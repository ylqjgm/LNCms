# TASK006-13: 创建AuthorService接口和实现 - 基础CRUD

## 任务信息

**任务编号**: TASK006-13  
**父任务**: TASK006  
**任务名称**: 创建AuthorService接口和实现 - 基础CRUD  
**版本信息**: v1.2.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 20:48:19 CST

## 任务描述

创建作者服务，提供作者管理的基础CRUD功能。包括：1) 定义AuthorService接口（GetAuthor、GetAuthors、CreateAuthor、UpdateAuthor、DeleteAuthor方法）；2) 实现作者查询（单个作者、作者列表，支持分页和筛选）；3) 实现作者创建（管理员创建作者）；4) 实现作者更新；5) 实现作者删除。所有代码必须遵循Golang编码规范，错误消息使用中文。参考TASK005-14用户服务实现。

## 依赖任务

TASK006-04（实现AuthorRepository接口和实现）、TASK006-07（复用PasswordService）

## 实现指南

### 1. 定义AuthorService接口

在 `internal/service/` 目录下创建 `author_service.go` 文件，定义AuthorService接口：

```go
package service

import (
    "context"
    "yourproject/internal/dto"
)

// AuthorService 作者服务接口
// 提供作者管理的CRUD功能
type AuthorService interface {
    // GetAuthor 根据ID获取作者
    GetAuthor(ctx context.Context, authorID int64) (*dto.AuthorInfo, error)
    
    // GetAuthors 获取作者列表，支持分页和筛选
    GetAuthors(ctx context.Context, params *dto.AuthorQueryParams) (*dto.AuthorListResponse, error)
    
    // CreateAuthor 创建作者（管理员操作）
    CreateAuthor(ctx context.Context, req *dto.CreateAuthorRequest) (*dto.AuthorInfo, error)
    
    // UpdateAuthor 更新作者信息
    UpdateAuthor(ctx context.Context, authorID int64, req *dto.UpdateAuthorRequest) (*dto.AuthorInfo, error)
    
    // DeleteAuthor 删除作者
    DeleteAuthor(ctx context.Context, authorID int64) error
}
```

### 2. 定义DTO结构

在 `internal/dto/` 目录下创建或扩展 `author_dto.go` 文件：

```go
package dto

import (
    "github.com/lib/pq"
)

// AuthorQueryParams 作者查询参数
type AuthorQueryParams struct {
    Page          int     `form:"page"`           // 页码，从1开始
    Limit         int     `form:"limit"`          // 每页数量
    AuthorName    string  `form:"author_name"`   // 作者名筛选（模糊匹配）
    Email         string  `form:"email"`         // 邮箱筛选（模糊匹配）
    Phone         string  `form:"phone"`         // 手机号筛选（模糊匹配）
    IsActive      *bool   `form:"is_active"`     // 激活状态筛选
    IsLocked      *bool   `form:"is_locked"`     // 锁定状态筛选
    AuthorLevelID *int64  `form:"author_level_id"` // 作者等级ID筛选
    UserID        *int64  `form:"user_id"`       // 用户ID筛选
    AuthorTypeIDs []int32 `form:"author_type_ids"` // 作者类型ID数组筛选
    SortBy        string  `form:"sort_by"`       // 排序字段
    SortOrder     string  `form:"sort_order"`    // 排序方向：asc、desc
}

// AuthorListResponse 作者列表响应
type AuthorListResponse struct {
    Authors    []*AuthorInfo `json:"authors"`     // 作者列表
    Total      int64         `json:"total"`      // 总记录数
    Page       int           `json:"page"`        // 当前页码
    Limit      int           `json:"limit"`       // 每页数量
    TotalPages int           `json:"total_pages"` // 总页数
}

// CreateAuthorRequest 创建作者请求
type CreateAuthorRequest struct {
    AuthorName    string   `json:"author_name" binding:"required,min=3,max=100"`
    Email         string   `json:"email" binding:"required,email"`
    Phone         *string  `json:"phone,omitempty"`
    Password      string   `json:"password" binding:"required,min=8"`
    EmailVerified bool     `json:"email_verified,omitempty"`
    PhoneVerified bool     `json:"phone_verified,omitempty"`
    IsActive      bool     `json:"is_active,omitempty"`
    IsLocked      bool     `json:"is_locked,omitempty"`
    AuthorTypeIDs []int32  `json:"author_type_ids" binding:"required,min=1"`
    AuthorLevelID *int64   `json:"author_level_id,omitempty"`
    UserID        *int64   `json:"user_id,omitempty"`
}

// UpdateAuthorRequest 更新作者请求
type UpdateAuthorRequest struct {
    AuthorName    *string  `json:"author_name,omitempty"`
    Email         *string  `json:"email,omitempty"`
    Phone         *string  `json:"phone,omitempty"`
    Password      *string  `json:"password,omitempty"`
    EmailVerified *bool    `json:"email_verified,omitempty"`
    PhoneVerified *bool    `json:"phone_verified,omitempty"`
    AuthorTypeIDs []int32  `json:"author_type_ids,omitempty"`
    AuthorLevelID *int64   `json:"author_level_id,omitempty"`
    UserID        *int64   `json:"user_id,omitempty"`
}
```

### 3. 实现AuthorService接口

在同一个文件中实现AuthorService接口：

```go
// authorService AuthorService的实现
type authorService struct {
    authorRepo      repository.AuthorRepository
    passwordService PasswordService
}

// NewAuthorService 创建AuthorService实例
func NewAuthorService(
    authorRepo repository.AuthorRepository,
    passwordService PasswordService,
) AuthorService {
    return &authorService{
        authorRepo:      authorRepo,
        passwordService: passwordService,
    }
}

// GetAuthor 根据ID获取作者
func (s *authorService) GetAuthor(ctx context.Context, authorID int64) (*dto.AuthorInfo, error) {
    author, err := s.authorRepo.GetByID(ctx, authorID)
    if err != nil {
        return nil, err
    }
    return dto.ToAuthorInfo(author), nil
}

// GetAuthors 获取作者列表，支持分页和筛选
func (s *authorService) GetAuthors(ctx context.Context, params *dto.AuthorQueryParams) (*dto.AuthorListResponse, error) {
    // 转换DTO参数为Repository参数
    repoParams := &repository.AuthorQueryParams{
        Page:          params.Page,
        Limit:         params.Limit,
        AuthorName:    params.AuthorName,
        Email:         params.Email,
        Phone:         params.Phone,
        IsActive:      params.IsActive,
        IsLocked:      params.IsLocked,
        AuthorLevelID: params.AuthorLevelID,
        UserID:        params.UserID,
        AuthorTypeIDs: params.AuthorTypeIDs,
        SortBy:        params.SortBy,
        SortOrder:     params.SortOrder,
    }
    
    authors, total, err := s.authorRepo.GetAll(ctx, repoParams)
    if err != nil {
        return nil, fmt.Errorf("查询作者列表失败: %w", err)
    }
    
    // 转换为DTO
    authorInfos := make([]*dto.AuthorInfo, len(authors))
    for i, author := range authors {
        authorInfos[i] = dto.ToAuthorInfo(author)
    }
    
    // 计算总页数
    totalPages := int((total + int64(params.Limit) - 1) / int64(params.Limit))
    if totalPages == 0 {
        totalPages = 1
    }
    
    return &dto.AuthorListResponse{
        Authors:    authorInfos,
        Total:      total,
        Page:       params.Page,
        Limit:      params.Limit,
        TotalPages: totalPages,
    }, nil
}

// CreateAuthor 创建作者（管理员操作）
func (s *authorService) CreateAuthor(ctx context.Context, req *dto.CreateAuthorRequest) (*dto.AuthorInfo, error) {
    // 1. 验证作者名唯一性
    exists, err := s.authorRepo.ExistsByAuthorName(ctx, req.AuthorName)
    if err != nil {
        return nil, fmt.Errorf("检查作者名失败: %w", err)
    }
    if exists {
        return nil, fmt.Errorf("作者名已被使用")
    }
    
    // 2. 验证邮箱唯一性
    exists, err = s.authorRepo.ExistsByEmail(ctx, req.Email)
    if err != nil {
        return nil, fmt.Errorf("检查邮箱失败: %w", err)
    }
    if exists {
        return nil, fmt.Errorf("邮箱已被使用")
    }
    
    // 3. 验证手机号唯一性（如果提供）
    if req.Phone != nil && *req.Phone != "" {
        exists, err = s.authorRepo.ExistsByPhone(ctx, *req.Phone)
        if err != nil {
            return nil, fmt.Errorf("检查手机号失败: %w", err)
        }
        if exists {
            return nil, fmt.Errorf("手机号已被使用")
        }
    }
    
    // 4. 验证密码强度
    if err := s.passwordService.ValidatePasswordStrength(req.Password); err != nil {
        return nil, fmt.Errorf("密码强度不符合要求: %w", err)
    }
    
    // 5. 哈希密码
    passwordHash, err := s.passwordService.HashPassword(req.Password)
    if err != nil {
        return nil, fmt.Errorf("密码加密失败: %w", err)
    }
    
    // 6. 创建作者
    author := &models.Author{
        AuthorName:    req.AuthorName,
        Email:         req.Email,
        PasswordHash:  passwordHash,
        EmailVerified: req.EmailVerified,
        PhoneVerified: req.PhoneVerified,
        IsActive:      req.IsActive,
        IsLocked:      req.IsLocked,
        AuthorTypeIDs: pq.Int32Array(req.AuthorTypeIDs),
        AuthorLevelID: req.AuthorLevelID,
        UserID:        req.UserID,
    }
    
    if req.Phone != nil {
        author.Phone = req.Phone
    }
    
    if err := s.authorRepo.Create(ctx, author); err != nil {
        return nil, fmt.Errorf("创建作者失败: %w", err)
    }
    
    return dto.ToAuthorInfo(author), nil
}

// UpdateAuthor 更新作者信息
func (s *authorService) UpdateAuthor(ctx context.Context, authorID int64, req *dto.UpdateAuthorRequest) (*dto.AuthorInfo, error) {
    // 1. 获取作者
    author, err := s.authorRepo.GetByID(ctx, authorID)
    if err != nil {
        return nil, err
    }
    
    // 2. 更新字段（仅更新提供的字段）
    if req.AuthorName != nil {
        // 验证作者名唯一性（如果修改）
        if *req.AuthorName != author.AuthorName {
            exists, err := s.authorRepo.ExistsByAuthorName(ctx, *req.AuthorName)
            if err != nil {
                return nil, fmt.Errorf("检查作者名失败: %w", err)
            }
            if exists {
                return nil, fmt.Errorf("作者名已被使用")
            }
        }
        author.AuthorName = *req.AuthorName
    }
    
    if req.Email != nil {
        // 验证邮箱唯一性（如果修改）
        if *req.Email != author.Email {
            exists, err := s.authorRepo.ExistsByEmail(ctx, *req.Email)
            if err != nil {
                return nil, fmt.Errorf("检查邮箱失败: %w", err)
            }
            if exists {
                return nil, fmt.Errorf("邮箱已被使用")
            }
        }
        author.Email = *req.Email
    }
    
    if req.Phone != nil {
        author.Phone = req.Phone
    }
    
    if req.Password != nil {
        // 验证密码强度
        if err := s.passwordService.ValidatePasswordStrength(*req.Password); err != nil {
            return nil, fmt.Errorf("密码强度不符合要求: %w", err)
        }
        
        // 哈希密码
        passwordHash, err := s.passwordService.HashPassword(*req.Password)
        if err != nil {
            return nil, fmt.Errorf("密码加密失败: %w", err)
        }
        author.PasswordHash = passwordHash
    }
    
    if req.EmailVerified != nil {
        author.EmailVerified = *req.EmailVerified
    }
    
    if req.PhoneVerified != nil {
        author.PhoneVerified = *req.PhoneVerified
    }
    
    if req.AuthorTypeIDs != nil {
        author.AuthorTypeIDs = pq.Int32Array(req.AuthorTypeIDs)
    }
    
    if req.AuthorLevelID != nil {
        author.AuthorLevelID = req.AuthorLevelID
    }
    
    if req.UserID != nil {
        author.UserID = req.UserID
    }
    
    // 3. 保存更新
    if err := s.authorRepo.Update(ctx, author); err != nil {
        return nil, fmt.Errorf("更新作者失败: %w", err)
    }
    
    return dto.ToAuthorInfo(author), nil
}

// DeleteAuthor 删除作者
func (s *authorService) DeleteAuthor(ctx context.Context, authorID int64) error {
    // 检查作者是否存在
    _, err := s.authorRepo.GetByID(ctx, authorID)
    if err != nil {
        return err
    }
    
    // 删除作者
    if err := s.authorRepo.Delete(ctx, authorID); err != nil {
        return fmt.Errorf("删除作者失败: %w", err)
    }
    
    return nil
}
```

### 4. 添加必要的导入

```go
package service

import (
    "context"
    "fmt"
    
    "github.com/lib/pq"
    "yourproject/internal/dto"
    "yourproject/internal/models"
    "yourproject/internal/repository"
)
```

### 5. 注意事项

- **错误处理**：所有错误消息必须使用中文
- **唯一性验证**：创建和更新时验证作者名、邮箱、手机号的唯一性
- **密码处理**：更新密码时验证密码强度并哈希
- **数组处理**：author_type_ids数组正确转换
- **分页计算**：分页参数正确计算总页数

## 验收标准

1. **接口定义完整**
   - AuthorService接口包含所有必需方法
   - 方法签名正确

2. **DTO定义完整**
   - AuthorQueryParams结构体定义完整
   - AuthorListResponse结构体定义完整
   - CreateAuthorRequest结构体定义完整
   - UpdateAuthorRequest结构体定义完整

3. **实现完整**
   - 所有接口方法都已实现
   - 实现逻辑正确，符合业务需求
   - 错误处理完善，错误消息使用中文

4. **查询功能**
   - GetAuthors方法支持分页、筛选、排序
   - 数组查询（author_type_ids）正确实现

5. **代码规范**
   - 遵循Golang编码规范
   - 注释完整，使用中文

## 相关文件

- `internal/service/author_service.go` - AuthorService接口和实现文件（待创建）
- `internal/dto/author_dto.go` - 作者DTO文件（待创建）
- `docs/TASKS/TASK005/TASK005-14.md` - 用户服务实现参考
- `.cursor/rules/coding-standards.mdc` - Golang编码规范

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.0  
**最后更新**: 2026-01-03 20:48:19 CST

