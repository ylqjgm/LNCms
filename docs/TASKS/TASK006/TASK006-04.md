# TASK006-04: 实现AuthorRepository接口和实现

## 任务信息

**任务编号**: TASK006-04  
**父任务**: TASK006  
**任务名称**: 实现AuthorRepository接口和实现  
**版本信息**: v1.2.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 20:48:19 CST

## 任务描述

实现AuthorRepository接口，提供作者数据的CRUD操作。包括：1) 定义AuthorRepository接口（Create、GetByID、GetByAuthorName、GetByEmail、GetAll、Update、Delete、UpdateStatus、UpdateLastLoginAt等方法）；2) 实现AuthorRepository接口（使用GORM进行数据库操作）；3) 实现条件查询方法（支持分页、筛选、排序，包括按author_type_ids数组查询）。所有代码必须遵循Golang编码规范，错误消息使用中文。参考TASK005-04用户仓储层实现。

## 依赖任务

TASK006-01（创建Author模型）

## 实现指南

### 1. 定义AuthorRepository接口

在 `internal/repository/` 目录下创建 `author_repository.go` 文件，定义AuthorRepository接口：

```go
package repository

import (
    "context"
    "yourproject/internal/models"
)

// AuthorRepository 作者仓储接口
// 提供作者数据的CRUD操作和查询方法
type AuthorRepository interface {
    // Create 创建作者
    Create(ctx context.Context, author *models.Author) error
    
    // GetByID 根据ID获取作者
    GetByID(ctx context.Context, id int64) (*models.Author, error)
    
    // GetByAuthorName 根据作者名获取作者
    GetByAuthorName(ctx context.Context, authorName string) (*models.Author, error)
    
    // GetByEmail 根据邮箱获取作者
    GetByEmail(ctx context.Context, email string) (*models.Author, error)
    
    // GetByPhone 根据手机号获取作者
    GetByPhone(ctx context.Context, phone string) (*models.Author, error)
    
    // GetAll 获取作者列表，支持分页、筛选、排序
    GetAll(ctx context.Context, params *AuthorQueryParams) ([]*models.Author, int64, error)
    
    // Update 更新作者信息
    Update(ctx context.Context, author *models.Author) error
    
    // Delete 删除作者（软删除或硬删除）
    Delete(ctx context.Context, id int64) error
    
    // UpdateStatus 更新作者状态
    UpdateStatus(ctx context.Context, id int64, isActive bool) error
    
    // UpdateLastLoginAt 更新最后登录时间
    UpdateLastLoginAt(ctx context.Context, id int64) error
    
    // ExistsByAuthorName 检查作者名是否存在
    ExistsByAuthorName(ctx context.Context, authorName string) (bool, error)
    
    // ExistsByEmail 检查邮箱是否存在
    ExistsByEmail(ctx context.Context, email string) (bool, error)
    
    // ExistsByPhone 检查手机号是否存在
    ExistsByPhone(ctx context.Context, phone string) (bool, error)
}

// AuthorQueryParams 作者查询参数
type AuthorQueryParams struct {
    Page          int     // 页码，从1开始
    Limit         int     // 每页数量
    AuthorName    string  // 作者名筛选（模糊匹配）
    Email         string  // 邮箱筛选（模糊匹配）
    Phone         string  // 手机号筛选（模糊匹配）
    IsActive      *bool   // 激活状态筛选
    IsLocked      *bool   // 锁定状态筛选
    AuthorLevelID *int64 // 作者等级ID筛选
    UserID        *int64  // 用户ID筛选
    AuthorTypeIDs []int32 // 作者类型ID数组筛选（支持数组查询）
    SortBy        string  // 排序字段
    SortOrder     string  // 排序方向：asc、desc
}
```

### 2. 实现AuthorRepository接口

在同一个文件中实现AuthorRepository接口：

```go
// authorRepository AuthorRepository的实现
type authorRepository struct {
    db *gorm.DB
}

// NewAuthorRepository 创建AuthorRepository实例
func NewAuthorRepository(db *gorm.DB) AuthorRepository {
    return &authorRepository{db: db}
}

// Create 创建作者
func (r *authorRepository) Create(ctx context.Context, author *models.Author) error {
    if err := r.db.WithContext(ctx).Create(author).Error; err != nil {
        if errors.Is(err, gorm.ErrDuplicatedKey) {
            return fmt.Errorf("作者已存在：作者名或邮箱已被使用")
        }
        return fmt.Errorf("创建作者失败: %w", err)
    }
    return nil
}

// GetByID 根据ID获取作者
func (r *authorRepository) GetByID(ctx context.Context, id int64) (*models.Author, error) {
    var author models.Author
    if err := r.db.WithContext(ctx).Where("id = ?", id).First(&author).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, fmt.Errorf("作者不存在")
        }
        return nil, fmt.Errorf("查询作者失败: %w", err)
    }
    return &author, nil
}

// GetByAuthorName 根据作者名获取作者
func (r *authorRepository) GetByAuthorName(ctx context.Context, authorName string) (*models.Author, error) {
    var author models.Author
    if err := r.db.WithContext(ctx).Where("author_name = ?", authorName).First(&author).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, fmt.Errorf("作者不存在")
        }
        return nil, fmt.Errorf("查询作者失败: %w", err)
    }
    return &author, nil
}

// GetByEmail 根据邮箱获取作者
func (r *authorRepository) GetByEmail(ctx context.Context, email string) (*models.Author, error) {
    var author models.Author
    if err := r.db.WithContext(ctx).Where("email = ?", email).First(&author).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, fmt.Errorf("作者不存在")
        }
        return nil, fmt.Errorf("查询作者失败: %w", err)
    }
    return &author, nil
}

// GetByPhone 根据手机号获取作者
func (r *authorRepository) GetByPhone(ctx context.Context, phone string) (*models.Author, error) {
    var author models.Author
    if err := r.db.WithContext(ctx).Where("phone = ?", phone).First(&author).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, fmt.Errorf("作者不存在")
        }
        return nil, fmt.Errorf("查询作者失败: %w", err)
    }
    return &author, nil
}

// GetAll 获取作者列表，支持分页、筛选、排序
func (r *authorRepository) GetAll(ctx context.Context, params *AuthorQueryParams) ([]*models.Author, int64, error) {
    var authors []*models.Author
    var total int64
    
    query := r.db.WithContext(ctx).Model(&models.Author{})
    
    // 应用筛选条件
    if params.AuthorName != "" {
        query = query.Where("author_name LIKE ?", "%"+params.AuthorName+"%")
    }
    if params.Email != "" {
        query = query.Where("email LIKE ?", "%"+params.Email+"%")
    }
    if params.Phone != "" {
        query = query.Where("phone LIKE ?", "%"+params.Phone+"%")
    }
    if params.IsActive != nil {
        query = query.Where("is_active = ?", *params.IsActive)
    }
    if params.IsLocked != nil {
        query = query.Where("is_locked = ?", *params.IsLocked)
    }
    if params.AuthorLevelID != nil {
        query = query.Where("author_level_id = ?", *params.AuthorLevelID)
    }
    if params.UserID != nil {
        query = query.Where("user_id = ?", *params.UserID)
    }
    // 数组查询：查询包含指定类型ID的作者
    if len(params.AuthorTypeIDs) > 0 {
        // 使用PostgreSQL数组操作符 ANY 查询
        // 查询author_type_ids数组中包含任意一个指定类型ID的作者
        query = query.Where("author_type_ids && ?", pq.Array(params.AuthorTypeIDs))
    }
    
    // 统计总数
    if err := query.Count(&total).Error; err != nil {
        return nil, 0, fmt.Errorf("统计作者数量失败: %w", err)
    }
    
    // 应用排序
    sortBy := params.SortBy
    if sortBy == "" {
        sortBy = "created_at"
    }
    sortOrder := params.SortOrder
    if sortOrder == "" || (sortOrder != "asc" && sortOrder != "desc") {
        sortOrder = "desc"
    }
    query = query.Order(sortBy + " " + sortOrder)
    
    // 应用分页
    page := params.Page
    if page < 1 {
        page = 1
    }
    limit := params.Limit
    if limit < 1 {
        limit = 20
    }
    if limit > 100 {
        limit = 100
    }
    offset := (page - 1) * limit
    query = query.Offset(offset).Limit(limit)
    
    // 执行查询
    if err := query.Find(&authors).Error; err != nil {
        return nil, 0, fmt.Errorf("查询作者列表失败: %w", err)
    }
    
    return authors, total, nil
}

// Update 更新作者信息
func (r *authorRepository) Update(ctx context.Context, author *models.Author) error {
    if err := r.db.WithContext(ctx).Save(author).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return fmt.Errorf("作者不存在")
        }
        return fmt.Errorf("更新作者失败: %w", err)
    }
    return nil
}

// Delete 删除作者
func (r *authorRepository) Delete(ctx context.Context, id int64) error {
    result := r.db.WithContext(ctx).Delete(&models.Author{}, id)
    if result.Error != nil {
        return fmt.Errorf("删除作者失败: %w", result.Error)
    }
    if result.RowsAffected == 0 {
        return fmt.Errorf("作者不存在")
    }
    return nil
}

// UpdateStatus 更新作者状态
func (r *authorRepository) UpdateStatus(ctx context.Context, id int64, isActive bool) error {
    result := r.db.WithContext(ctx).Model(&models.Author{}).
        Where("id = ?", id).
        Update("is_active", isActive)
    if result.Error != nil {
        return fmt.Errorf("更新作者状态失败: %w", result.Error)
    }
    if result.RowsAffected == 0 {
        return fmt.Errorf("作者不存在")
    }
    return nil
}

// UpdateLastLoginAt 更新最后登录时间
func (r *authorRepository) UpdateLastLoginAt(ctx context.Context, id int64) error {
    now := time.Now()
    result := r.db.WithContext(ctx).Model(&models.Author{}).
        Where("id = ?", id).
        Update("last_login_at", now)
    if result.Error != nil {
        return fmt.Errorf("更新最后登录时间失败: %w", result.Error)
    }
    if result.RowsAffected == 0 {
        return fmt.Errorf("作者不存在")
    }
    return nil
}

// ExistsByAuthorName 检查作者名是否存在
func (r *authorRepository) ExistsByAuthorName(ctx context.Context, authorName string) (bool, error) {
    var count int64
    if err := r.db.WithContext(ctx).Model(&models.Author{}).
        Where("author_name = ?", authorName).
        Count(&count).Error; err != nil {
        return false, fmt.Errorf("检查作者名是否存在失败: %w", err)
    }
    return count > 0, nil
}

// ExistsByEmail 检查邮箱是否存在
func (r *authorRepository) ExistsByEmail(ctx context.Context, email string) (bool, error) {
    var count int64
    if err := r.db.WithContext(ctx).Model(&models.Author{}).
        Where("email = ?", email).
        Count(&count).Error; err != nil {
        return false, fmt.Errorf("检查邮箱是否存在失败: %w", err)
    }
    return count > 0, nil
}

// ExistsByPhone 检查手机号是否存在
func (r *authorRepository) ExistsByPhone(ctx context.Context, phone string) (bool, error) {
    var count int64
    if err := r.db.WithContext(ctx).Model(&models.Author{}).
        Where("phone = ?", phone).
        Count(&count).Error; err != nil {
        return false, fmt.Errorf("检查手机号是否存在失败: %w", err)
    }
    return count > 0, nil
}
```

### 3. 添加必要的导入

```go
package repository

import (
    "context"
    "errors"
    "fmt"
    "time"
    
    "github.com/lib/pq"
    "gorm.io/gorm"
    "yourproject/internal/models"
)
```

### 4. 数组查询说明

对于author_type_ids数组字段的查询，需要使用PostgreSQL数组操作符：

- **&& 操作符**：查询数组是否有重叠（包含任意一个指定值）
- **@> 操作符**：查询数组是否包含所有指定值
- **ANY 操作符**：查询数组是否包含指定值

示例：
```go
// 查询包含类型ID为1或2的作者（使用 && 操作符）
query = query.Where("author_type_ids && ?", pq.Array([]int32{1, 2}))

// 查询同时包含类型ID为1和2的作者（使用 @> 操作符）
query = query.Where("author_type_ids @> ?", pq.Array([]int32{1, 2}))

// 查询包含类型ID为1的作者（使用 ANY 操作符）
query = query.Where("? = ANY(author_type_ids)", 1)
```

### 5. 注意事项

- **错误处理**：所有错误消息必须使用中文
- **上下文传递**：所有方法都接受context.Context参数，支持超时和取消
- **参数验证**：在方法内部验证参数有效性
- **分页限制**：limit最大值为100，防止查询过多数据
- **模糊查询**：AuthorName、Email、Phone支持模糊匹配（LIKE查询）
- **数组查询**：AuthorTypeIDs使用PostgreSQL数组操作符进行查询
- **排序默认值**：默认按created_at降序排序
- **错误包装**：使用fmt.Errorf和%w动词包装错误，保留错误链
- **记录不存在**：当记录不存在时，返回明确的错误消息

## 验收标准

1. **接口定义完整**
   - AuthorRepository接口包含所有必需方法
   - 方法签名正确，参数和返回值类型正确
   - AuthorQueryParams结构体定义完整，包含AuthorTypeIDs数组字段

2. **实现完整**
   - 所有接口方法都已实现
   - 实现逻辑正确，符合业务需求
   - 错误处理完善，错误消息使用中文

3. **查询功能**
   - GetAll方法支持分页、筛选、排序
   - 筛选条件正确应用
   - 数组查询（author_type_ids）正确实现
   - 分页参数验证正确
   - 排序功能正确实现

4. **数组查询**
   - 支持按author_type_ids数组查询
   - 使用PostgreSQL数组操作符（&&、@>、ANY）
   - 数组查询性能优化（使用GIN索引）

5. **错误处理**
   - 所有错误都被正确处理
   - 错误消息清晰、具体，使用中文
   - 使用错误包装保留错误链

6. **代码规范**
   - 遵循Golang编码规范
   - 遵循GORM最佳实践
   - 注释完整，使用中文

## 相关文件

- `internal/models/author.go` - Author模型文件
- `docs/TASKS/TASK005/TASK005-04.md` - 用户仓储层实现参考
- `.cursor/rules/coding-standards.mdc` - Golang编码规范
- `internal/repository/author_repository.go` - AuthorRepository接口和实现文件（待创建）

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.0  
**最后更新**: 2026-01-03 20:48:19 CST

