# TASK006-26: 扩展JWT认证中间件支持作者token

## 任务信息

**任务编号**: TASK006-26  
**父任务**: TASK006  
**任务名称**: 扩展JWT认证中间件支持作者token  
**版本信息**: v1.2.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 20:48:19 CST

## 任务描述

扩展TASK005-27实现的JWT认证中间件，支持作者token验证。包括：1) 扩展JWTAuthMiddleware函数，支持作者token验证；2) 从请求头提取JWT token；3) 验证token类型（用户token或作者token）；4) 将作者信息存储到上下文（context）中；5) 如果token无效，返回401错误。所有代码必须遵循Golang编码规范和API设计规范。参考TASK005-27 JWT认证中间件实现。

## 依赖任务

TASK006-08（扩展JWTService支持作者token）

## 实现指南

### 1. 扩展JWT认证中间件

在 `internal/middleware/` 目录下的 `jwt_auth.go` 文件中，扩展JWTAuthMiddleware函数：

```go
package middleware

import (
    "net/http"
    "strings"
    
    "github.com/gin-gonic/gin"
    
    "yourproject/internal/service"
    "yourproject/pkg/response"
)

// JWTAuthMiddleware JWT认证中间件（扩展）
// 支持用户token和作者token验证
func JWTAuthMiddleware(jwtService service.JWTService) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. 从请求头提取JWT token
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            response.Unauthorized(c, "缺少认证信息", nil)
            c.Abort()
            return
        }
        
        // 提取token（格式：Bearer <token>）
        tokenParts := strings.Split(authHeader, " ")
        if len(tokenParts) != 2 || tokenParts[0] != "Bearer" {
            response.Unauthorized(c, "认证信息格式错误", nil)
            c.Abort()
            return
        }
        
        token := tokenParts[1]
        
        // 2. 验证token类型并解析
        // 先尝试验证为用户token
        userClaims, err := jwtService.ValidateToken(token)
        if err == nil && userClaims != nil {
            // 用户token验证成功
            c.Set("user_id", userClaims.UserID)
            c.Set("username", userClaims.Username)
            c.Set("role_id", userClaims.RoleID)
            c.Set("token_type", "user")
            c.Next()
            return
        }
        
        // 再尝试验证为作者token
        authorClaims, err := jwtService.ValidateAuthorToken(token)
        if err == nil && authorClaims != nil {
            // 作者token验证成功
            c.Set("author_id", authorClaims.AuthorID)
            c.Set("author_name", authorClaims.AuthorName)
            c.Set("author_type_ids", authorClaims.AuthorTypeIDs)
            c.Set("author_level_id", authorClaims.AuthorLevelID)
            c.Set("user_id", authorClaims.UserID) // 如果作者关联了用户
            c.Set("token_type", "author")
            c.Next()
            return
        }
        
        // 3. token验证失败
        response.Unauthorized(c, "无效的token或token已过期", nil)
        c.Abort()
    }
}
```

### 2. 创建辅助函数获取上下文信息

在中间件文件中添加辅助函数，便于从上下文获取用户或作者信息：

```go
// GetUserIDFromContext 从上下文获取用户ID
func GetUserIDFromContext(c *gin.Context) (int64, bool) {
    userID, exists := c.Get("user_id")
    if !exists {
        return 0, false
    }
    id, ok := userID.(int64)
    return id, ok
}

// GetAuthorIDFromContext 从上下文获取作者ID
func GetAuthorIDFromContext(c *gin.Context) (int64, bool) {
    authorID, exists := c.Get("author_id")
    if !exists {
        return 0, false
    }
    id, ok := authorID.(int64)
    return id, ok
}

// GetTokenTypeFromContext 从上下文获取token类型
func GetTokenTypeFromContext(c *gin.Context) (string, bool) {
    tokenType, exists := c.Get("token_type")
    if !exists {
        return "", false
    }
    t, ok := tokenType.(string)
    return t, ok
}

// IsAuthorToken 检查是否为作者token
func IsAuthorToken(c *gin.Context) bool {
    tokenType, exists := GetTokenTypeFromContext(c)
    return exists && tokenType == "author"
}

// IsUserToken 检查是否为用户token
func IsUserToken(c *gin.Context) bool {
    tokenType, exists := GetTokenTypeFromContext(c)
    return exists && tokenType == "user"
}
```

### 3. 可选：创建仅验证作者token的中间件

如果需要某些路由仅允许作者访问，可以创建专门的中间件：

```go
// AuthorAuthMiddleware 作者认证中间件
// 仅允许作者token访问
func AuthorAuthMiddleware(jwtService service.JWTService) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. 从请求头提取JWT token
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            response.Unauthorized(c, "缺少认证信息", nil)
            c.Abort()
            return
        }
        
        // 提取token
        tokenParts := strings.Split(authHeader, " ")
        if len(tokenParts) != 2 || tokenParts[0] != "Bearer" {
            response.Unauthorized(c, "认证信息格式错误", nil)
            c.Abort()
            return
        }
        
        token := tokenParts[1]
        
        // 2. 验证作者token
        authorClaims, err := jwtService.ValidateAuthorToken(token)
        if err != nil || authorClaims == nil {
            response.Unauthorized(c, "无效的作者token或token已过期", nil)
            c.Abort()
            return
        }
        
        // 3. 将作者信息存储到上下文
        c.Set("author_id", authorClaims.AuthorID)
        c.Set("author_name", authorClaims.AuthorName)
        c.Set("author_type_ids", authorClaims.AuthorTypeIDs)
        c.Set("author_level_id", authorClaims.AuthorLevelID)
        c.Set("user_id", authorClaims.UserID)
        c.Set("token_type", "author")
        
        c.Next()
    }
}
```

### 4. 注意事项

- **Token类型区分**：通过Subject字段或token验证结果区分用户token和作者token
- **上下文存储**：将用户或作者信息存储到Gin上下文中，便于后续处理函数使用
- **错误处理**：token无效时返回401未授权错误
- **向后兼容**：保持原有用户token验证功能不变
- **性能考虑**：先验证用户token，再验证作者token，或根据路由前缀选择验证方式

## 验收标准

1. **中间件扩展完整**
   - JWTAuthMiddleware支持作者token验证
   - 正确区分用户token和作者token

2. **上下文存储**
   - 作者信息正确存储到上下文
   - 辅助函数正确实现

3. **错误处理**
   - Token无效时返回401错误
   - 错误消息使用中文

4. **代码规范**
   - 遵循Golang编码规范
   - 遵循API设计规范

## 相关文件

- `internal/middleware/jwt_auth.go` - JWT认证中间件文件（需要扩展）
- `docs/TASKS/TASK005/TASK005-27.md` - JWT认证中间件实现参考
- `.cursor/rules/coding-standards.mdc` - Golang编码规范
- `.cursor/rules/api-design.mdc` - API设计规范

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.0  
**最后更新**: 2026-01-03 20:48:19 CST

