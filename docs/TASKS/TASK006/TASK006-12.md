# TASK006-12: 编写AuthService扩展单元测试

## 任务信息

**任务编号**: TASK006-12  
**父任务**: TASK006  
**任务名称**: 编写AuthService扩展单元测试  
**版本信息**: v1.2.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 20:48:19 CST

## 任务描述

编写认证服务扩展的单元测试。包括：1) 测试作者登录功能（正常登录、错误密码、作者锁定等）；2) 测试作者注册功能（正常注册、重复作者名、弱密码等）；3) 测试作者登出功能；4) 使用Mock Repository和Service进行测试；5) 确保测试覆盖率达标。所有测试用例描述必须使用中文。参考TASK005-13认证服务单元测试。

## 依赖任务

TASK006-11（创建AuthService扩展 - 作者注册）

## 实现指南

### 1. 创建测试文件

在 `internal/service/` 目录下创建或扩展 `auth_service_test.go` 文件，添加作者认证相关测试。

### 2. 测试AuthorLogin方法

```go
// TestAuthService_AuthorLogin 测试作者登录
func TestAuthService_AuthorLogin(t *testing.T) {
    tests := []struct {
        name    string
        req     *dto.AuthorLoginRequest
        setup   func(*MockAuthorRepository, *MockPasswordService, *MockJWTService, *MockAuthorLoginLogRepository)
        wantErr bool
        errMsg  string
    }{
        {
            name: "正常登录（使用作者名）",
            req: &dto.AuthorLoginRequest{
                AuthorNameOrEmail: "testauthor",
                Password:          "password123",
                IPAddress:         "127.0.0.1",
                UserAgent:         "test-agent",
            },
            setup: func(authorRepo *MockAuthorRepository, passwordService *MockPasswordService, jwtService *MockJWTService, logRepo *MockAuthorLoginLogRepository) {
                author := &models.Author{
                    ID:            1,
                    AuthorName:    "testauthor",
                    Email:         "test@example.com",
                    PasswordHash:  "hashed_password",
                    IsActive:      true,
                    IsLocked:      false,
                    EmailVerified: true,
                    AuthorTypeIDs: pq.Int32Array{1},
                }
                authorRepo.On("GetByAuthorName", mock.Anything, "testauthor").Return(author, nil)
                passwordService.On("VerifyPassword", "hashed_password", "password123").Return(true)
                jwtService.On("GenerateAuthorToken", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(&service.TokenPair{
                    AccessToken:  "access_token",
                    RefreshToken: "refresh_token",
                    ExpiresAt:   time.Now().Add(15 * time.Minute),
                }, nil)
                authorRepo.On("UpdateLastLoginAt", mock.Anything, int64(1)).Return(nil)
                logRepo.On("Create", mock.Anything, mock.Anything).Return(nil)
            },
            wantErr: false,
        },
        {
            name: "正常登录（使用邮箱）",
            req: &dto.AuthorLoginRequest{
                AuthorNameOrEmail: "test@example.com",
                Password:          "password123",
            },
            setup: func(authorRepo *MockAuthorRepository, passwordService *MockPasswordService, jwtService *MockJWTService, logRepo *MockAuthorLoginLogRepository) {
                author := &models.Author{
                    ID:            1,
                    AuthorName:    "testauthor",
                    Email:         "test@example.com",
                    PasswordHash:  "hashed_password",
                    IsActive:      true,
                    IsLocked:      false,
                    EmailVerified: true,
                }
                authorRepo.On("GetByEmail", mock.Anything, "test@example.com").Return(author, nil)
                passwordService.On("VerifyPassword", "hashed_password", "password123").Return(true)
                jwtService.On("GenerateAuthorToken", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(&service.TokenPair{}, nil)
                authorRepo.On("UpdateLastLoginAt", mock.Anything, int64(1)).Return(nil)
                logRepo.On("Create", mock.Anything, mock.Anything).Return(nil)
            },
            wantErr: false,
        },
        {
            name: "作者不存在",
            req: &dto.AuthorLoginRequest{
                AuthorNameOrEmail: "nonexistent",
                Password:          "password123",
            },
            setup: func(authorRepo *MockAuthorRepository, passwordService *MockPasswordService, jwtService *MockJWTService, logRepo *MockAuthorLoginLogRepository) {
                authorRepo.On("GetByAuthorName", mock.Anything, "nonexistent").Return(nil, fmt.Errorf("作者不存在"))
            },
            wantErr: true,
            errMsg:  "作者不存在或密码错误",
        },
        {
            name: "密码错误",
            req: &dto.AuthorLoginRequest{
                AuthorNameOrEmail: "testauthor",
                Password:          "wrong_password",
            },
            setup: func(authorRepo *MockAuthorRepository, passwordService *MockPasswordService, jwtService *MockJWTService, logRepo *MockAuthorLoginLogRepository) {
                author := &models.Author{
                    ID:            1,
                    AuthorName:    "testauthor",
                    PasswordHash:  "hashed_password",
                    IsActive:      true,
                    IsLocked:      false,
                    EmailVerified: true,
                }
                authorRepo.On("GetByAuthorName", mock.Anything, "testauthor").Return(author, nil)
                passwordService.On("VerifyPassword", "hashed_password", "wrong_password").Return(false)
                logRepo.On("Create", mock.Anything, mock.Anything).Return(nil)
            },
            wantErr: true,
            errMsg:   "作者不存在或密码错误",
        },
        {
            name: "作者未激活",
            req: &dto.AuthorLoginRequest{
                AuthorNameOrEmail: "testauthor",
                Password:          "password123",
            },
            setup: func(authorRepo *MockAuthorRepository, passwordService *MockPasswordService, jwtService *MockJWTService, logRepo *MockAuthorLoginLogRepository) {
                author := &models.Author{
                    ID:            1,
                    AuthorName:    "testauthor",
                    PasswordHash:  "hashed_password",
                    IsActive:      false,
                    IsLocked:      false,
                    EmailVerified: true,
                }
                authorRepo.On("GetByAuthorName", mock.Anything, "testauthor").Return(author, nil)
                logRepo.On("Create", mock.Anything, mock.Anything).Return(nil)
            },
            wantErr: true,
            errMsg:  "作者未激活",
        },
        {
            name: "作者已锁定",
            req: &dto.AuthorLoginRequest{
                AuthorNameOrEmail: "testauthor",
                Password:          "password123",
            },
            setup: func(authorRepo *MockAuthorRepository, passwordService *MockPasswordService, jwtService *MockJWTService, logRepo *MockAuthorLoginLogRepository) {
                author := &models.Author{
                    ID:            1,
                    AuthorName:    "testauthor",
                    PasswordHash:  "hashed_password",
                    IsActive:      true,
                    IsLocked:      true,
                    EmailVerified: true,
                }
                authorRepo.On("GetByAuthorName", mock.Anything, "testauthor").Return(author, nil)
                logRepo.On("Create", mock.Anything, mock.Anything).Return(nil)
            },
            wantErr: true,
            errMsg:  "作者已被锁定",
        },
        {
            name: "邮箱未验证",
            req: &dto.AuthorLoginRequest{
                AuthorNameOrEmail: "testauthor",
                Password:          "password123",
            },
            setup: func(authorRepo *MockAuthorRepository, passwordService *MockPasswordService, jwtService *MockJWTService, logRepo *MockAuthorLoginLogRepository) {
                author := &models.Author{
                    ID:            1,
                    AuthorName:    "testauthor",
                    PasswordHash:  "hashed_password",
                    IsActive:      true,
                    IsLocked:      false,
                    EmailVerified: false,
                }
                authorRepo.On("GetByAuthorName", mock.Anything, "testauthor").Return(author, nil)
                logRepo.On("Create", mock.Anything, mock.Anything).Return(nil)
            },
            wantErr: true,
            errMsg:  "邮箱未验证",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 创建Mock
            mockAuthorRepo := new(MockAuthorRepository)
            mockPasswordService := new(MockPasswordService)
            mockJWTService := new(MockJWTService)
            mockLogRepo := new(MockAuthorLoginLogRepository)
            
            // 设置Mock期望
            if tt.setup != nil {
                tt.setup(mockAuthorRepo, mockPasswordService, mockJWTService, mockLogRepo)
            }
            
            // 创建服务
            service := NewAuthService(
                nil,
                mockAuthorRepo,
                mockPasswordService,
                mockJWTService,
                nil,
                mockLogRepo,
                nil,
            )
            
            // 执行测试
            resp, err := service.AuthorLogin(context.Background(), tt.req)
            
            if tt.wantErr {
                require.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
                assert.Nil(t, resp)
            } else {
                require.NoError(t, err)
                assert.NotNil(t, resp)
                assert.NotEmpty(t, resp.AccessToken)
            }
        })
    }
}
```

### 3. 测试AuthorRegister方法

```go
// TestAuthService_AuthorRegister 测试作者注册
func TestAuthService_AuthorRegister(t *testing.T) {
    tests := []struct {
        name    string
        req     *dto.AuthorRegisterRequest
        config  *config.AuthorRegisterConfig
        setup   func(*MockAuthorRepository, *MockPasswordService, *MockJWTService)
        wantErr bool
        errMsg  string
    }{
        {
            name: "正常注册",
            req: &dto.AuthorRegisterRequest{
                AuthorName:    "newauthor",
                Email:         "new@example.com",
                Password:      "password123",
                AuthorTypeIDs: []int32{1},
            },
            config: &config.AuthorRegisterConfig{
                Enabled:           true,
                RequireEmailVerify: false,
                RequireApproval:   false,
            },
            setup: func(authorRepo *MockAuthorRepository, passwordService *MockPasswordService, jwtService *MockJWTService) {
                authorRepo.On("ExistsByAuthorName", mock.Anything, "newauthor").Return(false, nil)
                authorRepo.On("ExistsByEmail", mock.Anything, "new@example.com").Return(false, nil)
                passwordService.On("ValidatePasswordStrength", "password123").Return(nil)
                passwordService.On("HashPassword", "password123").Return("hashed_password", nil)
                authorRepo.On("Create", mock.Anything, mock.Anything).Return(nil)
                jwtService.On("GenerateAuthorToken", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(&service.TokenPair{
                    AccessToken:  "access_token",
                    RefreshToken: "refresh_token",
                    ExpiresAt:   time.Now().Add(15 * time.Minute),
                }, nil)
            },
            wantErr: false,
        },
        {
            name: "重复作者名",
            req: &dto.AuthorRegisterRequest{
                AuthorName:    "existingauthor",
                Email:         "new@example.com",
                Password:      "password123",
                AuthorTypeIDs: []int32{1},
            },
            config: &config.AuthorRegisterConfig{
                Enabled: true,
            },
            setup: func(authorRepo *MockAuthorRepository, passwordService *MockPasswordService, jwtService *MockJWTService) {
                authorRepo.On("ExistsByAuthorName", mock.Anything, "existingauthor").Return(true, nil)
            },
            wantErr: true,
            errMsg:  "作者名已被使用",
        },
        {
            name: "弱密码",
            req: &dto.AuthorRegisterRequest{
                AuthorName:    "newauthor",
                Email:         "new@example.com",
                Password:      "123",
                AuthorTypeIDs: []int32{1},
            },
            config: &config.AuthorRegisterConfig{
                Enabled: true,
            },
            setup: func(authorRepo *MockAuthorRepository, passwordService *MockPasswordService, jwtService *MockJWTService) {
                authorRepo.On("ExistsByAuthorName", mock.Anything, "newauthor").Return(false, nil)
                authorRepo.On("ExistsByEmail", mock.Anything, "new@example.com").Return(false, nil)
                passwordService.On("ValidatePasswordStrength", "123").Return(fmt.Errorf("密码长度不足"))
            },
            wantErr: true,
            errMsg:  "密码强度不符合要求",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 创建Mock
            mockAuthorRepo := new(MockAuthorRepository)
            mockPasswordService := new(MockPasswordService)
            mockJWTService := new(MockJWTService)
            
            // 设置Mock期望
            if tt.setup != nil {
                tt.setup(mockAuthorRepo, mockPasswordService, mockJWTService)
            }
            
            // 创建服务
            service := NewAuthService(
                nil,
                mockAuthorRepo,
                mockPasswordService,
                mockJWTService,
                nil,
                nil,
                tt.config,
            )
            
            // 执行测试
            resp, err := service.AuthorRegister(context.Background(), tt.req)
            
            if tt.wantErr {
                require.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
                assert.Nil(t, resp)
            } else {
                require.NoError(t, err)
                assert.NotNil(t, resp)
            }
        })
    }
}
```

### 4. 测试AuthorLogout方法

```go
// TestAuthService_AuthorLogout 测试作者登出
func TestAuthService_AuthorLogout(t *testing.T) {
    mockJWTService := new(MockJWTService)
    service := NewAuthService(
        nil,
        nil,
        nil,
        mockJWTService,
        nil,
        nil,
        nil,
    )
    
    token := "test_token"
    mockJWTService.On("BlacklistToken", token).Return(nil)
    
    err := service.AuthorLogout(context.Background(), token)
    require.NoError(t, err)
}
```

### 5. 注意事项

- **Mock使用**：使用Mock Repository和Service进行测试，避免依赖真实数据库
- **测试覆盖**：确保测试覆盖所有新增的方法和场景
- **边界情况**：测试各种错误场景和边界情况
- **测试描述**：所有测试用例名称使用中文

## 验收标准

1. **测试覆盖完整**
   - AuthorLogin方法有完整测试
   - AuthorRegister方法有完整测试
   - AuthorLogout方法有完整测试

2. **测试覆盖率**
   - 测试覆盖率达到80%以上
   - 使用go test -cover检查覆盖率

3. **测试描述**
   - 所有测试用例名称使用中文
   - 错误消息使用中文

4. **代码规范**
   - 遵循Golang测试规范
   - 使用testify进行断言
   - 使用Mock进行依赖隔离

## 相关文件

- `internal/service/auth_service.go` - AuthService接口和实现文件
- `docs/TASKS/TASK005/TASK005-13.md` - 认证服务单元测试参考
- `.cursor/rules/testing.mdc` - Golang单元测试规范
- `internal/service/auth_service_test.go` - AuthService单元测试文件（需要扩展）

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.0  
**最后更新**: 2026-01-03 20:48:19 CST

