# TASK005-09: 创建JWTService接口和实现

## 任务信息

**任务编号**: TASK005-09  
**父任务**: TASK005  
**任务名称**: 创建JWTService接口和实现  
**版本信息**: v1.1.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 20:06:59 CST

## 任务描述

创建JWT服务，提供token生成、验证和刷新功能。包括：1) 定义JWTService接口（GenerateToken、ValidateToken、RefreshToken、BlacklistToken等方法）；2) 实现token生成（使用github.com/golang-jwt/jwt/v5，HS256算法）；3) 实现token验证；4) 实现token刷新；5) 集成SessionRepository进行token黑名单管理。所有代码必须遵循Golang编码规范和安全规范。

## 依赖任务

TASK005-05（实现SessionRepository接口和实现）

## 实现指南

### 1. 定义JWT Claims结构

在 `internal/service/` 目录下创建 `jwt_service.go` 文件，定义JWT Claims：

```go
package service

import (
    "time"
    
    "github.com/golang-jwt/jwt/v5"
)

// JWTClaims JWT Claims结构
type JWTClaims struct {
    UserID   int64  `json:"user_id"`
    Username string `json:"username"`
    RoleID   *int64 `json:"role_id,omitempty"`
    jwt.RegisteredClaims
}
```

### 2. 定义JWTService接口

```go
// JWTService JWT服务接口
// 提供token生成、验证和刷新功能
type JWTService interface {
    // GenerateToken 生成JWT token
    // 返回access token和refresh token
    GenerateToken(userID int64, username string, roleID *int64) (*TokenPair, error)
    
    // ValidateToken 验证JWT token
    // 返回Claims和是否有效
    ValidateToken(tokenString string) (*JWTClaims, error)
    
    // RefreshToken 刷新token
    // 使用refresh token生成新的token对
    RefreshToken(refreshToken string) (*TokenPair, error)
    
    // BlacklistToken 将token加入黑名单
    BlacklistToken(token string) error
    
    // IsBlacklisted 检查token是否在黑名单中
    IsBlacklisted(token string) (bool, error)
}

// TokenPair token对
type TokenPair struct {
    AccessToken  string    `json:"access_token"`
    RefreshToken string    `json:"refresh_token"`
    ExpiresAt    time.Time `json:"expires_at"`
}
```

### 3. 定义JWT配置

```go
// JWTConfig JWT配置
type JWTConfig struct {
    SecretKey           []byte        // 密钥
    AccessTokenExpiry  time.Duration  // Access token过期时间，默认15分钟
    RefreshTokenExpiry time.Duration  // Refresh token过期时间，默认7天
    Issuer             string         // 签发者
}

// DefaultJWTConfig 默认JWT配置
func DefaultJWTConfig(secretKey string) *JWTConfig {
    return &JWTConfig{
        SecretKey:           []byte(secretKey),
        AccessTokenExpiry:  15 * time.Minute,
        RefreshTokenExpiry: 7 * 24 * time.Hour,
        Issuer:             "lncms",
    }
}
```

### 4. 实现JWTService接口

```go
package service

import (
    "errors"
    "fmt"
    "time"
    
    "github.com/golang-jwt/jwt/v5"
    "yourproject/internal/repository"
)

// jwtService JWTService的实现
type jwtService struct {
    config           *JWTConfig
    sessionRepo      repository.SessionRepository
}

// NewJWTService 创建JWTService实例
func NewJWTService(config *JWTConfig, sessionRepo repository.SessionRepository) JWTService {
    if config == nil {
        panic("JWT配置不能为空")
    }
    if sessionRepo == nil {
        panic("SessionRepository不能为空")
    }
    
    return &jwtService{
        config:      config,
        sessionRepo: sessionRepo,
    }
}

// GenerateToken 生成JWT token
func (s *jwtService) GenerateToken(userID int64, username string, roleID *int64) (*TokenPair, error) {
    now := time.Now()
    
    // 生成access token
    accessClaims := JWTClaims{
        UserID:   userID,
        Username: username,
        RoleID:   roleID,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(now.Add(s.config.AccessTokenExpiry)),
            IssuedAt:  jwt.NewNumericDate(now),
            NotBefore: jwt.NewNumericDate(now),
            Issuer:    s.config.Issuer,
            Subject:   fmt.Sprintf("%d", userID),
        },
    }
    
    accessToken := jwt.NewWithClaims(jwt.SigningMethodHS256, accessClaims)
    accessTokenString, err := accessToken.SignedString(s.config.SecretKey)
    if err != nil {
        return nil, fmt.Errorf("生成access token失败: %w", err)
    }
    
    // 生成refresh token
    refreshClaims := JWTClaims{
        UserID:   userID,
        Username: username,
        RoleID:   roleID,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(now.Add(s.config.RefreshTokenExpiry)),
            IssuedAt:  jwt.NewNumericDate(now),
            NotBefore: jwt.NewNumericDate(now),
            Issuer:    s.config.Issuer,
            Subject:   fmt.Sprintf("%d", userID),
        },
    }
    
    refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims)
    refreshTokenString, err := refreshToken.SignedString(s.config.SecretKey)
    if err != nil {
        return nil, fmt.Errorf("生成refresh token失败: %w", err)
    }
    
    // 存储会话到数据库
    ctx := context.Background()
    accessSession := &models.UserSession{
        UserID:    userID,
        Token:     accessTokenString,
        TokenType: models.TokenTypeAccess,
        ExpiresAt: now.Add(s.config.AccessTokenExpiry),
    }
    if err := s.sessionRepo.Create(ctx, accessSession); err != nil {
        return nil, fmt.Errorf("存储access token会话失败: %w", err)
    }
    
    refreshSession := &models.UserSession{
        UserID:    userID,
        Token:     refreshTokenString,
        TokenType: models.TokenTypeRefresh,
        ExpiresAt: now.Add(s.config.RefreshTokenExpiry),
    }
    if err := s.sessionRepo.Create(ctx, refreshSession); err != nil {
        return nil, fmt.Errorf("存储refresh token会话失败: %w", err)
    }
    
    return &TokenPair{
        AccessToken:  accessTokenString,
        RefreshToken: refreshTokenString,
        ExpiresAt:    now.Add(s.config.AccessTokenExpiry),
    }, nil
}

// ValidateToken 验证JWT token
func (s *jwtService) ValidateToken(tokenString string) (*JWTClaims, error) {
    // 检查token是否在黑名单中
    isBlacklisted, err := s.IsBlacklisted(tokenString)
    if err != nil {
        return nil, fmt.Errorf("检查token黑名单状态失败: %w", err)
    }
    if isBlacklisted {
        return nil, errors.New("token已被加入黑名单")
    }
    
    // 解析token
    token, err := jwt.ParseWithClaims(tokenString, &JWTClaims{}, func(token *jwt.Token) (interface{}, error) {
        // 验证签名算法
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, fmt.Errorf("不支持的签名算法: %v", token.Header["alg"])
        }
        return s.config.SecretKey, nil
    })
    
    if err != nil {
        return nil, fmt.Errorf("解析token失败: %w", err)
    }
    
    // 验证token是否有效
    if !token.Valid {
        return nil, errors.New("token无效")
    }
    
    // 提取Claims
    claims, ok := token.Claims.(*JWTClaims)
    if !ok {
        return nil, errors.New("无法提取Claims")
    }
    
    // 验证过期时间
    if claims.ExpiresAt != nil && claims.ExpiresAt.Time.Before(time.Now()) {
        return nil, errors.New("token已过期")
    }
    
    return claims, nil
}

// RefreshToken 刷新token
func (s *jwtService) RefreshToken(refreshToken string) (*TokenPair, error) {
    // 验证refresh token
    claims, err := s.ValidateToken(refreshToken)
    if err != nil {
        return nil, fmt.Errorf("refresh token验证失败: %w", err)
    }
    
    // 检查token类型
    ctx := context.Background()
    session, err := s.sessionRepo.GetByToken(ctx, refreshToken)
    if err != nil {
        return nil, fmt.Errorf("获取refresh token会话失败: %w", err)
    }
    if session.TokenType != models.TokenTypeRefresh {
        return nil, errors.New("不是有效的refresh token")
    }
    
    // 将旧的refresh token加入黑名单
    if err := s.BlacklistToken(refreshToken); err != nil {
        return nil, fmt.Errorf("将旧refresh token加入黑名单失败: %w", err)
    }
    
    // 生成新的token对
    return s.GenerateToken(claims.UserID, claims.Username, claims.RoleID)
}

// BlacklistToken 将token加入黑名单
func (s *jwtService) BlacklistToken(token string) error {
    ctx := context.Background()
    return s.sessionRepo.BlacklistToken(ctx, token)
}

// IsBlacklisted 检查token是否在黑名单中
func (s *jwtService) IsBlacklisted(token string) (bool, error) {
    ctx := context.Background()
    return s.sessionRepo.IsBlacklisted(ctx, token)
}
```

### 5. 添加必要的导入

```go
package service

import (
    "context"
    "errors"
    "fmt"
    "time"
    
    "github.com/golang-jwt/jwt/v5"
    "yourproject/internal/models"
    "yourproject/internal/repository"
)
```

### 6. 错误定义

```go
// JWT服务错误定义
var (
    ErrTokenInvalid      = errors.New("token无效")
    ErrTokenExpired      = errors.New("token已过期")
    ErrTokenBlacklisted  = errors.New("token已被加入黑名单")
    ErrInvalidTokenType  = errors.New("无效的token类型")
)
```

### 7. 注意事项

- **签名算法**：使用HS256算法，确保密钥安全
- **过期时间**：Access token默认15分钟，Refresh token默认7天
- **黑名单机制**：集成SessionRepository进行token黑名单管理
- **错误处理**：所有错误消息使用中文，清晰描述问题
- **安全性**：密钥必须保密，不要硬编码在代码中
- **Claims验证**：验证token的所有必要字段，包括过期时间

## 验收标准

1. **接口定义完整**
   - JWTService接口包含所有必需方法
   - 方法签名正确，参数和返回值类型正确

2. **实现完整**
   - 所有接口方法都已实现
   - 实现逻辑正确，符合安全规范
   - 错误处理完善，错误消息使用中文

3. **Token生成功能**
   - GenerateToken方法正确生成access token和refresh token
   - Token包含必要的Claims信息
   - Token正确存储到数据库

4. **Token验证功能**
   - ValidateToken方法正确验证token
   - 检查token黑名单状态
   - 验证token过期时间

5. **Token刷新功能**
   - RefreshToken方法正确刷新token
   - 旧的refresh token被加入黑名单
   - 生成新的token对

6. **黑名单功能**
   - BlacklistToken方法正确实现
   - IsBlacklisted方法正确实现
   - 集成SessionRepository进行黑名单管理

7. **代码规范**
   - 遵循Golang编码规范
   - 遵循安全开发规范
   - 注释完整，使用中文

## 相关文件

- `internal/repository/session_repository.go` - SessionRepository实现文件
- `internal/models/user_session.go` - UserSession模型文件
- `.cursor/rules/security.mdc` - 应用安全开发规范
- `.cursor/rules/coding-standards.mdc` - Golang编码规范
- `internal/service/jwt_service.go` - JWTService接口和实现文件（待创建）

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.1  
**最后更新**: 2026-01-03 20:06:59 CST

