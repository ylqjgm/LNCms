# TASK005-13: 编写AuthService单元测试

## 任务信息

**任务编号**: TASK005-13  
**父任务**: TASK005  
**任务名称**: 编写AuthService单元测试  
**版本信息**: v1.1.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 20:26:31 CST

## 任务描述

编写认证服务单元测试。包括：1) 测试登录功能（正常登录、错误密码、用户锁定等）；2) 测试注册功能（正常注册、重复用户名、弱密码等）；3) 测试登出功能；4) 使用Mock Repository和Service进行测试；5) 确保测试覆盖率达标。所有测试用例描述必须使用中文。

## 依赖任务

TASK005-12（创建AuthService接口和实现 - 用户注册）

## 实现指南

### 1. 创建测试文件

在 `internal/service/` 目录下创建 `auth_service_test.go` 文件。

### 2. 设置测试依赖

```go
package service

import (
    "context"
    "testing"
    "time"
    
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
    "github.com/stretchr/testify/require"
    
    "yourproject/internal/config"
    "yourproject/internal/dto"
    "yourproject/internal/models"
    "yourproject/internal/repository"
)
```

### 3. 定义Mock结构

```go
// MockUserRepository Mock UserRepository
type MockUserRepository struct {
    mock.Mock
}

func (m *MockUserRepository) GetByUsername(ctx context.Context, username string) (*models.User, error) {
    args := m.Called(ctx, username)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*models.User), args.Error(1)
}

func (m *MockUserRepository) GetByEmail(ctx context.Context, email string) (*models.User, error) {
    args := m.Called(ctx, email)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*models.User), args.Error(1)
}

// ... 其他方法

// MockPasswordService Mock PasswordService
type MockPasswordService struct {
    mock.Mock
}

func (m *MockPasswordService) HashPassword(password string) (string, error) {
    args := m.Called(password)
    return args.String(0), args.Error(1)
}

func (m *MockPasswordService) VerifyPassword(hashedPassword, password string) bool {
    args := m.Called(hashedPassword, password)
    return args.Bool(0)
}

func (m *MockPasswordService) ValidatePasswordStrength(password string) error {
    args := m.Called(password)
    return args.Error(0)
}

// MockJWTService Mock JWTService
type MockJWTService struct {
    mock.Mock
}

func (m *MockJWTService) GenerateToken(userID int64, username string, roleID *int64) (*TokenPair, error) {
    args := m.Called(userID, username, roleID)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*TokenPair), args.Error(1)
}

func (m *MockJWTService) BlacklistToken(token string) error {
    args := m.Called(token)
    return args.Error(0)
}

// ... 其他方法
```

### 4. 测试登录功能

```go
func TestAuthService_Login(t *testing.T) {
    tests := []struct {
        name        string
        setupMocks  func(*MockUserRepository, *MockPasswordService, *MockJWTService)
        req         *dto.LoginRequest
        wantErr     bool
        errMsg      string
    }{
        {
            name: "正常登录-用户名",
            setupMocks: func(userRepo *MockUserRepository, passwordService *MockPasswordService, jwtService *MockJWTService) {
                user := &models.User{
                    ID:            1,
                    Username:      "testuser",
                    Email:         "test@example.com",
                    PasswordHash:  "hashed_password",
                    IsActive:      true,
                    IsLocked:      false,
                    EmailVerified: true,
                }
                userRepo.On("GetByUsername", mock.Anything, "testuser").Return(user, nil)
                passwordService.On("VerifyPassword", "hashed_password", "password123").Return(true)
                jwtService.On("GenerateToken", int64(1), "testuser", (*int64)(nil)).Return(&TokenPair{
                    AccessToken:  "access_token",
                    RefreshToken: "refresh_token",
                    ExpiresAt:    time.Now().Add(15 * time.Minute),
                }, nil)
            },
            req: &dto.LoginRequest{
                UsernameOrEmail: "testuser",
                Password:        "password123",
            },
            wantErr: false,
        },
        {
            name: "正常登录-邮箱",
            setupMocks: func(userRepo *MockUserRepository, passwordService *MockPasswordService, jwtService *MockJWTService) {
                user := &models.User{
                    ID:            1,
                    Username:      "testuser",
                    Email:         "test@example.com",
                    PasswordHash:  "hashed_password",
                    IsActive:      true,
                    IsLocked:      false,
                    EmailVerified: true,
                }
                userRepo.On("GetByEmail", mock.Anything, "test@example.com").Return(user, nil)
                passwordService.On("VerifyPassword", "hashed_password", "password123").Return(true)
                jwtService.On("GenerateToken", int64(1), "testuser", (*int64)(nil)).Return(&TokenPair{
                    AccessToken:  "access_token",
                    RefreshToken: "refresh_token",
                    ExpiresAt:    time.Now().Add(15 * time.Minute),
                }, nil)
            },
            req: &dto.LoginRequest{
                UsernameOrEmail: "test@example.com",
                Password:        "password123",
            },
            wantErr: false,
        },
        {
            name: "用户不存在",
            setupMocks: func(userRepo *MockUserRepository, passwordService *MockPasswordService, jwtService *MockJWTService) {
                userRepo.On("GetByUsername", mock.Anything, "nonexistent").Return(nil, errors.New("用户不存在"))
            },
            req: &dto.LoginRequest{
                UsernameOrEmail: "nonexistent",
                Password:        "password123",
            },
            wantErr: true,
            errMsg:  "用户名或密码错误",
        },
        {
            name: "密码错误",
            setupMocks: func(userRepo *MockUserRepository, passwordService *MockPasswordService, jwtService *MockJWTService) {
                user := &models.User{
                    ID:            1,
                    Username:      "testuser",
                    Email:         "test@example.com",
                    PasswordHash:  "hashed_password",
                    IsActive:      true,
                    IsLocked:      false,
                    EmailVerified: true,
                }
                userRepo.On("GetByUsername", mock.Anything, "testuser").Return(user, nil)
                passwordService.On("VerifyPassword", "hashed_password", "wrong_password").Return(false)
            },
            req: &dto.LoginRequest{
                UsernameOrEmail: "testuser",
                Password:        "wrong_password",
            },
            wantErr: true,
            errMsg:  "用户名或密码错误",
        },
        {
            name: "用户未激活",
            setupMocks: func(userRepo *MockUserRepository, passwordService *MockPasswordService, jwtService *MockJWTService) {
                user := &models.User{
                    ID:            1,
                    Username:      "testuser",
                    Email:         "test@example.com",
                    PasswordHash:  "hashed_password",
                    IsActive:      false,
                    IsLocked:      false,
                    EmailVerified: true,
                }
                userRepo.On("GetByUsername", mock.Anything, "testuser").Return(user, nil)
            },
            req: &dto.LoginRequest{
                UsernameOrEmail: "testuser",
                Password:        "password123",
            },
            wantErr: true,
            errMsg:  "用户未激活，无法登录",
        },
        {
            name: "用户已锁定",
            setupMocks: func(userRepo *MockUserRepository, passwordService *MockPasswordService, jwtService *MockJWTService) {
                user := &models.User{
                    ID:            1,
                    Username:      "testuser",
                    Email:         "test@example.com",
                    PasswordHash:  "hashed_password",
                    IsActive:      true,
                    IsLocked:      true,
                    EmailVerified: true,
                }
                userRepo.On("GetByUsername", mock.Anything, "testuser").Return(user, nil)
            },
            req: &dto.LoginRequest{
                UsernameOrEmail: "testuser",
                Password:        "password123",
            },
            wantErr: true,
            errMsg:  "用户已被锁定，无法登录",
        },
        {
            name: "邮箱未验证",
            setupMocks: func(userRepo *MockUserRepository, passwordService *MockPasswordService, jwtService *MockJWTService) {
                user := &models.User{
                    ID:            1,
                    Username:      "testuser",
                    Email:         "test@example.com",
                    PasswordHash:  "hashed_password",
                    IsActive:      true,
                    IsLocked:      false,
                    EmailVerified: false,
                }
                userRepo.On("GetByUsername", mock.Anything, "testuser").Return(user, nil)
            },
            req: &dto.LoginRequest{
                UsernameOrEmail: "testuser",
                Password:        "password123",
            },
            wantErr: true,
            errMsg:  "邮箱未验证，请先验证邮箱",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 创建Mock对象
            mockUserRepo := new(MockUserRepository)
            mockPasswordService := new(MockPasswordService)
            mockJWTService := new(MockJWTService)
            
            // 设置Mock期望
            tt.setupMocks(mockUserRepo, mockPasswordService, mockJWTService)
            
            // 创建AuthService实例
            authService := NewAuthService(
                mockUserRepo,
                mockPasswordService,
                mockJWTService,
                nil, // LoginLogRepository可以为nil
                nil, // RegisterConfig可以为nil
            )
            
            // 执行测试
            ctx := context.Background()
            resp, err := authService.Login(ctx, tt.req)
            
            // 验证结果
            if tt.wantErr {
                require.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
                assert.Nil(t, resp)
            } else {
                require.NoError(t, err)
                require.NotNil(t, resp)
                assert.NotEmpty(t, resp.AccessToken)
                assert.NotEmpty(t, resp.RefreshToken)
                assert.NotNil(t, resp.User)
            }
            
            // 验证Mock调用
            mockUserRepo.AssertExpectations(t)
            mockPasswordService.AssertExpectations(t)
            mockJWTService.AssertExpectations(t)
        })
    }
}
```

### 5. 测试注册功能

```go
func TestAuthService_Register(t *testing.T) {
    tests := []struct {
        name        string
        setupMocks  func(*MockUserRepository, *MockPasswordService, *MockJWTService)
        config      *config.RegisterConfig
        req         *dto.RegisterRequest
        wantErr     bool
        errMsg      string
    }{
        {
            name: "正常注册",
            setupMocks: func(userRepo *MockUserRepository, passwordService *MockPasswordService, jwtService *MockJWTService) {
                userRepo.On("ExistsByUsername", mock.Anything, "newuser").Return(false, nil)
                userRepo.On("ExistsByEmail", mock.Anything, "new@example.com").Return(false, nil)
                passwordService.On("ValidatePasswordStrength", "password123").Return(nil)
                passwordService.On("HashPassword", "password123").Return("hashed_password", nil)
                userRepo.On("Create", mock.Anything, mock.AnythingOfType("*models.User")).Return(nil)
                jwtService.On("GenerateToken", mock.Anything, "newuser", (*int64)(nil)).Return(&TokenPair{
                    AccessToken:  "access_token",
                    RefreshToken: "refresh_token",
                    ExpiresAt:    time.Now().Add(15 * time.Minute),
                }, nil)
            },
            config: &config.RegisterConfig{
                Enabled: true,
                RequireEmailVerify: false,
                RequireApproval: false,
            },
            req: &dto.RegisterRequest{
                Username: "newuser",
                Email:    "new@example.com",
                Password: "password123",
            },
            wantErr: false,
        },
        {
            name: "注册功能已关闭",
            setupMocks: func(userRepo *MockUserRepository, passwordService *MockPasswordService, jwtService *MockJWTService) {
                // 不需要设置Mock
            },
            config: &config.RegisterConfig{
                Enabled: false,
            },
            req: &dto.RegisterRequest{
                Username: "newuser",
                Email:    "new@example.com",
                Password: "password123",
            },
            wantErr: true,
            errMsg:  "注册功能已关闭",
        },
        {
            name: "用户名已存在",
            setupMocks: func(userRepo *MockUserRepository, passwordService *MockPasswordService, jwtService *MockJWTService) {
                userRepo.On("ExistsByUsername", mock.Anything, "existinguser").Return(true, nil)
            },
            config: &config.RegisterConfig{
                Enabled: true,
            },
            req: &dto.RegisterRequest{
                Username: "existinguser",
                Email:    "new@example.com",
                Password: "password123",
            },
            wantErr: true,
            errMsg:  "用户名已被使用",
        },
        {
            name: "邮箱已存在",
            setupMocks: func(userRepo *MockUserRepository, passwordService *MockPasswordService, jwtService *MockJWTService) {
                userRepo.On("ExistsByUsername", mock.Anything, "newuser").Return(false, nil)
                userRepo.On("ExistsByEmail", mock.Anything, "existing@example.com").Return(true, nil)
            },
            config: &config.RegisterConfig{
                Enabled: true,
            },
            req: &dto.RegisterRequest{
                Username: "newuser",
                Email:    "existing@example.com",
                Password: "password123",
            },
            wantErr: true,
            errMsg:  "邮箱已被使用",
        },
        {
            name: "密码强度不足",
            setupMocks: func(userRepo *MockUserRepository, passwordService *MockPasswordService, jwtService *MockJWTService) {
                userRepo.On("ExistsByUsername", mock.Anything, "newuser").Return(false, nil)
                userRepo.On("ExistsByEmail", mock.Anything, "new@example.com").Return(false, nil)
                passwordService.On("ValidatePasswordStrength", "weak").Return(errors.New("密码强度不符合要求"))
            },
            config: &config.RegisterConfig{
                Enabled: true,
            },
            req: &dto.RegisterRequest{
                Username: "newuser",
                Email:    "new@example.com",
                Password: "weak",
            },
            wantErr: true,
            errMsg:  "密码强度不符合要求",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 创建Mock对象
            mockUserRepo := new(MockUserRepository)
            mockPasswordService := new(MockPasswordService)
            mockJWTService := new(MockJWTService)
            
            // 设置Mock期望
            tt.setupMocks(mockUserRepo, mockPasswordService, mockJWTService)
            
            // 创建AuthService实例
            authService := NewAuthService(
                mockUserRepo,
                mockPasswordService,
                mockJWTService,
                nil,
                tt.config,
            )
            
            // 执行测试
            ctx := context.Background()
            resp, err := authService.Register(ctx, tt.req)
            
            // 验证结果
            if tt.wantErr {
                require.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
                assert.Nil(t, resp)
            } else {
                require.NoError(t, err)
                require.NotNil(t, resp)
                assert.NotNil(t, resp.User)
            }
            
            // 验证Mock调用
            mockUserRepo.AssertExpectations(t)
            mockPasswordService.AssertExpectations(t)
            if !tt.wantErr && !tt.config.RequireApproval {
                mockJWTService.AssertExpectations(t)
            }
        })
    }
}
```

### 6. 测试登出功能

```go
func TestAuthService_Logout(t *testing.T) {
    tests := []struct {
        name       string
        setupMocks func(*MockJWTService)
        token      string
        wantErr    bool
        errMsg     string
    }{
        {
            name: "正常登出",
            setupMocks: func(jwtService *MockJWTService) {
                jwtService.On("BlacklistToken", "valid_token").Return(nil)
            },
            token:   "valid_token",
            wantErr: false,
        },
        {
            name: "token为空",
            setupMocks: func(jwtService *MockJWTService) {
                // 不需要设置Mock
            },
            token:   "",
            wantErr: true,
            errMsg:  "token不能为空",
        },
        {
            name: "黑名单失败",
            setupMocks: func(jwtService *MockJWTService) {
                jwtService.On("BlacklistToken", "token").Return(errors.New("黑名单操作失败"))
            },
            token:   "token",
            wantErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 创建Mock对象
            mockJWTService := new(MockJWTService)
            
            // 设置Mock期望
            tt.setupMocks(mockJWTService)
            
            // 创建AuthService实例
            authService := NewAuthService(
                nil,
                nil,
                mockJWTService,
                nil,
                nil,
            )
            
            // 执行测试
            ctx := context.Background()
            err := authService.Logout(ctx, tt.token)
            
            // 验证结果
            if tt.wantErr {
                require.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
            } else {
                require.NoError(t, err)
            }
            
            // 验证Mock调用
            mockJWTService.AssertExpectations(t)
        })
    }
}
```

### 7. 注意事项

- **使用表驱动测试**：使用表驱动测试处理多个测试场景
- **Mock对象**：使用testify/mock创建Mock对象
- **测试覆盖**：覆盖正常情况、边界情况和异常情况
- **测试描述**：所有测试用例名称和错误消息使用中文
- **测试独立性**：每个测试应该独立，不依赖其他测试
- **覆盖率要求**：确保测试覆盖率达标（80%以上）

## 验收标准

1. **测试文件完整**
   - 创建了auth_service_test.go文件
   - 测试文件结构清晰，组织合理

2. **登录功能测试**
   - 测试正常登录（用户名和邮箱）
   - 测试用户不存在
   - 测试密码错误
   - 测试用户未激活
   - 测试用户已锁定
   - 测试邮箱未验证

3. **注册功能测试**
   - 测试正常注册
   - 测试注册功能已关闭
   - 测试用户名已存在
   - 测试邮箱已存在
   - 测试密码强度不足

4. **登出功能测试**
   - 测试正常登出
   - 测试token为空
   - 测试黑名单失败

5. **测试质量**
   - 使用Mock对象进行测试
   - 测试用例覆盖全面
   - 测试描述使用中文
   - 测试覆盖率达标（80%以上）

6. **代码规范**
   - 遵循Golang测试规范
   - 遵循单元测试规范
   - 注释完整，使用中文

## 相关文件

- `internal/service/auth_service.go` - AuthService实现文件
- `.cursor/rules/testing.mdc` - Golang单元测试规范
- `.cursor/rules/coding-standards.mdc` - Golang编码规范
- `internal/service/auth_service_test.go` - AuthService测试文件（待创建）

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.1  
**最后更新**: 2026-01-03 20:26:31 CST

