# TASK005-05: 实现SessionRepository接口和实现

## 任务信息

**任务编号**: TASK005-05  
**父任务**: TASK005  
**任务名称**: 实现SessionRepository接口和实现  
**版本信息**: v1.1.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 20:06:59 CST

## 任务描述

实现SessionRepository接口，提供会话数据的存储和查询操作。包括：1) 定义SessionRepository接口（Create、GetByToken、BlacklistToken、IsBlacklisted、DeleteExpired等方法）；2) 实现SessionRepository接口（可以使用数据库或Redis）；3) 实现token黑名单管理。所有代码必须遵循Golang编码规范。

## 依赖任务

TASK005-02（创建UserSession模型）

## 实现指南

### 1. 定义SessionRepository接口

在 `internal/repository/` 目录下创建 `session_repository.go` 文件，定义SessionRepository接口：

```go
package repository

import (
    "context"
    "time"
    "yourproject/internal/models"
)

// SessionRepository 会话仓储接口
// 提供会话数据的存储和查询操作，支持token黑名单管理
type SessionRepository interface {
    // Create 创建会话
    Create(ctx context.Context, session *models.UserSession) error
    
    // GetByToken 根据token获取会话
    GetByToken(ctx context.Context, token string) (*models.UserSession, error)
    
    // GetByUserID 根据用户ID获取会话列表
    GetByUserID(ctx context.Context, userID int64, limit int) ([]*models.UserSession, error)
    
    // BlacklistToken 将token加入黑名单
    BlacklistToken(ctx context.Context, token string) error
    
    // IsBlacklisted 检查token是否在黑名单中
    IsBlacklisted(ctx context.Context, token string) (bool, error)
    
    // DeleteExpired 删除过期的会话
    DeleteExpired(ctx context.Context) error
    
    // DeleteByUserID 删除用户的所有会话
    DeleteByUserID(ctx context.Context, userID int64) error
    
    // DeleteByToken 删除指定token的会话
    DeleteByToken(ctx context.Context, token string) error
}
```

### 2. 实现SessionRepository接口（数据库实现）

在同一个文件中实现SessionRepository接口，使用GORM进行数据库操作：

```go
// sessionRepository SessionRepository的实现（数据库）
type sessionRepository struct {
    db *gorm.DB
}

// NewSessionRepository 创建SessionRepository实例
func NewSessionRepository(db *gorm.DB) SessionRepository {
    return &sessionRepository{db: db}
}

// Create 创建会话
func (r *sessionRepository) Create(ctx context.Context, session *models.UserSession) error {
    if err := r.db.WithContext(ctx).Create(session).Error; err != nil {
        if errors.Is(err, gorm.ErrDuplicatedKey) {
            return fmt.Errorf("会话已存在：token已被使用")
        }
        return fmt.Errorf("创建会话失败: %w", err)
    }
    return nil
}

// GetByToken 根据token获取会话
func (r *sessionRepository) GetByToken(ctx context.Context, token string) (*models.UserSession, error) {
    var session models.UserSession
    if err := r.db.WithContext(ctx).Where("token = ?", token).First(&session).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, fmt.Errorf("会话不存在")
        }
        return nil, fmt.Errorf("查询会话失败: %w", err)
    }
    return &session, nil
}

// GetByUserID 根据用户ID获取会话列表
func (r *sessionRepository) GetByUserID(ctx context.Context, userID int64, limit int) ([]*models.UserSession, error) {
    var sessions []*models.UserSession
    query := r.db.WithContext(ctx).Where("user_id = ?", userID).
        Order("created_at DESC")
    
    if limit > 0 {
        if limit > 100 {
            limit = 100
        }
        query = query.Limit(limit)
    }
    
    if err := query.Find(&sessions).Error; err != nil {
        return nil, fmt.Errorf("查询用户会话列表失败: %w", err)
    }
    return sessions, nil
}

// BlacklistToken 将token加入黑名单
func (r *sessionRepository) BlacklistToken(ctx context.Context, token string) error {
    now := time.Now()
    result := r.db.WithContext(ctx).Model(&models.UserSession{}).
        Where("token = ?", token).
        Updates(map[string]interface{}{
            "is_blacklisted": true,
            "blacklisted_at": now,
        })
    if result.Error != nil {
        return fmt.Errorf("将token加入黑名单失败: %w", result.Error)
    }
    if result.RowsAffected == 0 {
        return fmt.Errorf("会话不存在")
    }
    return nil
}

// IsBlacklisted 检查token是否在黑名单中
func (r *sessionRepository) IsBlacklisted(ctx context.Context, token string) (bool, error) {
    var session models.UserSession
    if err := r.db.WithContext(ctx).
        Where("token = ? AND is_blacklisted = ?", token, true).
        First(&session).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return false, nil
        }
        return false, fmt.Errorf("检查token黑名单状态失败: %w", err)
    }
    return true, nil
}

// DeleteExpired 删除过期的会话
func (r *sessionRepository) DeleteExpired(ctx context.Context) error {
    now := time.Now()
    result := r.db.WithContext(ctx).
        Where("expires_at < ?", now).
        Delete(&models.UserSession{})
    if result.Error != nil {
        return fmt.Errorf("删除过期会话失败: %w", result.Error)
    }
    return nil
}

// DeleteByUserID 删除用户的所有会话
func (r *sessionRepository) DeleteByUserID(ctx context.Context, userID int64) error {
    result := r.db.WithContext(ctx).
        Where("user_id = ?", userID).
        Delete(&models.UserSession{})
    if result.Error != nil {
        return fmt.Errorf("删除用户会话失败: %w", result.Error)
    }
    return nil
}

// DeleteByToken 删除指定token的会话
func (r *sessionRepository) DeleteByToken(ctx context.Context, token string) error {
    result := r.db.WithContext(ctx).
        Where("token = ?", token).
        Delete(&models.UserSession{})
    if result.Error != nil {
        return fmt.Errorf("删除会话失败: %w", result.Error)
    }
    if result.RowsAffected == 0 {
        return fmt.Errorf("会话不存在")
    }
    return nil
}
```

### 3. 可选：Redis实现（高级功能）

如果需要使用Redis实现SessionRepository以提高性能，可以创建另一个实现：

```go
// redisSessionRepository SessionRepository的Redis实现
type redisSessionRepository struct {
    client *redis.Client
    db     *gorm.DB // 用于持久化存储
}

// NewRedisSessionRepository 创建Redis实现的SessionRepository实例
func NewRedisSessionRepository(client *redis.Client, db *gorm.DB) SessionRepository {
    return &redisSessionRepository{
        client: client,
        db:     db,
    }
}

// Create 创建会话（同时存储到Redis和数据库）
func (r *redisSessionRepository) Create(ctx context.Context, session *models.UserSession) error {
    // 存储到数据库
    if err := r.db.WithContext(ctx).Create(session).Error; err != nil {
        return fmt.Errorf("创建会话失败: %w", err)
    }
    
    // 存储到Redis，key格式：session:{token}
    key := fmt.Sprintf("session:%s", session.Token)
    data, err := json.Marshal(session)
    if err != nil {
        return fmt.Errorf("序列化会话数据失败: %w", err)
    }
    
    // 设置过期时间
    expiresIn := time.Until(session.ExpiresAt)
    if err := r.client.Set(ctx, key, data, expiresIn).Err(); err != nil {
        return fmt.Errorf("存储会话到Redis失败: %w", err)
    }
    
    return nil
}

// GetByToken 根据token获取会话（优先从Redis获取）
func (r *redisSessionRepository) GetByToken(ctx context.Context, token string) (*models.UserSession, error) {
    key := fmt.Sprintf("session:%s", token)
    
    // 从Redis获取
    data, err := r.client.Get(ctx, key).Bytes()
    if err == nil {
        var session models.UserSession
        if err := json.Unmarshal(data, &session); err == nil {
            return &session, nil
        }
    }
    
    // 从数据库获取
    var session models.UserSession
    if err := r.db.WithContext(ctx).Where("token = ?", token).First(&session).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, fmt.Errorf("会话不存在")
        }
        return nil, fmt.Errorf("查询会话失败: %w", err)
    }
    
    // 回写到Redis
    sessionData, _ := json.Marshal(session)
    expiresIn := time.Until(session.ExpiresAt)
    r.client.Set(ctx, key, sessionData, expiresIn)
    
    return &session, nil
}

// IsBlacklisted 检查token是否在黑名单中（优先从Redis获取）
func (r *redisSessionRepository) IsBlacklisted(ctx context.Context, token string) (bool, error) {
    blacklistKey := fmt.Sprintf("blacklist:%s", token)
    
    // 从Redis检查
    exists, err := r.client.Exists(ctx, blacklistKey).Result()
    if err == nil && exists > 0 {
        return true, nil
    }
    
    // 从数据库检查
    var session models.UserSession
    if err := r.db.WithContext(ctx).
        Where("token = ? AND is_blacklisted = ?", token, true).
        First(&session).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return false, nil
        }
        return false, fmt.Errorf("检查token黑名单状态失败: %w", err)
    }
    
    // 回写到Redis
    expiresIn := time.Until(session.ExpiresAt)
    r.client.Set(ctx, blacklistKey, "1", expiresIn)
    
    return true, nil
}

// BlacklistToken 将token加入黑名单（同时更新Redis和数据库）
func (r *redisSessionRepository) BlacklistToken(ctx context.Context, token string) error {
    now := time.Now()
    
    // 更新数据库
    var session models.UserSession
    if err := r.db.WithContext(ctx).Where("token = ?", token).First(&session).Error; err != nil {
        return fmt.Errorf("会话不存在")
    }
    
    session.IsBlacklisted = true
    session.BlacklistedAt = &now
    if err := r.db.WithContext(ctx).Save(&session).Error; err != nil {
        return fmt.Errorf("将token加入黑名单失败: %w", err)
    }
    
    // 更新Redis
    blacklistKey := fmt.Sprintf("blacklist:%s", token)
    expiresIn := time.Until(session.ExpiresAt)
    r.client.Set(ctx, blacklistKey, "1", expiresIn)
    
    return nil
}
```

### 4. 添加必要的导入

```go
package repository

import (
    "context"
    "encoding/json"
    "errors"
    "fmt"
    "time"
    
    "github.com/redis/go-redis/v9"
    "gorm.io/gorm"
    "yourproject/internal/models"
)
```

### 5. 注意事项

- **实现选择**：根据项目需求选择数据库实现或Redis实现，或两者结合
- **错误处理**：所有错误消息必须使用中文
- **上下文传递**：所有方法都接受context.Context参数
- **黑名单机制**：使用is_blacklisted字段标记黑名单，支持快速查询
- **过期清理**：定期调用DeleteExpired方法清理过期会话
- **性能优化**：如果使用Redis，可以提高查询性能，但需要处理数据一致性
- **错误包装**：使用fmt.Errorf和%w动词包装错误

## 验收标准

1. **接口定义完整**
   - SessionRepository接口包含所有必需方法
   - 方法签名正确，参数和返回值类型正确

2. **实现完整**
   - 所有接口方法都已实现
   - 实现逻辑正确，符合业务需求
   - 错误处理完善，错误消息使用中文

3. **黑名单功能**
   - BlacklistToken方法正确实现
   - IsBlacklisted方法正确实现
   - 黑名单状态正确更新

4. **查询功能**
   - GetByToken方法正确实现
   - GetByUserID方法支持限制数量
   - 查询逻辑正确

5. **清理功能**
   - DeleteExpired方法正确实现
   - DeleteByUserID方法正确实现
   - DeleteByToken方法正确实现

6. **代码规范**
   - 遵循Golang编码规范
   - 遵循GORM最佳实践
   - 注释完整，使用中文

## 相关文件

- `internal/models/user_session.go` - UserSession模型文件
- `.cursor/rules/coding-standards.mdc` - Golang编码规范
- `internal/repository/session_repository.go` - SessionRepository接口和实现文件（待创建）

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.1  
**最后更新**: 2026-01-03 20:06:59 CST

