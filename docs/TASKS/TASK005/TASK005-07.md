# TASK005-07: 创建PasswordService接口和实现

## 任务信息

**任务编号**: TASK005-07  
**父任务**: TASK005  
**任务名称**: 创建PasswordService接口和实现  
**版本信息**: v1.1.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 20:06:59 CST

## 任务描述

创建密码服务，提供密码加密和验证功能。包括：1) 定义PasswordService接口（HashPassword、VerifyPassword、ValidatePasswordStrength等方法）；2) 实现密码哈希（使用bcrypt，成本因子12）；3) 实现密码验证；4) 实现密码强度验证（根据配置验证密码规则）。所有代码必须遵循Golang编码规范和 security.mdc 安全规范。

## 依赖任务

无

## 实现指南

### 1. 定义PasswordService接口

在 `internal/service/` 目录下创建 `password_service.go` 文件，定义PasswordService接口：

```go
package service

// PasswordService 密码服务接口
// 提供密码加密、验证和强度验证功能
type PasswordService interface {
    // HashPassword 对密码进行哈希加密
    // 使用bcrypt算法，成本因子12
    HashPassword(password string) (string, error)
    
    // VerifyPassword 验证密码是否匹配哈希值
    VerifyPassword(hashedPassword, password string) bool
    
    // ValidatePasswordStrength 验证密码强度
    // 根据配置验证密码规则（长度、字符类型等）
    ValidatePasswordStrength(password string) error
    
    // GenerateRandomPassword 生成随机密码
    // 用于密码重置等场景
    GenerateRandomPassword(length int) (string, error)
}
```

### 2. 定义密码强度配置

```go
// PasswordStrengthConfig 密码强度配置
type PasswordStrengthConfig struct {
    MinLength      int  // 最小长度，默认8
    MaxLength      int  // 最大长度，默认128
    RequireUpper   bool // 是否需要大写字母
    RequireLower   bool // 是否需要小写字母
    RequireNumber  bool // 是否需要数字
    RequireSpecial bool // 是否需要特殊字符
}

// DefaultPasswordStrengthConfig 默认密码强度配置
func DefaultPasswordStrengthConfig() *PasswordStrengthConfig {
    return &PasswordStrengthConfig{
        MinLength:      8,
        MaxLength:      128,
        RequireUpper:   true,
        RequireLower:   true,
        RequireNumber:  true,
        RequireSpecial: true,
    }
}
```

### 3. 实现PasswordService接口

```go
package service

import (
    "crypto/rand"
    "errors"
    "fmt"
    "math/big"
    "strings"
    "unicode"
    
    "golang.org/x/crypto/bcrypt"
)

// passwordService PasswordService的实现
type passwordService struct {
    config *PasswordStrengthConfig
}

// NewPasswordService 创建PasswordService实例
func NewPasswordService(config *PasswordStrengthConfig) PasswordService {
    if config == nil {
        config = DefaultPasswordStrengthConfig()
    }
    return &passwordService{
        config: config,
    }
}

// HashPassword 对密码进行哈希加密
// 使用bcrypt算法，成本因子12
func (s *passwordService) HashPassword(password string) (string, error) {
    if password == "" {
        return "", errors.New("密码不能为空")
    }
    
    // 使用bcrypt进行哈希，成本因子12
    hash, err := bcrypt.GenerateFromPassword([]byte(password), 12)
    if err != nil {
        return "", fmt.Errorf("密码哈希失败: %w", err)
    }
    
    return string(hash), nil
}

// VerifyPassword 验证密码是否匹配哈希值
func (s *passwordService) VerifyPassword(hashedPassword, password string) bool {
    if hashedPassword == "" || password == "" {
        return false
    }
    
    err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
    return err == nil
}

// ValidatePasswordStrength 验证密码强度
func (s *passwordService) ValidatePasswordStrength(password string) error {
    if password == "" {
        return errors.New("密码不能为空")
    }
    
    // 验证长度
    length := len(password)
    if length < s.config.MinLength {
        return fmt.Errorf("密码长度不能少于%d个字符", s.config.MinLength)
    }
    if length > s.config.MaxLength {
        return fmt.Errorf("密码长度不能超过%d个字符", s.config.MaxLength)
    }
    
    var (
        hasUpper   = false
        hasLower   = false
        hasNumber  = false
        hasSpecial = false
    )
    
    // 检查字符类型
    for _, char := range password {
        switch {
        case unicode.IsUpper(char):
            hasUpper = true
        case unicode.IsLower(char):
            hasLower = true
        case unicode.IsNumber(char):
            hasNumber = true
        case unicode.IsPunct(char) || unicode.IsSymbol(char):
            hasSpecial = true
        }
    }
    
    // 验证必需字符类型
    var missingTypes []string
    if s.config.RequireUpper && !hasUpper {
        missingTypes = append(missingTypes, "大写字母")
    }
    if s.config.RequireLower && !hasLower {
        missingTypes = append(missingTypes, "小写字母")
    }
    if s.config.RequireNumber && !hasNumber {
        missingTypes = append(missingTypes, "数字")
    }
    if s.config.RequireSpecial && !hasSpecial {
        missingTypes = append(missingTypes, "特殊字符")
    }
    
    if len(missingTypes) > 0 {
        return fmt.Errorf("密码必须包含%s", strings.Join(missingTypes, "、"))
    }
    
    return nil
}

// GenerateRandomPassword 生成随机密码
func (s *passwordService) GenerateRandomPassword(length int) (string, error) {
    if length < s.config.MinLength {
        length = s.config.MinLength
    }
    if length > s.config.MaxLength {
        length = s.config.MaxLength
    }
    
    // 定义字符集
    const (
        upperChars   = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        lowerChars   = "abcdefghijklmnopqrstuvwxyz"
        numberChars  = "0123456789"
        specialChars = "!@#$%^&*()_+-=[]{}|;:,.<>?"
    )
    
    var charSet string
    if s.config.RequireUpper {
        charSet += upperChars
    }
    if s.config.RequireLower {
        charSet += lowerChars
    }
    if s.config.RequireNumber {
        charSet += numberChars
    }
    if s.config.RequireSpecial {
        charSet += specialChars
    }
    
    if charSet == "" {
        charSet = upperChars + lowerChars + numberChars + specialChars
    }
    
    // 生成随机密码
    password := make([]byte, length)
    for i := range password {
        num, err := rand.Int(rand.Reader, big.NewInt(int64(len(charSet))))
        if err != nil {
            return "", fmt.Errorf("生成随机密码失败: %w", err)
        }
        password[i] = charSet[num.Int64()]
    }
    
    // 确保密码满足所有要求
    passwordStr := string(password)
    if err := s.ValidatePasswordStrength(passwordStr); err != nil {
        // 如果生成的密码不满足要求，重新生成
        return s.GenerateRandomPassword(length)
    }
    
    return passwordStr, nil
}
```

### 4. 添加必要的导入

```go
package service

import (
    "crypto/rand"
    "errors"
    "fmt"
    "math/big"
    "strings"
    "unicode"
    
    "golang.org/x/crypto/bcrypt"
)
```

### 5. 添加错误定义

```go
// 密码服务错误定义
var (
    ErrPasswordEmpty        = errors.New("密码不能为空")
    ErrPasswordTooShort     = errors.New("密码长度不足")
    ErrPasswordTooLong      = errors.New("密码长度过长")
    ErrPasswordMissingUpper = errors.New("密码必须包含大写字母")
    ErrPasswordMissingLower = errors.New("密码必须包含小写字母")
    ErrPasswordMissingNumber = errors.New("密码必须包含数字")
    ErrPasswordMissingSpecial = errors.New("密码必须包含特殊字符")
)
```

### 6. 注意事项

- **bcrypt成本因子**：使用成本因子12，平衡安全性和性能
- **密码强度验证**：根据配置灵活验证密码规则
- **错误消息**：所有错误消息使用中文，清晰描述问题
- **随机密码生成**：确保生成的密码满足所有强度要求
- **安全性**：使用crypto/rand生成随机数，确保密码安全性
- **配置灵活性**：支持自定义密码强度配置

## 验收标准

1. **接口定义完整**
   - PasswordService接口包含所有必需方法
   - 方法签名正确，参数和返回值类型正确

2. **实现完整**
   - 所有接口方法都已实现
   - 实现逻辑正确，符合安全规范
   - 错误处理完善，错误消息使用中文

3. **密码哈希功能**
   - HashPassword方法使用bcrypt，成本因子12
   - 哈希结果正确，可以用于验证

4. **密码验证功能**
   - VerifyPassword方法正确验证密码
   - 支持验证正确和错误的密码

5. **密码强度验证**
   - ValidatePasswordStrength方法正确验证密码规则
   - 支持配置化的密码强度要求
   - 错误消息清晰，使用中文

6. **随机密码生成**
   - GenerateRandomPassword方法生成满足要求的随机密码
   - 生成的密码满足所有强度要求

7. **代码规范**
   - 遵循Golang编码规范
   - 遵循安全开发规范
   - 注释完整，使用中文

## 相关文件

- `.cursor/rules/security.mdc` - 应用安全开发规范
- `.cursor/rules/coding-standards.mdc` - Golang编码规范
- `internal/service/password_service.go` - PasswordService接口和实现文件（待创建）

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.1  
**最后更新**: 2026-01-03 20:06:59 CST

