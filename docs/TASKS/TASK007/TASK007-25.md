# TASK007-25: 实现NovelChapterAttachmentRepository接口和实现

## 任务信息

**任务编号**: TASK007-25  
**父任务**: TASK007  
**任务名称**: 实现NovelChapterAttachmentRepository接口和实现  
**版本信息**: v1.2.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 23:19:17 CST

## 任务描述

实现NovelChapterAttachmentRepository接口，提供小说章节附件数据的CRUD操作。包括：1) 定义NovelChapterAttachmentRepository接口（Create、GetByID、GetByChapterID、Update、Delete、UpdateSortOrder等方法）；2) 实现NovelChapterAttachmentRepository接口（使用GORM进行数据库操作）。所有代码必须遵循Golang编码规范，错误消息使用中文。

## 依赖任务

TASK007-07（创建NovelChapterAttachment模型）

## 实现指南

### 1. 参考数据库设计文档

阅读 `docs/TASKS/TASK002/TASK002-22.md` 文档，了解novel_chapter_attachments表的完整设计：
- 表结构：id、chapter_id、file_id、file_name、file_type、file_size、sort_order、created_at、updated_at
- 外键关联：chapter_id 关联 novel_chapters 表，file_id 关联 files 表
- 索引：chapter_id、file_id、sort_order

### 2. 创建NovelChapterAttachmentRepository接口文件

在 `internal/repository/` 目录下创建 `novel_chapter_attachment_repository.go` 文件，定义NovelChapterAttachmentRepository接口：

```go
package repository

import (
    "context"
    "yourproject/internal/models"
)

// NovelChapterAttachmentRepository 小说章节附件仓储接口
// 提供小说章节附件数据的CRUD操作
type NovelChapterAttachmentRepository interface {
    // Create 创建小说章节附件
    Create(ctx context.Context, attachment *models.NovelChapterAttachment) error
    
    // GetByID 根据ID获取小说章节附件
    GetByID(ctx context.Context, id int64) (*models.NovelChapterAttachment, error)
    
    // GetByChapterID 根据章节ID获取附件列表
    GetByChapterID(ctx context.Context, chapterID int64) ([]*models.NovelChapterAttachment, error)
    
    // Update 更新小说章节附件
    Update(ctx context.Context, attachment *models.NovelChapterAttachment) error
    
    // Delete 删除小说章节附件
    Delete(ctx context.Context, id int64) error
    
    // UpdateSortOrder 更新附件排序
    UpdateSortOrder(ctx context.Context, id int64, sortOrder int) error
}
```

### 3. 实现NovelChapterAttachmentRepository接口

```go
// novelChapterAttachmentRepository NovelChapterAttachmentRepository接口实现
type novelChapterAttachmentRepository struct {
    db *gorm.DB
}

// NewNovelChapterAttachmentRepository 创建NovelChapterAttachmentRepository实例
func NewNovelChapterAttachmentRepository(db *gorm.DB) NovelChapterAttachmentRepository {
    return &novelChapterAttachmentRepository{db: db}
}

// Create 创建小说章节附件
func (r *novelChapterAttachmentRepository) Create(ctx context.Context, attachment *models.NovelChapterAttachment) error {
    if err := r.db.WithContext(ctx).Create(attachment).Error; err != nil {
        return fmt.Errorf("创建小说章节附件失败: %w", err)
    }
    return nil
}

// GetByID 根据ID获取小说章节附件
func (r *novelChapterAttachmentRepository) GetByID(ctx context.Context, id int64) (*models.NovelChapterAttachment, error) {
    var attachment models.NovelChapterAttachment
    if err := r.db.WithContext(ctx).Where("id = ?", id).First(&attachment).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, fmt.Errorf("小说章节附件不存在")
        }
        return nil, fmt.Errorf("查询小说章节附件失败: %w", err)
    }
    return &attachment, nil
}

// GetByChapterID 根据章节ID获取附件列表
func (r *novelChapterAttachmentRepository) GetByChapterID(ctx context.Context, chapterID int64) ([]*models.NovelChapterAttachment, error) {
    var attachments []*models.NovelChapterAttachment
    if err := r.db.WithContext(ctx).
        Where("chapter_id = ?", chapterID).
        Order("sort_order ASC").
        Find(&attachments).Error; err != nil {
        return nil, fmt.Errorf("查询小说章节附件列表失败: %w", err)
    }
    return attachments, nil
}

// Update 更新小说章节附件
func (r *novelChapterAttachmentRepository) Update(ctx context.Context, attachment *models.NovelChapterAttachment) error {
    if err := r.db.WithContext(ctx).Save(attachment).Error; err != nil {
        return fmt.Errorf("更新小说章节附件失败: %w", err)
    }
    return nil
}

// Delete 删除小说章节附件
func (r *novelChapterAttachmentRepository) Delete(ctx context.Context, id int64) error {
    result := r.db.WithContext(ctx).Delete(&models.NovelChapterAttachment{}, id)
    if result.Error != nil {
        return fmt.Errorf("删除小说章节附件失败: %w", result.Error)
    }
    if result.RowsAffected == 0 {
        return fmt.Errorf("小说章节附件不存在")
    }
    return nil
}

// UpdateSortOrder 更新附件排序
func (r *novelChapterAttachmentRepository) UpdateSortOrder(ctx context.Context, id int64, sortOrder int) error {
    result := r.db.WithContext(ctx).Model(&models.NovelChapterAttachment{}).
        Where("id = ?", id).
        Update("sort_order", sortOrder)
    if result.Error != nil {
        return fmt.Errorf("更新小说章节附件排序失败: %w", result.Error)
    }
    if result.RowsAffected == 0 {
        return fmt.Errorf("小说章节附件不存在")
    }
    return nil
}
```

### 4. 添加必要的导入

```go
package repository

import (
    "context"
    "errors"
    "fmt"
    
    "gorm.io/gorm"
    "yourproject/internal/models"
)
```

### 5. 注意事项

- **错误处理**：所有错误消息必须使用中文
- **上下文传递**：所有数据库操作必须使用context.Context
- **排序**：GetByChapterID方法按sort_order排序
- **文件关联**：注意file_id关联files表，确保文件存在

## 验收标准

1. **接口定义完整**
   - NovelChapterAttachmentRepository接口包含所有必需方法
   - 方法签名正确，参数和返回值合理

2. **实现完整**
   - 所有接口方法都已实现
   - 实现逻辑正确，错误处理完善

3. **查询功能**
   - GetByChapterID方法按sort_order排序返回附件列表

4. **错误处理**
   - 所有错误消息使用中文
   - 正确处理记录不存在等错误

5. **代码规范**
   - 遵循Golang编码规范
   - 遵循GORM最佳实践
   - 代码注释完整（使用中文）

## 相关文件

- `docs/TASKS/TASK002/TASK002-22.md` - 小说章节附件表数据库设计文档
- `docs/TASKS/TASK007/TASK007-07.md` - NovelChapterAttachment模型实现文档
- `docs/TASKS/TASK007/TASK007-24.md` - NovelChapterRepository实现参考
- `.cursor/rules/coding-standards.mdc` - Golang编码规范
- `internal/repository/novel_chapter_attachment_repository.go` - NovelChapterAttachmentRepository接口和实现文件（待创建）

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.0  
**最后更新**: 2026-01-03 23:19:17 CST

