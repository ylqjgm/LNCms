# TASK007-43: 创建NovelChapterService接口和实现

## 任务信息

**任务编号**: TASK007-43  
**父任务**: TASK007  
**任务名称**: 创建NovelChapterService接口和实现  
**版本信息**: v1.2.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 23:43:24 CST

## 任务描述

创建小说章节服务，提供小说章节管理的业务逻辑。包括：1) 定义NovelChapterService接口（GetChapter、GetChapters、CreateChapter、UpdateChapter、DeleteChapter、UpdateStatus、UpdateWordCount等方法）；2) 实现章节查询（单个章节、章节列表，支持分页、排序）；3) 实现章节创建、更新、删除；4) 实现字数统计和更新小说总字数。所有代码必须遵循Golang编码规范，错误消息使用中文。

## 依赖任务

TASK007-24（实现NovelChapterRepository接口和实现）、TASK007-42（创建NovelVolumeService接口和实现）、TASK007-41（创建NovelService接口和实现 - 状态和统计管理）

## 实现指南

### 1. 创建NovelChapterService接口文件

在 `internal/service/` 目录下创建 `novel_chapter_service.go` 文件，定义NovelChapterService接口：

```go
package service

import (
    "context"
    "yourproject/internal/models"
)

// NovelChapterService 小说章节服务接口
// 提供小说章节管理的业务逻辑
type NovelChapterService interface {
    // GetChapter 根据ID获取章节
    GetChapter(ctx context.Context, id int64) (*models.NovelChapter, error)
    
    // GetChapters 获取章节列表（支持分页、排序）
    GetChapters(ctx context.Context, params *NovelChapterQueryParams) ([]*models.NovelChapter, int64, error)
    
    // CreateChapter 创建章节
    CreateChapter(ctx context.Context, chapter *models.NovelChapter) error
    
    // UpdateChapter 更新章节
    UpdateChapter(ctx context.Context, chapter *models.NovelChapter) error
    
    // DeleteChapter 删除章节
    DeleteChapter(ctx context.Context, id int64) error
    
    // UpdateStatus 更新章节状态
    UpdateStatus(ctx context.Context, id int64, status string) error
    
    // UpdateWordCount 更新章节字数并更新小说总字数
    UpdateWordCount(ctx context.Context, id int64) error
}

// NovelChapterQueryParams 小说章节查询参数
type NovelChapterQueryParams struct {
    NovelID   int64  // 小说ID（必填）
    VolumeID *int64 // 分卷ID（可选）
    Page      int    // 页码，从1开始
    Limit     int    // 每页数量
    Status    string // 状态筛选
    IsVip     *bool  // 是否VIP筛选
    OrderBy   string // 排序字段（sort_order、created_at、updated_at）
    OrderDir  string // 排序方向（asc、desc）
}
```

### 2. 实现NovelChapterService接口

在同一个文件中实现NovelChapterService接口：

```go
// novelChapterService NovelChapterService的实现
type novelChapterService struct {
    chapterRepo repository.NovelChapterRepository
    novelRepo   repository.NovelRepository
    volumeRepo  repository.NovelVolumeRepository
    novelSvc    NovelService
}

// NewNovelChapterService 创建NovelChapterService实例
func NewNovelChapterService(
    chapterRepo repository.NovelChapterRepository,
    novelRepo repository.NovelRepository,
    volumeRepo repository.NovelVolumeRepository,
    novelSvc NovelService,
) NovelChapterService {
    return &novelChapterService{
        chapterRepo: chapterRepo,
        novelRepo:   novelRepo,
        volumeRepo:  volumeRepo,
        novelSvc:    novelSvc,
    }
}

// GetChapter 根据ID获取章节
func (s *novelChapterService) GetChapter(ctx context.Context, id int64) (*models.NovelChapter, error) {
    if id <= 0 {
        return nil, errors.New("章节ID无效")
    }
    
    chapter, err := s.chapterRepo.GetByID(ctx, id)
    if err != nil {
        return nil, fmt.Errorf("获取章节失败: %w", err)
    }
    
    return chapter, nil
}

// GetChapters 获取章节列表
func (s *novelChapterService) GetChapters(ctx context.Context, params *NovelChapterQueryParams) ([]*models.NovelChapter, int64, error) {
    if params.NovelID <= 0 {
        return nil, 0, errors.New("小说ID无效")
    }
    
    // 验证小说是否存在
    _, err := s.novelRepo.GetByID(ctx, params.NovelID)
    if err != nil {
        return nil, 0, errors.New("小说不存在")
    }
    
    // 构建查询参数
    queryParams := &repository.NovelChapterQueryParams{
        Page:     params.Page,
        Limit:    params.Limit,
        Status:   params.Status,
        IsVip:    params.IsVip,
        OrderBy:  params.OrderBy,
        OrderDir: params.OrderDir,
    }
    
    // 验证和设置默认值
    if queryParams.Page < 1 {
        queryParams.Page = 1
    }
    if queryParams.Limit < 1 {
        queryParams.Limit = 20
    }
    if queryParams.Limit > 100 {
        queryParams.Limit = 100
    }
    if queryParams.OrderBy == "" {
        queryParams.OrderBy = "sort_order"
    }
    if queryParams.OrderDir == "" {
        queryParams.OrderDir = "asc"
    }
    
    var chapters []*models.NovelChapter
    var total int64
    var err2 error
    
    if params.VolumeID != nil {
        chapters, total, err2 = s.chapterRepo.GetByVolumeID(ctx, *params.VolumeID, queryParams)
    } else {
        chapters, total, err2 = s.chapterRepo.GetByNovelID(ctx, params.NovelID, queryParams)
    }
    
    if err2 != nil {
        return nil, 0, fmt.Errorf("获取章节列表失败: %w", err2)
    }
    
    return chapters, total, nil
}

// CreateChapter 创建章节
func (s *novelChapterService) CreateChapter(ctx context.Context, chapter *models.NovelChapter) error {
    // 业务验证
    if err := s.validateChapter(chapter); err != nil {
        return err
    }
    
    // 验证小说是否存在
    _, err := s.novelRepo.GetByID(ctx, chapter.NovelID)
    if err != nil {
        return errors.New("小说不存在")
    }
    
    // 验证分卷是否存在（如果指定了分卷）
    if chapter.VolumeID != nil {
        _, err := s.volumeRepo.GetByID(ctx, *chapter.VolumeID)
        if err != nil {
            return errors.New("分卷不存在")
        }
    }
    
    // 设置默认值
    if chapter.Status == "" {
        chapter.Status = "draft"
    }
    if chapter.SortOrder == 0 {
        // 获取当前最大排序值
        chapters, _, err := s.chapterRepo.GetByNovelID(ctx, chapter.NovelID, &repository.NovelChapterQueryParams{
            Page:     1,
            Limit:    10000,
            OrderBy:  "sort_order",
            OrderDir: "desc",
        })
        if err == nil && len(chapters) > 0 {
            chapter.SortOrder = chapters[0].SortOrder + 1
        } else {
            chapter.SortOrder = 1
        }
    }
    
    // 计算字数
    if chapter.Content != "" {
        chapter.WordCount = int64(len([]rune(chapter.Content)))
    }
    
    // 创建章节
    if err := s.chapterRepo.Create(ctx, chapter); err != nil {
        return fmt.Errorf("创建章节失败: %w", err)
    }
    
    // 更新小说总字数
    if chapter.Status == "published" {
        if err := s.novelSvc.UpdateWordCount(ctx, chapter.NovelID); err != nil {
            // 记录错误但不中断流程
            // log.Printf("更新小说总字数失败: %v", err)
        }
    }
    
    return nil
}

// UpdateChapter 更新章节
func (s *novelChapterService) UpdateChapter(ctx context.Context, chapter *models.NovelChapter) error {
    // 业务验证
    if err := s.validateChapter(chapter); err != nil {
        return err
    }
    
    // 检查章节是否存在
    existing, err := s.chapterRepo.GetByID(ctx, chapter.ID)
    if err != nil {
        return errors.New("章节不存在")
    }
    
    // 验证小说ID是否改变（不允许改变）
    if existing.NovelID != chapter.NovelID {
        return errors.New("不能修改章节所属的小说")
    }
    
    // 重新计算字数
    if chapter.Content != "" {
        chapter.WordCount = int64(len([]rune(chapter.Content)))
    }
    
    // 更新章节
    if err := s.chapterRepo.Update(ctx, chapter); err != nil {
        return fmt.Errorf("更新章节失败: %w", err)
    }
    
    // 如果状态变为已发布，更新小说总字数
    if chapter.Status == "published" && existing.Status != "published" {
        if err := s.novelSvc.UpdateWordCount(ctx, chapter.NovelID); err != nil {
            // 记录错误但不中断流程
        }
    }
    
    return nil
}

// DeleteChapter 删除章节
func (s *novelChapterService) DeleteChapter(ctx context.Context, id int64) error {
    if id <= 0 {
        return errors.New("章节ID无效")
    }
    
    // 检查章节是否存在
    chapter, err := s.chapterRepo.GetByID(ctx, id)
    if err != nil {
        return errors.New("章节不存在")
    }
    
    novelID := chapter.NovelID
    
    // 删除章节
    if err := s.chapterRepo.Delete(ctx, id); err != nil {
        return fmt.Errorf("删除章节失败: %w", err)
    }
    
    // 更新小说总字数
    if chapter.Status == "published" {
        if err := s.novelSvc.UpdateWordCount(ctx, novelID); err != nil {
            // 记录错误但不中断流程
        }
    }
    
    return nil
}

// UpdateStatus 更新章节状态
func (s *novelChapterService) UpdateStatus(ctx context.Context, id int64, status string) error {
    if id <= 0 {
        return errors.New("章节ID无效")
    }
    
    // 验证状态
    validStatuses := []string{"draft", "reviewing", "published", "archived"}
    isValid := false
    for _, validStatus := range validStatuses {
        if status == validStatus {
            isValid = true
            break
        }
    }
    if !isValid {
        return errors.New("无效的章节状态")
    }
    
    // 检查章节是否存在
    chapter, err := s.chapterRepo.GetByID(ctx, id)
    if err != nil {
        return errors.New("章节不存在")
    }
    
    oldStatus := chapter.Status
    
    // 更新状态
    if err := s.chapterRepo.UpdateStatus(ctx, id, status); err != nil {
        return fmt.Errorf("更新章节状态失败: %w", err)
    }
    
    // 如果状态变为已发布或从已发布变为其他状态，更新小说总字数
    if (status == "published" && oldStatus != "published") || 
       (oldStatus == "published" && status != "published") {
        if err := s.novelSvc.UpdateWordCount(ctx, chapter.NovelID); err != nil {
            // 记录错误但不中断流程
        }
    }
    
    return nil
}

// UpdateWordCount 更新章节字数并更新小说总字数
func (s *novelChapterService) UpdateWordCount(ctx context.Context, id int64) error {
    if id <= 0 {
        return errors.New("章节ID无效")
    }
    
    // 检查章节是否存在
    chapter, err := s.chapterRepo.GetByID(ctx, id)
    if err != nil {
        return errors.New("章节不存在")
    }
    
    // 重新计算字数
    wordCount := int64(len([]rune(chapter.Content)))
    
    // 更新章节字数
    if err := s.chapterRepo.UpdateWordCount(ctx, id, wordCount); err != nil {
        return fmt.Errorf("更新章节字数失败: %w", err)
    }
    
    // 如果章节已发布，更新小说总字数
    if chapter.Status == "published" {
        if err := s.novelSvc.UpdateWordCount(ctx, chapter.NovelID); err != nil {
            return fmt.Errorf("更新小说总字数失败: %w", err)
        }
    }
    
    return nil
}

// validateChapter 验证章节数据
func (s *novelChapterService) validateChapter(chapter *models.NovelChapter) error {
    if chapter.NovelID <= 0 {
        return errors.New("小说ID无效")
    }
    
    if chapter.ChapterTitle == "" {
        return errors.New("章节标题不能为空")
    }
    if len(chapter.ChapterTitle) > 200 {
        return errors.New("章节标题长度不能超过200个字符")
    }
    
    // 验证状态
    if chapter.Status != "" {
        validStatuses := []string{"draft", "reviewing", "published", "archived"}
        isValid := false
        for _, validStatus := range validStatuses {
            if chapter.Status == validStatus {
                isValid = true
                break
            }
        }
        if !isValid {
            return errors.New("无效的章节状态")
        }
    }
    
    return nil
}
```

### 3. 添加必要的导入

```go
package service

import (
    "context"
    "errors"
    "fmt"
    
    "yourproject/internal/models"
    "yourproject/internal/repository"
)
```

### 4. 注意事项

- **业务验证**：在Service层进行业务逻辑验证，包括数据有效性、业务规则等
- **错误处理**：所有错误消息必须使用中文
- **字数统计**：自动计算章节字数，并在章节状态变化时更新小说总字数
- **关联验证**：创建和更新时验证小说和分卷的存在性
- **排序处理**：创建时自动设置排序值
- **状态管理**：状态变化时自动更新小说总字数

## 验收标准

1. **接口定义完整**
   - NovelChapterService接口包含所有必需方法
   - 方法签名正确，参数和返回值类型正确
   - NovelChapterQueryParams结构体定义完整

2. **实现完整**
   - 所有接口方法都已实现
   - 业务逻辑正确实现

3. **业务验证**
   - 章节数据验证正确
   - 小说和分卷关联验证正确
   - 状态验证正确

4. **字数统计**
   - 自动计算章节字数
   - 章节状态变化时正确更新小说总字数
   - UpdateWordCount方法正确实现

5. **查询功能**
   - GetChapters方法支持分页、筛选、排序
   - 支持按小说ID和分卷ID查询

6. **错误处理**
   - 所有错误消息使用中文
   - 错误处理完整、清晰

7. **代码规范**
   - 遵循Golang编码规范
   - 代码注释完整（使用中文）

## 相关文件

- `docs/TASKS/TASK007/TASK007-24.md` - NovelChapterRepository实现文档
- `docs/TASKS/TASK007/TASK007-42.md` - NovelVolumeService实现文档
- `docs/TASKS/TASK007/TASK007-41.md` - NovelService状态和统计管理实现文档
- `docs/TASKS/TASK007/TASK007-06.md` - NovelChapter模型实现文档
- `.cursor/rules/coding-standards.mdc` - Golang编码规范
- `internal/service/novel_chapter_service.go` - NovelChapterService接口和实现文件（待创建）

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.0  
**最后更新**: 2026-01-03 23:43:24 CST

