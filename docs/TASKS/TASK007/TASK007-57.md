# TASK007-57: 创建TagHandler接口和实现

## 任务信息

**任务编号**: TASK007-57  
**父任务**: TASK007  
**任务名称**: 创建TagHandler接口和实现  
**版本信息**: v1.2.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 23:53:38 CST

## 任务描述

创建标签控制器，提供标签管理的HTTP API处理。包括：1) 定义TagHandler接口；2) 实现GetTags方法（处理GET /api/v1/tags请求，支持分页、筛选、排序）；3) 实现GetTag方法（处理GET /api/v1/tags/{id}请求）；4) 实现CreateTag方法（处理POST /api/v1/tags请求，需要管理员权限）；5) 实现UpdateTag方法（处理PUT /api/v1/tags/{id}请求，需要管理员权限）；6) 实现DeleteTag方法（处理DELETE /api/v1/tags/{id}请求，需要管理员权限）；7) 格式化响应（Envelope格式）。所有代码必须遵循API设计规范。

## 依赖任务

TASK007-39（创建TagService接口和实现）

## 实现指南

### 1. 创建TagHandler接口文件

在 `internal/handler/` 目录下创建 `tag_handler.go` 文件，定义TagHandler接口：

```go
package handler

import (
    "github.com/gin-gonic/gin"
)

// TagHandler 标签控制器接口
// 提供标签管理的HTTP API处理
type TagHandler interface {
    // GetTags 获取标签列表（支持分页、筛选、排序）
    GetTags(c *gin.Context)
    
    // GetTag 根据ID获取标签
    GetTag(c *gin.Context)
    
    // CreateTag 创建标签（需要管理员权限）
    CreateTag(c *gin.Context)
    
    // UpdateTag 更新标签（需要管理员权限）
    UpdateTag(c *gin.Context)
    
    // DeleteTag 删除标签（需要管理员权限）
    DeleteTag(c *gin.Context)
}
```

### 2. 定义请求和响应结构体

```go
// CreateTagRequest 创建标签请求
type CreateTagRequest struct {
    TagName        string  `json:"tag_name" binding:"required"`
    TagDescription *string `json:"tag_description,omitempty"`
    IsActive       bool    `json:"is_active"`
}

// UpdateTagRequest 更新标签请求
type UpdateTagRequest struct {
    TagName        string  `json:"tag_name" binding:"required"`
    TagDescription *string `json:"tag_description,omitempty"`
    IsActive       bool    `json:"is_active"`
}
```

### 3. 实现TagHandler接口

在同一个文件中实现TagHandler接口：

```go
// tagHandler TagHandler的实现
type tagHandler struct {
    tagSvc service.TagService
}

// NewTagHandler 创建TagHandler实例
func NewTagHandler(tagSvc service.TagService) TagHandler {
    return &tagHandler{
        tagSvc: tagSvc,
    }
}

// GetTags 获取标签列表
func (h *tagHandler) GetTags(c *gin.Context) {
    // 获取查询参数
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
    name := c.Query("name")
    isActiveStr := c.Query("is_active")
    orderBy := c.DefaultQuery("order_by", "created_at")
    orderDir := c.DefaultQuery("order_dir", "desc")
    
    ctx := c.Request.Context()
    
    // 构建查询参数
    params := &service.TagQueryParams{
        Page:     page,
        Limit:    limit,
        Name:     name,
        OrderBy:  orderBy,
        OrderDir: orderDir,
    }
    
    // 处理is_active参数
    if isActiveStr != "" {
        isActive := isActiveStr == "true"
        params.IsActive = &isActive
    }
    
    tags, total, err := h.tagSvc.GetTags(ctx, params)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", "获取标签列表失败", "")
        return
    }
    
    // 构建分页响应
    response.BuildPaginatedResponse(c, tags, page, limit, int(total))
}

// GetTag 根据ID获取标签
func (h *tagHandler) GetTag(c *gin.Context) {
    // 获取路径参数
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_ID", "标签ID无效", "id")
        return
    }
    
    ctx := c.Request.Context()
    
    tag, err := h.tagSvc.GetTag(ctx, id)
    if err != nil {
        if errors.Is(err, repository.ErrTagNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "TAG_NOT_FOUND", "标签不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", "获取标签失败", "")
        return
    }
    
    response.BuildSuccessResponse(c, tag)
}

// CreateTag 创建标签
func (h *tagHandler) CreateTag(c *gin.Context) {
    var req CreateTagRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "VALIDATION_ERROR", "请求参数验证失败", "")
        return
    }
    
    ctx := c.Request.Context()
    
    // 构建标签模型
    tag := &models.Tag{
        TagName:        req.TagName,
        TagDescription: req.TagDescription,
        IsActive:       req.IsActive,
    }
    
    if err := h.tagSvc.CreateTag(ctx, tag); err != nil {
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", fmt.Sprintf("创建标签失败: %v", err), "")
        return
    }
    
    response.BuildSuccessResponse(c, tag)
}

// UpdateTag 更新标签
func (h *tagHandler) UpdateTag(c *gin.Context) {
    // 获取路径参数
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_ID", "标签ID无效", "id")
        return
    }
    
    var req UpdateTagRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "VALIDATION_ERROR", "请求参数验证失败", "")
        return
    }
    
    ctx := c.Request.Context()
    
    // 构建标签模型
    tag := &models.Tag{
        ID:              id,
        TagName:         req.TagName,
        TagDescription:  req.TagDescription,
        IsActive:        req.IsActive,
    }
    
    if err := h.tagSvc.UpdateTag(ctx, tag); err != nil {
        if errors.Is(err, repository.ErrTagNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "TAG_NOT_FOUND", "标签不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", fmt.Sprintf("更新标签失败: %v", err), "")
        return
    }
    
    response.BuildSuccessResponse(c, tag)
}

// DeleteTag 删除标签
func (h *tagHandler) DeleteTag(c *gin.Context) {
    // 获取路径参数
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_ID", "标签ID无效", "id")
        return
    }
    
    ctx := c.Request.Context()
    
    if err := h.tagSvc.DeleteTag(ctx, id); err != nil {
        if errors.Is(err, repository.ErrTagNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "TAG_NOT_FOUND", "标签不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", fmt.Sprintf("删除标签失败: %v", err), "")
        return
    }
    
    response.BuildSuccessResponse(c, nil)
}
```

### 4. 添加必要的导入

```go
package handler

import (
    "errors"
    "fmt"
    "net/http"
    "strconv"
    
    "github.com/gin-gonic/gin"
    
    "yourproject/internal/models"
    "yourproject/internal/repository"
    "yourproject/internal/response"
    "yourproject/internal/service"
)
```

### 5. 注意事项

- **API规范**：所有API必须遵循OpenAPI 3.1.1规范
- **响应格式**：所有响应必须使用Envelope格式
- **分页支持**：GetTags方法支持分页，需要使用BuildPaginatedResponse
- **错误处理**：所有错误消息必须使用中文
- **权限验证**：创建、更新、删除操作需要管理员权限（通过中间件实现）
- **参数验证**：使用Gin的binding进行请求参数验证
- **路径参数**：使用c.Param获取路径参数
- **查询参数**：使用c.Query获取查询参数

## 验收标准

1. **接口定义完整**
   - TagHandler接口包含所有必需方法
   - 方法签名正确

2. **请求处理完整**
   - GetTags方法支持分页、筛选、排序
   - GetTag方法正确获取标签详情
   - CreateTag方法正确创建标签
   - UpdateTag方法正确更新标签
   - DeleteTag方法正确删除标签

3. **响应格式**
   - 所有响应使用Envelope格式
   - 成功响应格式正确
   - 错误响应格式正确
   - 分页响应格式正确

4. **错误处理**
   - 所有错误消息使用中文
   - HTTP状态码使用正确
   - 错误代码定义清晰

5. **参数验证**
   - 请求参数验证正确
   - 路径参数验证正确
   - 查询参数处理正确

6. **代码规范**
   - 遵循Golang编码规范
   - 遵循API设计规范
   - 代码注释完整（使用中文）

## 相关文件

- `docs/TASKS/TASK007/TASK007-39.md` - TagService实现文档
- `docs/TASKS/TASK007/TASK007-03.md` - Tag模型实现文档
- `docs/TASKS/TASK007/TASK007-55.md` - CategoryHandler实现参考
- `.cursor/rules/api-design.mdc` - API设计规范
- `.cursor/rules/coding-standards.mdc` - Golang编码规范
- `internal/handler/tag_handler.go` - TagHandler接口和实现文件（待创建）

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.0  
**最后更新**: 2026-01-03 23:53:38 CST

