# TASK007-19: 实现CategoryRepository接口和实现

## 任务信息

**任务编号**: TASK007-19  
**父任务**: TASK007  
**任务名称**: 实现CategoryRepository接口和实现  
**版本信息**: v1.2.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 23:05:05 CST

## 任务描述

实现CategoryRepository接口，提供分类数据的CRUD操作。包括：1) 定义CategoryRepository接口（Create、GetByID、GetAll、Update、Delete、GetTree、GetChildren、GetByType等方法）；2) 实现CategoryRepository接口（使用GORM进行数据库操作）；3) 实现树形结构查询方法（支持递归查询子分类）。所有代码必须遵循Golang编码规范，错误消息使用中文。

## 依赖任务

TASK007-01（创建Category模型）

## 实现指南

### 1. 创建Repository接口文件

在 `internal/repository/` 目录下创建 `category_repository.go` 文件，定义CategoryRepository接口：

```go
package repository

import (
    "context"
    "yourproject/internal/models"
)

// CategoryRepository 分类仓储接口
// 提供分类数据的CRUD操作和树形结构查询
type CategoryRepository interface {
    // Create 创建分类
    Create(ctx context.Context, category *models.Category) error
    
    // GetByID 根据ID获取分类
    GetByID(ctx context.Context, id int64) (*models.Category, error)
    
    // GetAll 获取所有分类
    GetAll(ctx context.Context) ([]*models.Category, error)
    
    // Update 更新分类
    Update(ctx context.Context, category *models.Category) error
    
    // Delete 删除分类
    Delete(ctx context.Context, id int64) error
    
    // GetTree 获取分类树（所有分类的树形结构）
    GetTree(ctx context.Context) ([]*models.Category, error)
    
    // GetChildren 获取指定分类的所有子分类（递归）
    GetChildren(ctx context.Context, parentID int64) ([]*models.Category, error)
    
    // GetByType 根据分类类型获取分类列表
    GetByType(ctx context.Context, categoryType string) ([]*models.Category, error)
    
    // GetByParentID 根据父分类ID获取直接子分类（非递归）
    GetByParentID(ctx context.Context, parentID *int64) ([]*models.Category, error)
}
```

### 2. 创建Repository实现文件

在 `internal/repository/` 目录下创建 `category_repository_impl.go` 文件，实现CategoryRepository接口：

```go
package repository

import (
    "context"
    "errors"
    "fmt"
    "gorm.io/gorm"
    "yourproject/internal/models"
)

// categoryRepository CategoryRepository的实现
type categoryRepository struct {
    db *gorm.DB
}

// NewCategoryRepository 创建CategoryRepository实例
func NewCategoryRepository(db *gorm.DB) CategoryRepository {
    return &categoryRepository{
        db: db,
    }
}

// Create 创建分类
func (r *categoryRepository) Create(ctx context.Context, category *models.Category) error {
    if err := r.db.WithContext(ctx).Create(category).Error; err != nil {
        return fmt.Errorf("创建分类失败: %w", err)
    }
    return nil
}

// GetByID 根据ID获取分类
func (r *categoryRepository) GetByID(ctx context.Context, id int64) (*models.Category, error) {
    var category models.Category
    if err := r.db.WithContext(ctx).Where("id = ?", id).First(&category).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("分类不存在")
        }
        return nil, fmt.Errorf("查询分类失败: %w", err)
    }
    return &category, nil
}

// GetAll 获取所有分类
func (r *categoryRepository) GetAll(ctx context.Context) ([]*models.Category, error) {
    var categories []*models.Category
    if err := r.db.WithContext(ctx).Order("category_order ASC, id ASC").Find(&categories).Error; err != nil {
        return nil, fmt.Errorf("查询分类列表失败: %w", err)
    }
    return categories, nil
}

// Update 更新分类
func (r *categoryRepository) Update(ctx context.Context, category *models.Category) error {
    if err := r.db.WithContext(ctx).Save(category).Error; err != nil {
        return fmt.Errorf("更新分类失败: %w", err)
    }
    return nil
}

// Delete 删除分类
func (r *categoryRepository) Delete(ctx context.Context, id int64) error {
    // 检查是否存在子分类
    var count int64
    if err := r.db.WithContext(ctx).Model(&models.Category{}).Where("parent_id = ?", id).Count(&count).Error; err != nil {
        return fmt.Errorf("检查子分类失败: %w", err)
    }
    if count > 0 {
        return errors.New("存在子分类，无法删除")
    }
    
    if err := r.db.WithContext(ctx).Delete(&models.Category{}, id).Error; err != nil {
        return fmt.Errorf("删除分类失败: %w", err)
    }
    return nil
}

// GetTree 获取分类树（所有分类的树形结构）
func (r *categoryRepository) GetTree(ctx context.Context) ([]*models.Category, error) {
    // 获取所有分类
    allCategories, err := r.GetAll(ctx)
    if err != nil {
        return nil, err
    }
    
    // 构建分类树
    return r.buildTree(allCategories, nil), nil
}

// GetChildren 获取指定分类的所有子分类（递归）
func (r *categoryRepository) GetChildren(ctx context.Context, parentID int64) ([]*models.Category, error) {
    var children []*models.Category
    
    // 递归查询所有子分类
    if err := r.getChildrenRecursive(ctx, parentID, &children); err != nil {
        return nil, err
    }
    
    return children, nil
}

// getChildrenRecursive 递归获取子分类
func (r *categoryRepository) getChildrenRecursive(ctx context.Context, parentID int64, result *[]*models.Category) error {
    var directChildren []*models.Category
    if err := r.db.WithContext(ctx).Where("parent_id = ?", parentID).Order("category_order ASC, id ASC").Find(&directChildren).Error; err != nil {
        return fmt.Errorf("查询子分类失败: %w", err)
    }
    
    for _, child := range directChildren {
        *result = append(*result, child)
        // 递归查询子分类的子分类
        if err := r.getChildrenRecursive(ctx, child.ID, result); err != nil {
            return err
        }
    }
    
    return nil
}

// GetByType 根据分类类型获取分类列表
func (r *categoryRepository) GetByType(ctx context.Context, categoryType string) ([]*models.Category, error) {
    var categories []*models.Category
    if err := r.db.WithContext(ctx).Where("category_type = ?", categoryType).Order("category_order ASC, id ASC").Find(&categories).Error; err != nil {
        return nil, fmt.Errorf("查询分类列表失败: %w", err)
    }
    return categories, nil
}

// GetByParentID 根据父分类ID获取直接子分类（非递归）
func (r *categoryRepository) GetByParentID(ctx context.Context, parentID *int64) ([]*models.Category, error) {
    var categories []*models.Category
    query := r.db.WithContext(ctx)
    
    if parentID == nil {
        query = query.Where("parent_id IS NULL")
    } else {
        query = query.Where("parent_id = ?", *parentID)
    }
    
    if err := query.Order("category_order ASC, id ASC").Find(&categories).Error; err != nil {
        return nil, fmt.Errorf("查询子分类列表失败: %w", err)
    }
    return categories, nil
}

// buildTree 构建分类树
func (r *categoryRepository) buildTree(categories []*models.Category, parentID *int64) []*models.Category {
    var tree []*models.Category
    
    for _, category := range categories {
        var catParentID *int64
        if category.ParentID != nil {
            catParentID = category.ParentID
        }
        
        // 判断是否为当前父节点的子节点
        if (parentID == nil && catParentID == nil) || (parentID != nil && catParentID != nil && *parentID == *catParentID) {
            // 递归构建子树
            category.Children = r.buildTree(categories, &category.ID)
            tree = append(tree, category)
        }
    }
    
    return tree
}
```

### 3. 注意事项

- **错误处理**：所有错误消息必须使用中文
- **事务处理**：删除操作需要检查子分类，确保数据完整性
- **树形结构**：实现递归查询和树形结构构建
- **性能优化**：对于大量数据，考虑使用缓存优化查询性能
- **上下文传递**：所有数据库操作必须传递context.Context
- **排序规则**：按照category_order和id进行排序

## 验收标准

1. **接口定义完整**
   - CategoryRepository接口包含所有必需方法
   - 方法签名正确，参数和返回值类型正确

2. **实现完整**
   - 所有接口方法都有实现
   - CRUD操作正确实现
   - 树形结构查询正确实现

3. **错误处理**
   - 所有错误消息使用中文
   - 错误处理完整，包括记录不存在的情况

4. **代码规范**
   - 遵循Golang编码规范
   - 遵循GORM最佳实践
   - 代码注释完整（使用中文）

5. **功能正确性**
   - Create方法能正确创建分类
   - GetByID方法能正确查询分类
   - GetAll方法能正确查询所有分类
   - Update方法能正确更新分类
   - Delete方法能正确删除分类（检查子分类）
   - GetTree方法能正确构建分类树
   - GetChildren方法能正确递归查询子分类
   - GetByType方法能正确按类型查询
   - GetByParentID方法能正确查询直接子分类

## 相关文件

- `docs/TASKS/TASK007/TASK007-01.md` - Category模型实现参考
- `.cursor/rules/coding-standards.mdc` - Golang编码规范
- `internal/repository/category_repository.go` - CategoryRepository接口文件（待创建）
- `internal/repository/category_repository_impl.go` - CategoryRepository实现文件（待创建）

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.0  
**最后更新**: 2026-01-03 23:05:05 CST

