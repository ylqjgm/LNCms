# TASK007-60: 创建NovelHandler接口和实现 - 状态和删除API

## 任务信息

**任务编号**: TASK007-60  
**父任务**: TASK007  
**任务名称**: 创建NovelHandler接口和实现 - 状态和删除API  
**版本信息**: v1.2.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 23:53:38 CST

## 任务描述

扩展小说控制器，提供小说状态管理和删除的HTTP API处理。包括：1) 扩展NovelHandler接口；2) 实现UpdateNovelStatus方法（处理PUT /api/v1/novels/{id}/status请求，需要作者或管理员权限）；3) 实现DeleteNovel方法（处理DELETE /api/v1/novels/{id}请求，需要作者或管理员权限）；4) 调用NovelService；5) 格式化响应（Envelope格式）。所有代码必须遵循API设计规范。

## 依赖任务

TASK007-59（创建NovelHandler接口和实现 - 创建和更新API）、TASK007-41（创建NovelService接口和实现 - 状态和统计管理）

## 实现指南

### 1. 扩展NovelHandler接口

在 `internal/handler/novel_handler.go` 文件中扩展NovelHandler接口：

```go
// NovelHandler 小说控制器接口
// 提供小说管理的HTTP API处理
type NovelHandler interface {
    // GetNovels 获取小说列表（支持分页、筛选、排序）
    GetNovels(c *gin.Context)
    
    // GetNovel 根据ID获取小说
    GetNovel(c *gin.Context)
    
    // CreateNovel 创建小说（需要作者或管理员权限）
    CreateNovel(c *gin.Context)
    
    // UpdateNovel 更新小说（需要作者或管理员权限）
    UpdateNovel(c *gin.Context)
    
    // UpdateNovelStatus 更新小说状态（需要作者或管理员权限）
    UpdateNovelStatus(c *gin.Context)
    
    // DeleteNovel 删除小说（需要作者或管理员权限）
    DeleteNovel(c *gin.Context)
}
```

### 2. 定义请求结构体

在同一个文件中添加状态更新请求结构体：

```go
// UpdateNovelStatusRequest 更新小说状态请求
type UpdateNovelStatusRequest struct {
    Status string `json:"status" binding:"required"`
}
```

### 3. 实现UpdateNovelStatus方法

在 `novelHandler` 结构体中实现 `UpdateNovelStatus` 方法：

```go
// UpdateNovelStatus 更新小说状态
func (h *novelHandler) UpdateNovelStatus(c *gin.Context) {
    // 获取路径参数
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_ID", "小说ID无效", "id")
        return
    }
    
    var req UpdateNovelStatusRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "VALIDATION_ERROR", "请求参数验证失败", "")
        return
    }
    
    ctx := c.Request.Context()
    
    // 获取当前用户信息（从JWT token中获取）
    userID, exists := c.Get("user_id")
    if !exists {
        response.BuildErrorResponse(c, http.StatusUnauthorized, "UNAUTHORIZED", "未授权", "")
        return
    }
    
    // 检查权限：只有作者或管理员可以更新小说状态
    userRole, exists := c.Get("user_role")
    if !exists {
        response.BuildErrorResponse(c, http.StatusForbidden, "FORBIDDEN", "权限不足", "")
        return
    }
    
    role := userRole.(string)
    if role != "author" && role != "admin" {
        response.BuildErrorResponse(c, http.StatusForbidden, "FORBIDDEN", "权限不足：需要作者或管理员权限", "")
        return
    }
    
    // 检查小说是否存在
    existing, err := h.novelSvc.GetNovel(ctx, id)
    if err != nil {
        if errors.Is(err, repository.ErrNovelNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "NOVEL_NOT_FOUND", "小说不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", "获取小说失败", "")
        return
    }
    
    // 检查权限：作者只能更新自己的小说状态，管理员可以更新所有小说状态
    if role == "author" && existing.AuthorID != userID.(int64) {
        response.BuildErrorResponse(c, http.StatusForbidden, "FORBIDDEN", "权限不足：只能更新自己的小说状态", "")
        return
    }
    
    // 更新小说状态
    if err := h.novelSvc.UpdateStatus(ctx, id, req.Status); err != nil {
        if errors.Is(err, repository.ErrNovelNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "NOVEL_NOT_FOUND", "小说不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", fmt.Sprintf("更新小说状态失败: %v", err), "")
        return
    }
    
    // 获取更新后的小说信息
    novel, err := h.novelSvc.GetNovel(ctx, id)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", "获取小说失败", "")
        return
    }
    
    response.BuildSuccessResponse(c, novel)
}
```

### 4. 实现DeleteNovel方法

在 `novelHandler` 结构体中实现 `DeleteNovel` 方法：

```go
// DeleteNovel 删除小说
func (h *novelHandler) DeleteNovel(c *gin.Context) {
    // 获取路径参数
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_ID", "小说ID无效", "id")
        return
    }
    
    ctx := c.Request.Context()
    
    // 获取当前用户信息（从JWT token中获取）
    userID, exists := c.Get("user_id")
    if !exists {
        response.BuildErrorResponse(c, http.StatusUnauthorized, "UNAUTHORIZED", "未授权", "")
        return
    }
    
    // 检查权限：只有作者或管理员可以删除小说
    userRole, exists := c.Get("user_role")
    if !exists {
        response.BuildErrorResponse(c, http.StatusForbidden, "FORBIDDEN", "权限不足", "")
        return
    }
    
    role := userRole.(string)
    if role != "author" && role != "admin" {
        response.BuildErrorResponse(c, http.StatusForbidden, "FORBIDDEN", "权限不足：需要作者或管理员权限", "")
        return
    }
    
    // 检查小说是否存在
    existing, err := h.novelSvc.GetNovel(ctx, id)
    if err != nil {
        if errors.Is(err, repository.ErrNovelNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "NOVEL_NOT_FOUND", "小说不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", "获取小说失败", "")
        return
    }
    
    // 检查权限：作者只能删除自己的小说，管理员可以删除所有小说
    if role == "author" && existing.AuthorID != userID.(int64) {
        response.BuildErrorResponse(c, http.StatusForbidden, "FORBIDDEN", "权限不足：只能删除自己的小说", "")
        return
    }
    
    // 删除小说
    if err := h.novelSvc.DeleteNovel(ctx, id); err != nil {
        if errors.Is(err, repository.ErrNovelNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "NOVEL_NOT_FOUND", "小说不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", fmt.Sprintf("删除小说失败: %v", err), "")
        return
    }
    
    response.BuildSuccessResponse(c, nil)
}
```

### 5. 添加必要的导入

确保文件包含以下导入：

```go
package handler

import (
    "errors"
    "fmt"
    "net/http"
    "strconv"
    
    "github.com/gin-gonic/gin"
    
    "yourproject/internal/repository"
    "yourproject/internal/response"
    "yourproject/internal/service"
)
```

### 6. 注意事项

- **API规范**：所有API必须遵循OpenAPI 3.1.1规范
- **响应格式**：所有响应必须使用Envelope格式
- **权限验证**：状态更新和删除操作需要作者或管理员权限（通过中间件和Handler中验证）
- **资源权限**：作者只能操作自己的小说，管理员可以操作所有小说
- **参数验证**：使用Gin的binding进行请求参数验证
- **错误处理**：所有错误消息必须使用中文
- **JWT认证**：从JWT token中获取用户ID和角色信息
- **状态更新**：调用NovelService的UpdateStatus方法

## 验收标准

1. **接口扩展完整**
   - NovelHandler接口包含UpdateNovelStatus和DeleteNovel方法
   - 方法签名正确

2. **请求处理完整**
   - UpdateNovelStatus方法正确更新小说状态
   - DeleteNovel方法正确删除小说
   - 权限验证正确

3. **权限控制**
   - 状态更新操作需要作者或管理员权限
   - 删除操作需要作者或管理员权限
   - 作者只能操作自己的小说
   - 管理员可以操作所有小说

4. **响应格式**
   - 所有响应使用Envelope格式
   - 成功响应格式正确
   - 错误响应格式正确

5. **错误处理**
   - 所有错误消息使用中文
   - HTTP状态码使用正确
   - 错误代码定义清晰

6. **参数验证**
   - 请求参数验证正确
   - 路径参数验证正确

7. **代码规范**
   - 遵循Golang编码规范
   - 遵循API设计规范
   - 代码注释完整（使用中文）

## 相关文件

- `docs/TASKS/TASK007/TASK007-59.md` - NovelHandler创建和更新API实现文档
- `docs/TASKS/TASK007/TASK007-41.md` - NovelService状态和统计管理实现文档
- `docs/TASKS/TASK007/TASK007-40.md` - NovelService基础CRUD实现文档
- `docs/TASKS/TASK007/TASK007-04.md` - Novel模型实现文档
- `.cursor/rules/api-design.mdc` - API设计规范
- `.cursor/rules/coding-standards.mdc` - Golang编码规范
- `internal/handler/novel_handler.go` - NovelHandler接口和实现文件（待扩展）

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.0  
**最后更新**: 2026-01-03 23:53:38 CST

