# TASK007-22: 实现NovelRepository接口和实现

## 任务信息

**任务编号**: TASK007-22  
**父任务**: TASK007  
**任务名称**: 实现NovelRepository接口和实现  
**版本信息**: v1.2.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 23:19:17 CST

## 任务描述

实现NovelRepository接口，提供小说数据的CRUD操作。包括：1) 定义NovelRepository接口（Create、GetByID、GetAll、Update、Delete、GetByAuthorID、GetByCategoryID、GetByTagID、UpdateStatus、UpdateWordCount等方法）；2) 实现NovelRepository接口（使用GORM进行数据库操作）；3) 实现条件查询方法（支持分页、筛选、排序，包括按分类、标签、作者查询）。所有代码必须遵循Golang编码规范，错误消息使用中文。

## 依赖任务

TASK007-04（创建Novel模型）

## 实现指南

### 1. 参考数据库设计文档

阅读 `docs/TASKS/TASK002/TASK002-19.md` 文档，了解novels表的完整设计：
- 表结构：id、title、description、author_id、category_ids数组、tag_ids数组、cover_url、status、serial_status、rating、word_count、is_active、created_at、updated_at
- 外键关联：author_id 关联 authors 表
- 索引：author_id、status、serial_status、is_active、复合索引等
- 数组字段：category_ids、tag_ids使用PostgreSQL数组类型

### 2. 创建NovelRepository接口文件

在 `internal/repository/` 目录下创建 `novel_repository.go` 文件，定义NovelRepository接口：

```go
package repository

import (
    "context"
    "yourproject/internal/models"
)

// NovelRepository 小说仓储接口
// 提供小说数据的CRUD操作和条件查询
type NovelRepository interface {
    // Create 创建小说
    Create(ctx context.Context, novel *models.Novel) error
    
    // GetByID 根据ID获取小说
    GetByID(ctx context.Context, id int64) (*models.Novel, error)
    
    // GetAll 获取小说列表（支持分页、筛选、排序）
    GetAll(ctx context.Context, params *NovelQueryParams) ([]*models.Novel, int64, error)
    
    // Update 更新小说
    Update(ctx context.Context, novel *models.Novel) error
    
    // Delete 删除小说
    Delete(ctx context.Context, id int64) error
    
    // GetByAuthorID 根据作者ID获取小说列表
    GetByAuthorID(ctx context.Context, authorID int64, params *NovelQueryParams) ([]*models.Novel, int64, error)
    
    // GetByCategoryID 根据分类ID获取小说列表
    GetByCategoryID(ctx context.Context, categoryID int64, params *NovelQueryParams) ([]*models.Novel, int64, error)
    
    // GetByTagID 根据标签ID获取小说列表
    GetByTagID(ctx context.Context, tagID int64, params *NovelQueryParams) ([]*models.Novel, int64, error)
    
    // UpdateStatus 更新小说状态
    UpdateStatus(ctx context.Context, id int64, status string) error
    
    // UpdateWordCount 更新小说字数
    UpdateWordCount(ctx context.Context, id int64, wordCount int64) error
}
```

### 3. 定义查询参数结构

```go
// NovelQueryParams 小说查询参数
type NovelQueryParams struct {
    Page          int      // 页码，从1开始
    Limit         int      // 每页数量
    Title         string   // 标题筛选（模糊匹配）
    AuthorID      *int64   // 作者ID筛选
    CategoryIDs   []int64  // 分类ID筛选（数组包含查询）
    TagIDs        []int64  // 标签ID筛选（数组包含查询）
    Status        string   // 状态筛选
    SerialStatus  string   // 连载状态筛选
    IsActive      *bool    // 是否启用筛选
    OrderBy       string   // 排序字段（title、created_at、updated_at、word_count、rating）
    OrderDir      string   // 排序方向（asc、desc）
}
```

### 4. 实现NovelRepository接口

```go
// novelRepository NovelRepository接口实现
type novelRepository struct {
    db *gorm.DB
}

// NewNovelRepository 创建NovelRepository实例
func NewNovelRepository(db *gorm.DB) NovelRepository {
    return &novelRepository{db: db}
}

// Create 创建小说
func (r *novelRepository) Create(ctx context.Context, novel *models.Novel) error {
    if err := r.db.WithContext(ctx).Create(novel).Error; err != nil {
        return fmt.Errorf("创建小说失败: %w", err)
    }
    return nil
}

// GetByID 根据ID获取小说
func (r *novelRepository) GetByID(ctx context.Context, id int64) (*models.Novel, error) {
    var novel models.Novel
    if err := r.db.WithContext(ctx).Where("id = ?", id).First(&novel).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, fmt.Errorf("小说不存在")
        }
        return nil, fmt.Errorf("查询小说失败: %w", err)
    }
    return &novel, nil
}

// GetAll 获取小说列表（支持分页、筛选、排序）
func (r *novelRepository) GetAll(ctx context.Context, params *NovelQueryParams) ([]*models.Novel, int64, error) {
    var novels []*models.Novel
    var total int64
    
    // 构建查询
    query := r.db.WithContext(ctx).Model(&models.Novel{})
    
    // 应用筛选条件
    if params.Title != "" {
        query = query.Where("title ILIKE ?", "%"+params.Title+"%")
    }
    if params.AuthorID != nil {
        query = query.Where("author_id = ?", *params.AuthorID)
    }
    if len(params.CategoryIDs) > 0 {
        // PostgreSQL数组包含查询
        query = query.Where("category_ids && ?", pq.Array(params.CategoryIDs))
    }
    if len(params.TagIDs) > 0 {
        // PostgreSQL数组包含查询
        query = query.Where("tag_ids && ?", pq.Array(params.TagIDs))
    }
    if params.Status != "" {
        query = query.Where("status = ?", params.Status)
    }
    if params.SerialStatus != "" {
        query = query.Where("serial_status = ?", params.SerialStatus)
    }
    if params.IsActive != nil {
        query = query.Where("is_active = ?", *params.IsActive)
    }
    
    // 获取总数
    if err := query.Count(&total).Error; err != nil {
        return nil, 0, fmt.Errorf("查询小说总数失败: %w", err)
    }
    
    // 应用排序
    orderBy := "created_at"
    if params.OrderBy != "" {
        // 验证排序字段，防止SQL注入
        validOrderBy := map[string]bool{
            "title":      true,
            "created_at": true,
            "updated_at": true,
            "word_count": true,
            "rating":     true,
        }
        if validOrderBy[params.OrderBy] {
            orderBy = params.OrderBy
        }
    }
    orderDir := "desc"
    if params.OrderDir == "asc" {
        orderDir = "asc"
    }
    query = query.Order(orderBy + " " + orderDir)
    
    // 应用分页
    page := params.Page
    if page < 1 {
        page = 1
    }
    limit := params.Limit
    if limit < 1 {
        limit = 20
    }
    if limit > 100 {
        limit = 100
    }
    offset := (page - 1) * limit
    query = query.Offset(offset).Limit(limit)
    
    // 执行查询
    if err := query.Find(&novels).Error; err != nil {
        return nil, 0, fmt.Errorf("查询小说列表失败: %w", err)
    }
    
    return novels, total, nil
}

// Update 更新小说
func (r *novelRepository) Update(ctx context.Context, novel *models.Novel) error {
    if err := r.db.WithContext(ctx).Save(novel).Error; err != nil {
        return fmt.Errorf("更新小说失败: %w", err)
    }
    return nil
}

// Delete 删除小说
func (r *novelRepository) Delete(ctx context.Context, id int64) error {
    result := r.db.WithContext(ctx).Delete(&models.Novel{}, id)
    if result.Error != nil {
        return fmt.Errorf("删除小说失败: %w", result.Error)
    }
    if result.RowsAffected == 0 {
        return fmt.Errorf("小说不存在")
    }
    return nil
}

// GetByAuthorID 根据作者ID获取小说列表
func (r *novelRepository) GetByAuthorID(ctx context.Context, authorID int64, params *NovelQueryParams) ([]*models.Novel, int64, error) {
    params.AuthorID = &authorID
    return r.GetAll(ctx, params)
}

// GetByCategoryID 根据分类ID获取小说列表
func (r *novelRepository) GetByCategoryID(ctx context.Context, categoryID int64, params *NovelQueryParams) ([]*models.Novel, int64, error) {
    params.CategoryIDs = []int64{categoryID}
    return r.GetAll(ctx, params)
}

// GetByTagID 根据标签ID获取小说列表
func (r *novelRepository) GetByTagID(ctx context.Context, tagID int64, params *NovelQueryParams) ([]*models.Novel, int64, error) {
    params.TagIDs = []int64{tagID}
    return r.GetAll(ctx, params)
}

// UpdateStatus 更新小说状态
func (r *novelRepository) UpdateStatus(ctx context.Context, id int64, status string) error {
    result := r.db.WithContext(ctx).Model(&models.Novel{}).
        Where("id = ?", id).
        Update("status", status)
    if result.Error != nil {
        return fmt.Errorf("更新小说状态失败: %w", result.Error)
    }
    if result.RowsAffected == 0 {
        return fmt.Errorf("小说不存在")
    }
    return nil
}

// UpdateWordCount 更新小说字数
func (r *novelRepository) UpdateWordCount(ctx context.Context, id int64, wordCount int64) error {
    result := r.db.WithContext(ctx).Model(&models.Novel{}).
        Where("id = ?", id).
        Update("word_count", wordCount)
    if result.Error != nil {
        return fmt.Errorf("更新小说字数失败: %w", result.Error)
    }
    if result.RowsAffected == 0 {
        return fmt.Errorf("小说不存在")
    }
    return nil
}
```

### 5. 添加必要的导入

```go
package repository

import (
    "context"
    "errors"
    "fmt"
    
    "github.com/lib/pq"
    "gorm.io/gorm"
    "yourproject/internal/models"
)
```

### 6. 注意事项

- **数组查询**：使用PostgreSQL的数组操作符（&&）进行数组包含查询
- **错误处理**：所有错误消息必须使用中文
- **上下文传递**：所有数据库操作必须使用context.Context
- **分页验证**：验证分页参数，确保page >= 1，limit在1-100之间
- **排序安全**：验证排序字段，防止SQL注入
- **数组字段处理**：正确处理category_ids和tag_ids数组字段
- **关联查询**：如果需要关联查询作者信息，使用Preload或Join

## 验收标准

1. **接口定义完整**
   - NovelRepository接口包含所有必需方法
   - 方法签名正确，参数和返回值合理

2. **实现完整**
   - 所有接口方法都已实现
   - 实现逻辑正确，错误处理完善

3. **查询功能**
   - 支持分页查询
   - 支持按标题筛选（模糊匹配）
   - 支持按作者ID筛选
   - 支持按分类ID筛选（数组包含查询）
   - 支持按标签ID筛选（数组包含查询）
   - 支持按状态、连载状态、启用状态筛选
   - 支持排序（按标题、创建时间、更新时间、字数、评分）

4. **数组查询**
   - 正确实现PostgreSQL数组包含查询
   - 支持多个分类ID和标签ID的筛选

5. **错误处理**
   - 所有错误消息使用中文
   - 正确处理记录不存在等错误

6. **代码规范**
   - 遵循Golang编码规范
   - 遵循GORM最佳实践
   - 代码注释完整（使用中文）

## 相关文件

- `docs/TASKS/TASK002/TASK002-19.md` - 小说表数据库设计文档
- `docs/TASKS/TASK007/TASK007-04.md` - Novel模型实现文档
- `docs/TASKS/TASK006/TASK006-04.md` - AuthorRepository实现参考
- `.cursor/rules/coding-standards.mdc` - Golang编码规范
- `internal/repository/novel_repository.go` - NovelRepository接口和实现文件（待创建）

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.0  
**最后更新**: 2026-01-03 23:19:17 CST

