# TASK007-59: 创建NovelHandler接口和实现 - 创建和更新API

## 任务信息

**任务编号**: TASK007-59  
**父任务**: TASK007  
**任务名称**: 创建NovelHandler接口和实现 - 创建和更新API  
**版本信息**: v1.2.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 23:53:38 CST

## 任务描述

扩展小说控制器，提供小说创建和更新的HTTP API处理。包括：1) 扩展NovelHandler接口；2) 实现CreateNovel方法（处理POST /api/v1/novels请求，需要作者或管理员权限）；3) 实现UpdateNovel方法（处理PUT /api/v1/novels/{id}请求，需要作者或管理员权限）；4) 调用NovelService；5) 格式化响应（Envelope格式）。所有代码必须遵循API设计规范。

## 依赖任务

TASK007-58（创建NovelHandler接口和实现 - 列表和详情API）、TASK007-40（创建NovelService接口和实现 - 基础CRUD）

## 实现指南

### 1. 扩展NovelHandler接口

在 `internal/handler/novel_handler.go` 文件中扩展NovelHandler接口：

```go
// NovelHandler 小说控制器接口
// 提供小说管理的HTTP API处理
type NovelHandler interface {
    // GetNovels 获取小说列表（支持分页、筛选、排序）
    GetNovels(c *gin.Context)
    
    // GetNovel 根据ID获取小说
    GetNovel(c *gin.Context)
    
    // CreateNovel 创建小说（需要作者或管理员权限）
    CreateNovel(c *gin.Context)
    
    // UpdateNovel 更新小说（需要作者或管理员权限）
    UpdateNovel(c *gin.Context)
}
```

### 2. 定义请求结构体

在同一个文件中添加请求结构体：

```go
// CreateNovelRequest 创建小说请求
type CreateNovelRequest struct {
    Title         string   `json:"title" binding:"required"`
    Description   *string  `json:"description,omitempty"`
    AuthorID      int64    `json:"author_id" binding:"required"`
    CategoryIDs   []int64  `json:"category_ids,omitempty"`
    TagIDs        []int64  `json:"tag_ids,omitempty"`
    CoverURL      *string  `json:"cover_url,omitempty"`
    Status        string   `json:"status"`
    SerialStatus  string   `json:"serial_status"`
    Rating        float64  `json:"rating"`
    IsActive      *bool    `json:"is_active"`
}

// UpdateNovelRequest 更新小说请求
type UpdateNovelRequest struct {
    Title         string   `json:"title" binding:"required"`
    Description   *string  `json:"description,omitempty"`
    AuthorID      int64    `json:"author_id" binding:"required"`
    CategoryIDs   []int64  `json:"category_ids,omitempty"`
    TagIDs        []int64   `json:"tag_ids,omitempty"`
    CoverURL      *string  `json:"cover_url,omitempty"`
    Status        string   `json:"status"`
    SerialStatus  string   `json:"serial_status"`
    Rating        float64  `json:"rating"`
    IsActive      *bool    `json:"is_active"`
}
```

### 3. 实现CreateNovel方法

在 `novelHandler` 结构体中实现 `CreateNovel` 方法：

```go
// CreateNovel 创建小说
func (h *novelHandler) CreateNovel(c *gin.Context) {
    var req CreateNovelRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "VALIDATION_ERROR", "请求参数验证失败", "")
        return
    }
    
    ctx := c.Request.Context()
    
    // 获取当前用户信息（从JWT token中获取）
    userID, exists := c.Get("user_id")
    if !exists {
        response.BuildErrorResponse(c, http.StatusUnauthorized, "UNAUTHORIZED", "未授权", "")
        return
    }
    
    // 检查权限：只有作者或管理员可以创建小说
    userRole, exists := c.Get("user_role")
    if !exists {
        response.BuildErrorResponse(c, http.StatusForbidden, "FORBIDDEN", "权限不足", "")
        return
    }
    
    role := userRole.(string)
    if role != "author" && role != "admin" {
        response.BuildErrorResponse(c, http.StatusForbidden, "FORBIDDEN", "权限不足：需要作者或管理员权限", "")
        return
    }
    
    // 构建小说模型
    novel := &models.Novel{
        Title:        req.Title,
        Description:  req.Description,
        AuthorID:     req.AuthorID,
        CategoryIDs:  req.CategoryIDs,
        TagIDs:       req.TagIDs,
        CoverURL:     req.CoverURL,
        Status:       req.Status,
        SerialStatus: req.SerialStatus,
        Rating:       req.Rating,
        IsActive:     req.IsActive,
    }
    
    if err := h.novelSvc.CreateNovel(ctx, novel); err != nil {
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", fmt.Sprintf("创建小说失败: %v", err), "")
        return
    }
    
    response.BuildSuccessResponse(c, novel)
}
```

### 4. 实现UpdateNovel方法

在 `novelHandler` 结构体中实现 `UpdateNovel` 方法：

```go
// UpdateNovel 更新小说
func (h *novelHandler) UpdateNovel(c *gin.Context) {
    // 获取路径参数
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_ID", "小说ID无效", "id")
        return
    }
    
    var req UpdateNovelRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "VALIDATION_ERROR", "请求参数验证失败", "")
        return
    }
    
    ctx := c.Request.Context()
    
    // 获取当前用户信息（从JWT token中获取）
    userID, exists := c.Get("user_id")
    if !exists {
        response.BuildErrorResponse(c, http.StatusUnauthorized, "UNAUTHORIZED", "未授权", "")
        return
    }
    
    // 检查权限：只有作者或管理员可以更新小说
    userRole, exists := c.Get("user_role")
    if !exists {
        response.BuildErrorResponse(c, http.StatusForbidden, "FORBIDDEN", "权限不足", "")
        return
    }
    
    role := userRole.(string)
    if role != "author" && role != "admin" {
        response.BuildErrorResponse(c, http.StatusForbidden, "FORBIDDEN", "权限不足：需要作者或管理员权限", "")
        return
    }
    
    // 检查小说是否存在
    existing, err := h.novelSvc.GetNovel(ctx, id)
    if err != nil {
        if errors.Is(err, repository.ErrNovelNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "NOVEL_NOT_FOUND", "小说不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", "获取小说失败", "")
        return
    }
    
    // 检查权限：作者只能更新自己的小说，管理员可以更新所有小说
    if role == "author" && existing.AuthorID != userID.(int64) {
        response.BuildErrorResponse(c, http.StatusForbidden, "FORBIDDEN", "权限不足：只能更新自己的小说", "")
        return
    }
    
    // 构建小说模型
    novel := &models.Novel{
        ID:           id,
        Title:        req.Title,
        Description:  req.Description,
        AuthorID:     req.AuthorID,
        CategoryIDs:  req.CategoryIDs,
        TagIDs:       req.TagIDs,
        CoverURL:     req.CoverURL,
        Status:       req.Status,
        SerialStatus: req.SerialStatus,
        Rating:       req.Rating,
        IsActive:     req.IsActive,
    }
    
    if err := h.novelSvc.UpdateNovel(ctx, novel); err != nil {
        if errors.Is(err, repository.ErrNovelNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "NOVEL_NOT_FOUND", "小说不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", fmt.Sprintf("更新小说失败: %v", err), "")
        return
    }
    
    response.BuildSuccessResponse(c, novel)
}
```

### 5. 添加必要的导入

确保文件包含以下导入：

```go
package handler

import (
    "errors"
    "fmt"
    "net/http"
    "strconv"
    
    "github.com/gin-gonic/gin"
    
    "yourproject/internal/models"
    "yourproject/internal/repository"
    "yourproject/internal/response"
    "yourproject/internal/service"
)
```

### 6. 注意事项

- **API规范**：所有API必须遵循OpenAPI 3.1.1规范
- **响应格式**：所有响应必须使用Envelope格式
- **权限验证**：创建和更新操作需要作者或管理员权限（通过中间件和Handler中验证）
- **资源权限**：作者只能更新自己的小说，管理员可以更新所有小说
- **参数验证**：使用Gin的binding进行请求参数验证
- **错误处理**：所有错误消息必须使用中文
- **JWT认证**：从JWT token中获取用户ID和角色信息

## 验收标准

1. **接口扩展完整**
   - NovelHandler接口包含CreateNovel和UpdateNovel方法
   - 方法签名正确

2. **请求处理完整**
   - CreateNovel方法正确创建小说
   - UpdateNovel方法正确更新小说
   - 权限验证正确

3. **权限控制**
   - 创建操作需要作者或管理员权限
   - 更新操作需要作者或管理员权限
   - 作者只能更新自己的小说
   - 管理员可以更新所有小说

4. **响应格式**
   - 所有响应使用Envelope格式
   - 成功响应格式正确
   - 错误响应格式正确

5. **错误处理**
   - 所有错误消息使用中文
   - HTTP状态码使用正确
   - 错误代码定义清晰

6. **参数验证**
   - 请求参数验证正确
   - 路径参数验证正确

7. **代码规范**
   - 遵循Golang编码规范
   - 遵循API设计规范
   - 代码注释完整（使用中文）

## 相关文件

- `docs/TASKS/TASK007/TASK007-58.md` - NovelHandler列表和详情API实现文档
- `docs/TASKS/TASK007/TASK007-40.md` - NovelService实现文档
- `docs/TASKS/TASK007/TASK007-04.md` - Novel模型实现文档
- `.cursor/rules/api-design.mdc` - API设计规范
- `.cursor/rules/coding-standards.mdc` - Golang编码规范
- `internal/handler/novel_handler.go` - NovelHandler接口和实现文件（待扩展）

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.0  
**最后更新**: 2026-01-03 23:53:38 CST

