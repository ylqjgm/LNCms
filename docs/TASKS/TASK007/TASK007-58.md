# TASK007-58: 创建NovelHandler接口和实现 - 列表和详情API

## 任务信息

**任务编号**: TASK007-58  
**父任务**: TASK007  
**任务名称**: 创建NovelHandler接口和实现 - 列表和详情API  
**版本信息**: v1.2.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 23:53:38 CST

## 任务描述

创建小说控制器，提供小说列表查询和详情查询的HTTP API处理。包括：1) 定义NovelHandler接口；2) 实现GetNovels方法（处理GET /api/v1/novels请求，支持分页、筛选、排序）；3) 实现GetNovel方法（处理GET /api/v1/novels/{id}请求）；4) 调用NovelService；5) 格式化响应（Envelope格式）。所有代码必须遵循API设计规范。

## 依赖任务

TASK007-40（创建NovelService接口和实现 - 基础CRUD）

## 实现指南

### 1. 创建NovelHandler接口文件

在 `internal/handler/` 目录下创建 `novel_handler.go` 文件，定义NovelHandler接口：

```go
package handler

import (
    "github.com/gin-gonic/gin"
)

// NovelHandler 小说控制器接口
// 提供小说管理的HTTP API处理
type NovelHandler interface {
    // GetNovels 获取小说列表（支持分页、筛选、排序）
    GetNovels(c *gin.Context)
    
    // GetNovel 根据ID获取小说
    GetNovel(c *gin.Context)
}
```

### 2. 实现NovelHandler接口

在同一个文件中实现NovelHandler接口：

```go
// novelHandler NovelHandler的实现
type novelHandler struct {
    novelSvc service.NovelService
}

// NewNovelHandler 创建NovelHandler实例
func NewNovelHandler(novelSvc service.NovelService) NovelHandler {
    return &novelHandler{
        novelSvc: novelSvc,
    }
}

// GetNovels 获取小说列表
func (h *novelHandler) GetNovels(c *gin.Context) {
    // 获取查询参数
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
    title := c.Query("title")
    authorIDStr := c.Query("author_id")
    categoryIDsStr := c.Query("category_ids")
    tagIDsStr := c.Query("tag_ids")
    status := c.Query("status")
    serialStatus := c.Query("serial_status")
    isActiveStr := c.Query("is_active")
    orderBy := c.DefaultQuery("order_by", "created_at")
    orderDir := c.DefaultQuery("order_dir", "desc")
    
    ctx := c.Request.Context()
    
    // 构建查询参数
    params := &service.NovelQueryParams{
        Page:         page,
        Limit:        limit,
        Title:        title,
        Status:       status,
        SerialStatus: serialStatus,
        OrderBy:      orderBy,
        OrderDir:    orderDir,
    }
    
    // 处理author_id参数
    if authorIDStr != "" {
        authorID, err := strconv.ParseInt(authorIDStr, 10, 64)
        if err == nil {
            params.AuthorID = &authorID
        }
    }
    
    // 处理category_ids参数（逗号分隔）
    if categoryIDsStr != "" {
        categoryIDs := parseInt64Slice(categoryIDsStr)
        if len(categoryIDs) > 0 {
            params.CategoryIDs = categoryIDs
        }
    }
    
    // 处理tag_ids参数（逗号分隔）
    if tagIDsStr != "" {
        tagIDs := parseInt64Slice(tagIDsStr)
        if len(tagIDs) > 0 {
            params.TagIDs = tagIDs
        }
    }
    
    // 处理is_active参数
    if isActiveStr != "" {
        isActive := isActiveStr == "true"
        params.IsActive = &isActive
    }
    
    novels, total, err := h.novelSvc.GetNovels(ctx, params)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", "获取小说列表失败", "")
        return
    }
    
    // 构建分页响应
    response.BuildPaginatedResponse(c, novels, page, limit, int(total))
}

// GetNovel 根据ID获取小说
func (h *novelHandler) GetNovel(c *gin.Context) {
    // 获取路径参数
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_ID", "小说ID无效", "id")
        return
    }
    
    ctx := c.Request.Context()
    
    novel, err := h.novelSvc.GetNovel(ctx, id)
    if err != nil {
        if errors.Is(err, repository.ErrNovelNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "NOVEL_NOT_FOUND", "小说不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", "获取小说失败", "")
        return
    }
    
    response.BuildSuccessResponse(c, novel)
}

// parseInt64Slice 解析逗号分隔的整数字符串为int64切片
func parseInt64Slice(s string) []int64 {
    parts := strings.Split(s, ",")
    result := make([]int64, 0, len(parts))
    for _, part := range parts {
        part = strings.TrimSpace(part)
        if part == "" {
            continue
        }
        id, err := strconv.ParseInt(part, 10, 64)
        if err == nil {
            result = append(result, id)
        }
    }
    return result
}
```

### 3. 添加必要的导入

```go
package handler

import (
    "errors"
    "net/http"
    "strconv"
    "strings"
    
    "github.com/gin-gonic/gin"
    
    "yourproject/internal/repository"
    "yourproject/internal/response"
    "yourproject/internal/service"
)
```

### 4. 注意事项

- **API规范**：所有API必须遵循OpenAPI 3.1.1规范
- **响应格式**：所有响应必须使用Envelope格式
- **分页支持**：GetNovels方法支持分页，需要使用BuildPaginatedResponse
- **查询参数**：支持多个查询参数，包括分页、筛选、排序
- **数组参数**：category_ids和tag_ids使用逗号分隔的字符串，需要解析为切片
- **错误处理**：所有错误消息必须使用中文
- **路径参数**：使用c.Param获取路径参数
- **查询参数**：使用c.Query获取查询参数

## 验收标准

1. **接口定义完整**
   - NovelHandler接口包含GetNovels和GetNovel方法
   - 方法签名正确

2. **请求处理完整**
   - GetNovels方法支持分页、筛选、排序
   - GetNovel方法正确获取小说详情
   - 查询参数解析正确

3. **响应格式**
   - 所有响应使用Envelope格式
   - 成功响应格式正确
   - 错误响应格式正确
   - 分页响应格式正确

4. **错误处理**
   - 所有错误消息使用中文
   - HTTP状态码使用正确
   - 错误代码定义清晰

5. **参数验证**
   - 路径参数验证正确
   - 查询参数处理正确
   - 数组参数解析正确

6. **代码规范**
   - 遵循Golang编码规范
   - 遵循API设计规范
   - 代码注释完整（使用中文）

## 相关文件

- `docs/TASKS/TASK007/TASK007-40.md` - NovelService实现文档
- `docs/TASKS/TASK007/TASK007-04.md` - Novel模型实现文档
- `docs/TASKS/TASK007/TASK007-55.md` - CategoryHandler实现参考
- `.cursor/rules/api-design.mdc` - API设计规范
- `.cursor/rules/coding-standards.mdc` - Golang编码规范
- `internal/handler/novel_handler.go` - NovelHandler接口和实现文件（待创建）

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.0  
**最后更新**: 2026-01-03 23:53:38 CST

