# TASK007-61: 创建NovelVolumeHandler和NovelChapterHandler接口和实现

## 任务信息

**任务编号**: TASK007-61  
**父任务**: TASK007  
**任务名称**: 创建NovelVolumeHandler和NovelChapterHandler接口和实现  
**版本信息**: v1.2.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-04 00:01:47 CST

## 任务描述

创建小说分卷和章节控制器，提供小说分卷和章节管理的HTTP API处理。包括：1) 定义NovelVolumeHandler和NovelChapterHandler接口；2) 实现分卷和章节的CRUD API端点；3) 调用对应的Service；4) 格式化响应（Envelope格式）。所有代码必须遵循API设计规范。

## 依赖任务

TASK007-42（创建NovelVolumeService接口和实现）、TASK007-43（创建NovelChapterService接口和实现）

## 实现指南

### 1. 创建NovelVolumeHandler接口文件

在 `internal/handler/` 目录下创建 `novel_volume_handler.go` 文件，定义NovelVolumeHandler接口：

```go
package handler

import (
    "github.com/gin-gonic/gin"
)

// NovelVolumeHandler 小说分卷控制器接口
// 提供小说分卷管理的HTTP API处理
type NovelVolumeHandler interface {
    // GetVolumes 获取分卷列表
    GetVolumes(c *gin.Context)
    
    // GetVolume 根据ID获取分卷
    GetVolume(c *gin.Context)
    
    // CreateVolume 创建分卷（需要作者或管理员权限）
    CreateVolume(c *gin.Context)
    
    // UpdateVolume 更新分卷（需要作者或管理员权限）
    UpdateVolume(c *gin.Context)
    
    // DeleteVolume 删除分卷（需要作者或管理员权限）
    DeleteVolume(c *gin.Context)
}
```

### 2. 创建NovelChapterHandler接口文件

在 `internal/handler/` 目录下创建 `novel_chapter_handler.go` 文件，定义NovelChapterHandler接口：

```go
package handler

import (
    "github.com/gin-gonic/gin"
)

// NovelChapterHandler 小说章节控制器接口
// 提供小说章节管理的HTTP API处理
type NovelChapterHandler interface {
    // GetChapters 获取章节列表（支持分页、排序）
    GetChapters(c *gin.Context)
    
    // GetChapter 根据ID获取章节
    GetChapter(c *gin.Context)
    
    // CreateChapter 创建章节（需要作者或管理员权限）
    CreateChapter(c *gin.Context)
    
    // UpdateChapter 更新章节（需要作者或管理员权限）
    UpdateChapter(c *gin.Context)
    
    // DeleteChapter 删除章节（需要作者或管理员权限）
    DeleteChapter(c *gin.Context)
    
    // UpdateChapterStatus 更新章节状态（需要作者或管理员权限）
    UpdateChapterStatus(c *gin.Context)
}
```

### 3. 实现NovelVolumeHandler接口

在 `novel_volume_handler.go` 文件中实现NovelVolumeHandler接口：

```go
// novelVolumeHandler NovelVolumeHandler的实现
type novelVolumeHandler struct {
    volumeSvc service.NovelVolumeService
}

// NewNovelVolumeHandler 创建NovelVolumeHandler实例
func NewNovelVolumeHandler(volumeSvc service.NovelVolumeService) NovelVolumeHandler {
    return &novelVolumeHandler{
        volumeSvc: volumeSvc,
    }
}

// GetVolumes 获取分卷列表
func (h *novelVolumeHandler) GetVolumes(c *gin.Context) {
    novelIDStr := c.Query("novel_id")
    if novelIDStr == "" {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_PARAM", "novel_id参数必填", "novel_id")
        return
    }
    
    novelID, err := strconv.ParseInt(novelIDStr, 10, 64)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_PARAM", "novel_id参数无效", "novel_id")
        return
    }
    
    ctx := c.Request.Context()
    
    volumes, err := h.volumeSvc.GetVolumes(ctx, novelID)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", "获取分卷列表失败", "")
        return
    }
    
    response.BuildSuccessResponse(c, volumes)
}

// GetVolume 根据ID获取分卷
func (h *novelVolumeHandler) GetVolume(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_ID", "分卷ID无效", "id")
        return
    }
    
    ctx := c.Request.Context()
    
    volume, err := h.volumeSvc.GetVolume(ctx, id)
    if err != nil {
        if errors.Is(err, repository.ErrNovelVolumeNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "VOLUME_NOT_FOUND", "分卷不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", "获取分卷失败", "")
        return
    }
    
    response.BuildSuccessResponse(c, volume)
}

// CreateVolume 创建分卷
func (h *novelVolumeHandler) CreateVolume(c *gin.Context) {
    var req CreateNovelVolumeRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "VALIDATION_ERROR", "请求参数验证失败", "")
        return
    }
    
    ctx := c.Request.Context()
    
    // 权限验证（参考NovelHandler的实现）
    // ...
    
    volume := &models.NovelVolume{
        NovelID:     req.NovelID,
        VolumeName:  req.VolumeName,
        Description: req.Description,
        SortOrder:   req.SortOrder,
        Status:      req.Status,
    }
    
    if err := h.volumeSvc.CreateVolume(ctx, volume); err != nil {
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", fmt.Sprintf("创建分卷失败: %v", err), "")
        return
    }
    
    response.BuildSuccessResponse(c, volume)
}

// UpdateVolume 更新分卷
func (h *novelVolumeHandler) UpdateVolume(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_ID", "分卷ID无效", "id")
        return
    }
    
    var req UpdateNovelVolumeRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "VALIDATION_ERROR", "请求参数验证失败", "")
        return
    }
    
    ctx := c.Request.Context()
    
    // 权限验证（参考NovelHandler的实现）
    // ...
    
    volume := &models.NovelVolume{
        ID:          id,
        NovelID:     req.NovelID,
        VolumeName:  req.VolumeName,
        Description: req.Description,
        SortOrder:   req.SortOrder,
        Status:      req.Status,
    }
    
    if err := h.volumeSvc.UpdateVolume(ctx, volume); err != nil {
        if errors.Is(err, repository.ErrNovelVolumeNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "VOLUME_NOT_FOUND", "分卷不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", fmt.Sprintf("更新分卷失败: %v", err), "")
        return
    }
    
    response.BuildSuccessResponse(c, volume)
}

// DeleteVolume 删除分卷
func (h *novelVolumeHandler) DeleteVolume(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_ID", "分卷ID无效", "id")
        return
    }
    
    ctx := c.Request.Context()
    
    // 权限验证（参考NovelHandler的实现）
    // ...
    
    if err := h.volumeSvc.DeleteVolume(ctx, id); err != nil {
        if errors.Is(err, repository.ErrNovelVolumeNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "VOLUME_NOT_FOUND", "分卷不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", fmt.Sprintf("删除分卷失败: %v", err), "")
        return
    }
    
    response.BuildSuccessResponse(c, nil)
}
```

### 4. 实现NovelChapterHandler接口

在 `novel_chapter_handler.go` 文件中实现NovelChapterHandler接口：

```go
// novelChapterHandler NovelChapterHandler的实现
type novelChapterHandler struct {
    chapterSvc service.NovelChapterService
}

// NewNovelChapterHandler 创建NovelChapterHandler实例
func NewNovelChapterHandler(chapterSvc service.NovelChapterService) NovelChapterHandler {
    return &novelChapterHandler{
        chapterSvc: chapterSvc,
    }
}

// GetChapters 获取章节列表
func (h *novelChapterHandler) GetChapters(c *gin.Context) {
    novelIDStr := c.Query("novel_id")
    volumeIDStr := c.Query("volume_id")
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
    orderBy := c.DefaultQuery("order_by", "sort_order")
    orderDir := c.DefaultQuery("order_dir", "asc")
    
    if novelIDStr == "" {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_PARAM", "novel_id参数必填", "novel_id")
        return
    }
    
    novelID, err := strconv.ParseInt(novelIDStr, 10, 64)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_PARAM", "novel_id参数无效", "novel_id")
        return
    }
    
    ctx := c.Request.Context()
    
    params := &service.NovelChapterQueryParams{
        NovelID:  novelID,
        Page:     page,
        Limit:    limit,
        OrderBy:  orderBy,
        OrderDir: orderDir,
    }
    
    if volumeIDStr != "" {
        volumeID, err := strconv.ParseInt(volumeIDStr, 10, 64)
        if err == nil {
            params.VolumeID = &volumeID
        }
    }
    
    chapters, total, err := h.chapterSvc.GetChapters(ctx, params)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", "获取章节列表失败", "")
        return
    }
    
    response.BuildPaginatedResponse(c, chapters, page, limit, int(total))
}

// GetChapter 根据ID获取章节
func (h *novelChapterHandler) GetChapter(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_ID", "章节ID无效", "id")
        return
    }
    
    ctx := c.Request.Context()
    
    chapter, err := h.chapterSvc.GetChapter(ctx, id)
    if err != nil {
        if errors.Is(err, repository.ErrNovelChapterNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "CHAPTER_NOT_FOUND", "章节不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", "获取章节失败", "")
        return
    }
    
    response.BuildSuccessResponse(c, chapter)
}

// CreateChapter 创建章节
func (h *novelChapterHandler) CreateChapter(c *gin.Context) {
    var req CreateNovelChapterRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "VALIDATION_ERROR", "请求参数验证失败", "")
        return
    }
    
    ctx := c.Request.Context()
    
    // 权限验证（参考NovelHandler的实现）
    // ...
    
    chapter := &models.NovelChapter{
        NovelID:    req.NovelID,
        VolumeID:   req.VolumeID,
        Title:      req.Title,
        Content:    req.Content,
        SortOrder:  req.SortOrder,
        Status:     req.Status,
        IsVip:      req.IsVip,
    }
    
    if err := h.chapterSvc.CreateChapter(ctx, chapter); err != nil {
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", fmt.Sprintf("创建章节失败: %v", err), "")
        return
    }
    
    response.BuildSuccessResponse(c, chapter)
}

// UpdateChapter 更新章节
func (h *novelChapterHandler) UpdateChapter(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_ID", "章节ID无效", "id")
        return
    }
    
    var req UpdateNovelChapterRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "VALIDATION_ERROR", "请求参数验证失败", "")
        return
    }
    
    ctx := c.Request.Context()
    
    // 权限验证（参考NovelHandler的实现）
    // ...
    
    chapter := &models.NovelChapter{
        ID:         id,
        NovelID:    req.NovelID,
        VolumeID:   req.VolumeID,
        Title:      req.Title,
        Content:    req.Content,
        SortOrder:  req.SortOrder,
        Status:     req.Status,
        IsVip:      req.IsVip,
    }
    
    if err := h.chapterSvc.UpdateChapter(ctx, chapter); err != nil {
        if errors.Is(err, repository.ErrNovelChapterNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "CHAPTER_NOT_FOUND", "章节不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", fmt.Sprintf("更新章节失败: %v", err), "")
        return
    }
    
    response.BuildSuccessResponse(c, chapter)
}

// DeleteChapter 删除章节
func (h *novelChapterHandler) DeleteChapter(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_ID", "章节ID无效", "id")
        return
    }
    
    ctx := c.Request.Context()
    
    // 权限验证（参考NovelHandler的实现）
    // ...
    
    if err := h.chapterSvc.DeleteChapter(ctx, id); err != nil {
        if errors.Is(err, repository.ErrNovelChapterNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "CHAPTER_NOT_FOUND", "章节不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", fmt.Sprintf("删除章节失败: %v", err), "")
        return
    }
    
    response.BuildSuccessResponse(c, nil)
}

// UpdateChapterStatus 更新章节状态
func (h *novelChapterHandler) UpdateChapterStatus(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_ID", "章节ID无效", "id")
        return
    }
    
    var req UpdateNovelChapterStatusRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "VALIDATION_ERROR", "请求参数验证失败", "")
        return
    }
    
    ctx := c.Request.Context()
    
    // 权限验证（参考NovelHandler的实现）
    // ...
    
    if err := h.chapterSvc.UpdateStatus(ctx, id, req.Status); err != nil {
        if errors.Is(err, repository.ErrNovelChapterNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "CHAPTER_NOT_FOUND", "章节不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", fmt.Sprintf("更新章节状态失败: %v", err), "")
        return
    }
    
    chapter, err := h.chapterSvc.GetChapter(ctx, id)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", "获取章节失败", "")
        return
    }
    
    response.BuildSuccessResponse(c, chapter)
}
```

### 5. 定义请求结构体

在两个文件中分别定义请求结构体：

```go
// CreateNovelVolumeRequest 创建分卷请求
type CreateNovelVolumeRequest struct {
    NovelID     int64   `json:"novel_id" binding:"required"`
    VolumeName  string  `json:"volume_name" binding:"required"`
    Description *string `json:"description,omitempty"`
    SortOrder   int     `json:"sort_order"`
    Status      string  `json:"status"`
}

// UpdateNovelVolumeRequest 更新分卷请求
type UpdateNovelVolumeRequest struct {
    NovelID     int64   `json:"novel_id" binding:"required"`
    VolumeName  string  `json:"volume_name" binding:"required"`
    Description *string `json:"description,omitempty"`
    SortOrder   int     `json:"sort_order"`
    Status      string  `json:"status"`
}

// CreateNovelChapterRequest 创建章节请求
type CreateNovelChapterRequest struct {
    NovelID   int64   `json:"novel_id" binding:"required"`
    VolumeID  *int64  `json:"volume_id,omitempty"`
    Title     string  `json:"title" binding:"required"`
    Content   string  `json:"content" binding:"required"`
    SortOrder int     `json:"sort_order"`
    Status    string  `json:"status"`
    IsVip     bool    `json:"is_vip"`
}

// UpdateNovelChapterRequest 更新章节请求
type UpdateNovelChapterRequest struct {
    NovelID   int64   `json:"novel_id" binding:"required"`
    VolumeID  *int64  `json:"volume_id,omitempty"`
    Title     string  `json:"title" binding:"required"`
    Content   string  `json:"content" binding:"required"`
    SortOrder int     `json:"sort_order"`
    Status    string  `json:"status"`
    IsVip     bool    `json:"is_vip"`
}

// UpdateNovelChapterStatusRequest 更新章节状态请求
type UpdateNovelChapterStatusRequest struct {
    Status string `json:"status" binding:"required"`
}
```

### 6. 添加必要的导入

```go
package handler

import (
    "errors"
    "fmt"
    "net/http"
    "strconv"
    
    "github.com/gin-gonic/gin"
    
    "yourproject/internal/models"
    "yourproject/internal/repository"
    "yourproject/internal/response"
    "yourproject/internal/service"
)
```

### 7. 注意事项

- **API规范**：所有API必须遵循OpenAPI 3.1.1规范
- **响应格式**：所有响应必须使用Envelope格式
- **权限验证**：创建、更新、删除操作需要作者或管理员权限（参考NovelHandler的实现）
- **分页支持**：GetChapters方法支持分页，需要使用BuildPaginatedResponse
- **参数验证**：使用Gin的binding进行请求参数验证
- **错误处理**：所有错误消息必须使用中文

## 验收标准

1. **接口定义完整**
   - NovelVolumeHandler和NovelChapterHandler接口包含所有必需方法
   - 方法签名正确

2. **请求处理完整**
   - 所有CRUD操作正确实现
   - 权限验证正确
   - 参数验证正确

3. **响应格式**
   - 所有响应使用Envelope格式
   - 成功响应格式正确
   - 错误响应格式正确

4. **错误处理**
   - 所有错误消息使用中文
   - HTTP状态码使用正确

5. **代码规范**
   - 遵循Golang编码规范
   - 遵循API设计规范

## 相关文件

- `docs/TASKS/TASK007/TASK007-42.md` - NovelVolumeService实现文档
- `docs/TASKS/TASK007/TASK007-43.md` - NovelChapterService实现文档
- `docs/TASKS/TASK007/TASK007-58.md` - NovelHandler实现参考
- `.cursor/rules/api-design.mdc` - API设计规范
- `internal/handler/novel_volume_handler.go` - NovelVolumeHandler文件（待创建）
- `internal/handler/novel_chapter_handler.go` - NovelChapterHandler文件（待创建）

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.0  
**最后更新**: 2026-01-04 00:01:47 CST

