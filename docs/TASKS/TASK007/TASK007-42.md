# TASK007-42: 创建NovelVolumeService接口和实现

## 任务信息

**任务编号**: TASK007-42  
**父任务**: TASK007  
**任务名称**: 创建NovelVolumeService接口和实现  
**版本信息**: v1.2.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 23:43:24 CST

## 任务描述

创建小说分卷服务，提供小说分卷管理的业务逻辑。包括：1) 定义NovelVolumeService接口（GetVolume、GetVolumes、CreateVolume、UpdateVolume、DeleteVolume、UpdateStatus等方法）；2) 实现分卷查询（单个分卷、分卷列表）；3) 实现分卷创建、更新、删除；4) 实现业务验证逻辑。所有代码必须遵循Golang编码规范，错误消息使用中文。

## 依赖任务

TASK007-23（实现NovelVolumeRepository接口和实现）、TASK007-40（创建NovelService接口和实现 - 基础CRUD）

## 实现指南

### 1. 创建NovelVolumeService接口文件

在 `internal/service/` 目录下创建 `novel_volume_service.go` 文件，定义NovelVolumeService接口：

```go
package service

import (
    "context"
    "yourproject/internal/models"
)

// NovelVolumeService 小说分卷服务接口
// 提供小说分卷管理的业务逻辑
type NovelVolumeService interface {
    // GetVolume 根据ID获取分卷
    GetVolume(ctx context.Context, id int64) (*models.NovelVolume, error)
    
    // GetVolumes 根据小说ID获取分卷列表
    GetVolumes(ctx context.Context, novelID int64) ([]*models.NovelVolume, error)
    
    // CreateVolume 创建分卷
    CreateVolume(ctx context.Context, volume *models.NovelVolume) error
    
    // UpdateVolume 更新分卷
    UpdateVolume(ctx context.Context, volume *models.NovelVolume) error
    
    // DeleteVolume 删除分卷
    DeleteVolume(ctx context.Context, id int64) error
    
    // UpdateStatus 更新分卷状态
    UpdateStatus(ctx context.Context, id int64, status string) error
}
```

### 2. 实现NovelVolumeService接口

在同一个文件中实现NovelVolumeService接口：

```go
// novelVolumeService NovelVolumeService的实现
type novelVolumeService struct {
    volumeRepo repository.NovelVolumeRepository
    novelRepo  repository.NovelRepository
}

// NewNovelVolumeService 创建NovelVolumeService实例
func NewNovelVolumeService(
    volumeRepo repository.NovelVolumeRepository,
    novelRepo repository.NovelRepository,
) NovelVolumeService {
    return &novelVolumeService{
        volumeRepo: volumeRepo,
        novelRepo:  novelRepo,
    }
}

// GetVolume 根据ID获取分卷
func (s *novelVolumeService) GetVolume(ctx context.Context, id int64) (*models.NovelVolume, error) {
    if id <= 0 {
        return nil, errors.New("分卷ID无效")
    }
    
    volume, err := s.volumeRepo.GetByID(ctx, id)
    if err != nil {
        return nil, fmt.Errorf("获取分卷失败: %w", err)
    }
    
    return volume, nil
}

// GetVolumes 根据小说ID获取分卷列表
func (s *novelVolumeService) GetVolumes(ctx context.Context, novelID int64) ([]*models.NovelVolume, error) {
    if novelID <= 0 {
        return nil, errors.New("小说ID无效")
    }
    
    // 验证小说是否存在
    _, err := s.novelRepo.GetByID(ctx, novelID)
    if err != nil {
        return nil, errors.New("小说不存在")
    }
    
    volumes, err := s.volumeRepo.GetByNovelID(ctx, novelID)
    if err != nil {
        return nil, fmt.Errorf("获取分卷列表失败: %w", err)
    }
    
    return volumes, nil
}

// CreateVolume 创建分卷
func (s *novelVolumeService) CreateVolume(ctx context.Context, volume *models.NovelVolume) error {
    // 业务验证
    if err := s.validateVolume(volume); err != nil {
        return err
    }
    
    // 验证小说是否存在
    _, err := s.novelRepo.GetByID(ctx, volume.NovelID)
    if err != nil {
        return errors.New("小说不存在")
    }
    
    // 设置默认值
    if volume.Status == "" {
        volume.Status = "draft"
    }
    if volume.SortOrder == 0 {
        // 获取当前最大排序值
        volumes, err := s.volumeRepo.GetByNovelID(ctx, volume.NovelID)
        if err == nil && len(volumes) > 0 {
            maxOrder := 0
            for _, v := range volumes {
                if v.SortOrder > maxOrder {
                    maxOrder = v.SortOrder
                }
            }
            volume.SortOrder = maxOrder + 1
        } else {
            volume.SortOrder = 1
        }
    }
    
    // 创建分卷
    if err := s.volumeRepo.Create(ctx, volume); err != nil {
        return fmt.Errorf("创建分卷失败: %w", err)
    }
    
    return nil
}

// UpdateVolume 更新分卷
func (s *novelVolumeService) UpdateVolume(ctx context.Context, volume *models.NovelVolume) error {
    // 业务验证
    if err := s.validateVolume(volume); err != nil {
        return err
    }
    
    // 检查分卷是否存在
    existing, err := s.volumeRepo.GetByID(ctx, volume.ID)
    if err != nil {
        return errors.New("分卷不存在")
    }
    
    // 验证小说ID是否改变（不允许改变）
    if existing.NovelID != volume.NovelID {
        return errors.New("不能修改分卷所属的小说")
    }
    
    // 更新分卷
    if err := s.volumeRepo.Update(ctx, volume); err != nil {
        return fmt.Errorf("更新分卷失败: %w", err)
    }
    
    return nil
}

// DeleteVolume 删除分卷
func (s *novelVolumeService) DeleteVolume(ctx context.Context, id int64) error {
    if id <= 0 {
        return errors.New("分卷ID无效")
    }
    
    // 检查分卷是否存在
    volume, err := s.volumeRepo.GetByID(ctx, id)
    if err != nil {
        return errors.New("分卷不存在")
    }
    
    // 删除分卷
    if err := s.volumeRepo.Delete(ctx, id); err != nil {
        return fmt.Errorf("删除分卷失败: %w", err)
    }
    
    return nil
}

// UpdateStatus 更新分卷状态
func (s *novelVolumeService) UpdateStatus(ctx context.Context, id int64, status string) error {
    if id <= 0 {
        return errors.New("分卷ID无效")
    }
    
    // 验证状态
    validStatuses := []string{"draft", "reviewing", "published", "archived"}
    isValid := false
    for _, validStatus := range validStatuses {
        if status == validStatus {
            isValid = true
            break
        }
    }
    if !isValid {
        return errors.New("无效的分卷状态")
    }
    
    // 检查分卷是否存在
    _, err := s.volumeRepo.GetByID(ctx, id)
    if err != nil {
        return errors.New("分卷不存在")
    }
    
    // 更新状态
    if err := s.volumeRepo.UpdateStatus(ctx, id, status); err != nil {
        return fmt.Errorf("更新分卷状态失败: %w", err)
    }
    
    return nil
}

// validateVolume 验证分卷数据
func (s *novelVolumeService) validateVolume(volume *models.NovelVolume) error {
    if volume.NovelID <= 0 {
        return errors.New("小说ID无效")
    }
    
    if volume.VolumeName == "" {
        return errors.New("分卷名称不能为空")
    }
    if len(volume.VolumeName) > 200 {
        return errors.New("分卷名称长度不能超过200个字符")
    }
    
    // 验证状态
    if volume.Status != "" {
        validStatuses := []string{"draft", "reviewing", "published", "archived"}
        isValid := false
        for _, validStatus := range validStatuses {
            if volume.Status == validStatus {
                isValid = true
                break
            }
        }
        if !isValid {
            return errors.New("无效的分卷状态")
        }
    }
    
    return nil
}
```

### 3. 添加必要的导入

```go
package service

import (
    "context"
    "errors"
    "fmt"
    
    "yourproject/internal/models"
    "yourproject/internal/repository"
)
```

### 4. 注意事项

- **业务验证**：在Service层进行业务逻辑验证，包括数据有效性、业务规则等
- **错误处理**：所有错误消息必须使用中文
- **上下文传递**：所有方法都接受context.Context参数
- **关联验证**：创建和更新时验证小说的存在性
- **排序处理**：创建时自动设置排序值
- **状态验证**：更新状态前验证状态值是否有效

## 验收标准

1. **接口定义完整**
   - NovelVolumeService接口包含所有必需方法
   - 方法签名正确，参数和返回值类型正确

2. **实现完整**
   - 所有接口方法都已实现
   - 业务逻辑正确实现

3. **业务验证**
   - 分卷数据验证正确
   - 小说关联验证正确
   - 状态验证正确

4. **查询功能**
   - GetVolumes方法能正确查询指定小说的所有分卷
   - 查询结果按sort_order排序

5. **错误处理**
   - 所有错误消息使用中文
   - 错误处理完整、清晰

6. **代码规范**
   - 遵循Golang编码规范
   - 代码注释完整（使用中文）

## 相关文件

- `docs/TASKS/TASK007/TASK007-23.md` - NovelVolumeRepository实现文档
- `docs/TASKS/TASK007/TASK007-40.md` - NovelService实现参考
- `docs/TASKS/TASK007/TASK007-05.md` - NovelVolume模型实现文档
- `.cursor/rules/coding-standards.mdc` - Golang编码规范
- `internal/service/novel_volume_service.go` - NovelVolumeService接口和实现文件（待创建）

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.0  
**最后更新**: 2026-01-03 23:43:24 CST

