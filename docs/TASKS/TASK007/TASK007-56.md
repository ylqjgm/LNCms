# TASK007-56: 创建RegionHandler接口和实现

## 任务信息

**任务编号**: TASK007-56  
**父任务**: TASK007  
**任务名称**: 创建RegionHandler接口和实现  
**版本信息**: v1.2.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 23:53:38 CST

## 任务描述

创建地区控制器，提供地区管理的HTTP API处理。包括：1) 定义RegionHandler接口；2) 实现GetRegions方法（处理GET /api/v1/regions请求，支持树形结构查询）；3) 实现GetRegion方法（处理GET /api/v1/regions/{id}请求）；4) 实现CreateRegion方法（处理POST /api/v1/regions请求，需要管理员权限）；5) 实现UpdateRegion方法（处理PUT /api/v1/regions/{id}请求，需要管理员权限）；6) 实现DeleteRegion方法（处理DELETE /api/v1/regions/{id}请求，需要管理员权限）；7) 格式化响应（Envelope格式）。所有代码必须遵循API设计规范。

## 依赖任务

TASK007-38（创建RegionService接口和实现）

## 实现指南

### 1. 创建RegionHandler接口文件

在 `internal/handler/` 目录下创建 `region_handler.go` 文件，定义RegionHandler接口：

```go
package handler

import (
    "github.com/gin-gonic/gin"
)

// RegionHandler 地区控制器接口
// 提供地区管理的HTTP API处理
type RegionHandler interface {
    // GetRegions 获取地区列表（支持树形结构查询）
    GetRegions(c *gin.Context)
    
    // GetRegion 根据ID获取地区
    GetRegion(c *gin.Context)
    
    // CreateRegion 创建地区（需要管理员权限）
    CreateRegion(c *gin.Context)
    
    // UpdateRegion 更新地区（需要管理员权限）
    UpdateRegion(c *gin.Context)
    
    // DeleteRegion 删除地区（需要管理员权限）
    DeleteRegion(c *gin.Context)
}
```

### 2. 定义请求和响应结构体

```go
// CreateRegionRequest 创建地区请求
type CreateRegionRequest struct {
    RegionName        string  `json:"region_name" binding:"required"`
    RegionDescription *string `json:"region_description,omitempty"`
    ParentID          *int64  `json:"parent_id,omitempty"`
    RegionOrder       int     `json:"region_order"`
    IsActive          bool    `json:"is_active"`
}

// UpdateRegionRequest 更新地区请求
type UpdateRegionRequest struct {
    RegionName        string  `json:"region_name" binding:"required"`
    RegionDescription *string `json:"region_description,omitempty"`
    ParentID          *int64  `json:"parent_id,omitempty"`
    RegionOrder       int     `json:"region_order"`
    IsActive          bool    `json:"is_active"`
}
```

### 3. 实现RegionHandler接口

在同一个文件中实现RegionHandler接口：

```go
// regionHandler RegionHandler的实现
type regionHandler struct {
    regionSvc service.RegionService
}

// NewRegionHandler 创建RegionHandler实例
func NewRegionHandler(regionSvc service.RegionService) RegionHandler {
    return &regionHandler{
        regionSvc: regionSvc,
    }
}

// GetRegions 获取地区列表
func (h *regionHandler) GetRegions(c *gin.Context) {
    // 获取查询参数
    tree := c.Query("tree") == "true"
    
    ctx := c.Request.Context()
    
    var regions interface{}
    var err error
    
    if tree {
        // 获取树形结构
        regions, err = h.regionSvc.GetRegionTree(ctx)
    } else {
        // 获取列表
        regions, err = h.regionSvc.GetRegions(ctx)
    }
    
    if err != nil {
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", "获取地区列表失败", "")
        return
    }
    
    response.BuildSuccessResponse(c, regions)
}

// GetRegion 根据ID获取地区
func (h *regionHandler) GetRegion(c *gin.Context) {
    // 获取路径参数
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_ID", "地区ID无效", "id")
        return
    }
    
    ctx := c.Request.Context()
    
    region, err := h.regionSvc.GetRegion(ctx, id)
    if err != nil {
        if errors.Is(err, repository.ErrRegionNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "REGION_NOT_FOUND", "地区不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", "获取地区失败", "")
        return
    }
    
    response.BuildSuccessResponse(c, region)
}

// CreateRegion 创建地区
func (h *regionHandler) CreateRegion(c *gin.Context) {
    var req CreateRegionRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "VALIDATION_ERROR", "请求参数验证失败", "")
        return
    }
    
    ctx := c.Request.Context()
    
    // 构建地区模型
    region := &models.Region{
        RegionName:        req.RegionName,
        RegionDescription: req.RegionDescription,
        ParentID:          req.ParentID,
        RegionOrder:       req.RegionOrder,
        IsActive:          req.IsActive,
    }
    
    if err := h.regionSvc.CreateRegion(ctx, region); err != nil {
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", fmt.Sprintf("创建地区失败: %v", err), "")
        return
    }
    
    response.BuildSuccessResponse(c, region)
}

// UpdateRegion 更新地区
func (h *regionHandler) UpdateRegion(c *gin.Context) {
    // 获取路径参数
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_ID", "地区ID无效", "id")
        return
    }
    
    var req UpdateRegionRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "VALIDATION_ERROR", "请求参数验证失败", "")
        return
    }
    
    ctx := c.Request.Context()
    
    // 构建地区模型
    region := &models.Region{
        ID:                id,
        RegionName:        req.RegionName,
        RegionDescription: req.RegionDescription,
        ParentID:          req.ParentID,
        RegionOrder:       req.RegionOrder,
        IsActive:          req.IsActive,
    }
    
    if err := h.regionSvc.UpdateRegion(ctx, region); err != nil {
        if errors.Is(err, repository.ErrRegionNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "REGION_NOT_FOUND", "地区不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", fmt.Sprintf("更新地区失败: %v", err), "")
        return
    }
    
    response.BuildSuccessResponse(c, region)
}

// DeleteRegion 删除地区
func (h *regionHandler) DeleteRegion(c *gin.Context) {
    // 获取路径参数
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.BuildErrorResponse(c, http.StatusBadRequest, "INVALID_ID", "地区ID无效", "id")
        return
    }
    
    ctx := c.Request.Context()
    
    if err := h.regionSvc.DeleteRegion(ctx, id); err != nil {
        if errors.Is(err, repository.ErrRegionNotFound) {
            response.BuildErrorResponse(c, http.StatusNotFound, "REGION_NOT_FOUND", "地区不存在", "")
            return
        }
        response.BuildErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", fmt.Sprintf("删除地区失败: %v", err), "")
        return
    }
    
    response.BuildSuccessResponse(c, nil)
}
```

### 4. 添加必要的导入

```go
package handler

import (
    "errors"
    "fmt"
    "net/http"
    "strconv"
    
    "github.com/gin-gonic/gin"
    
    "yourproject/internal/models"
    "yourproject/internal/repository"
    "yourproject/internal/response"
    "yourproject/internal/service"
)
```

### 5. 注意事项

- **API规范**：所有API必须遵循OpenAPI 3.1.1规范
- **响应格式**：所有响应必须使用Envelope格式
- **错误处理**：所有错误消息必须使用中文
- **权限验证**：创建、更新、删除操作需要管理员权限（通过中间件实现）
- **参数验证**：使用Gin的binding进行请求参数验证
- **路径参数**：使用c.Param获取路径参数
- **查询参数**：使用c.Query获取查询参数

## 验收标准

1. **接口定义完整**
   - RegionHandler接口包含所有必需方法
   - 方法签名正确

2. **请求处理完整**
   - GetRegions方法支持树形结构查询
   - GetRegion方法正确获取地区详情
   - CreateRegion方法正确创建地区
   - UpdateRegion方法正确更新地区
   - DeleteRegion方法正确删除地区

3. **响应格式**
   - 所有响应使用Envelope格式
   - 成功响应格式正确
   - 错误响应格式正确

4. **错误处理**
   - 所有错误消息使用中文
   - HTTP状态码使用正确
   - 错误代码定义清晰

5. **参数验证**
   - 请求参数验证正确
   - 路径参数验证正确
   - 查询参数处理正确

6. **代码规范**
   - 遵循Golang编码规范
   - 遵循API设计规范
   - 代码注释完整（使用中文）

## 相关文件

- `docs/TASKS/TASK007/TASK007-38.md` - RegionService实现文档
- `docs/TASKS/TASK007/TASK007-02.md` - Region模型实现文档
- `docs/TASKS/TASK007/TASK007-55.md` - CategoryHandler实现参考
- `.cursor/rules/api-design.mdc` - API设计规范
- `.cursor/rules/coding-standards.mdc` - Golang编码规范
- `internal/handler/region_handler.go` - RegionHandler接口和实现文件（待创建）

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.0  
**最后更新**: 2026-01-03 23:53:38 CST

