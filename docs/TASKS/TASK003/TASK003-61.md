# TASK003-61: 编写获取模块列表API测试

## 任务信息

**任务编号**: TASK003-61  
**父任务**: TASK003  
**任务名称**: 编写获取模块列表API测试  
**版本信息**: v2.0.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 14:22:42 CST

## 任务描述

编写获取模块列表API测试。包括：1) 测试GET端点；2) 测试正常情况、边界情况和异常情况；3) 测试分页功能；4) 确保所有测试用例通过。所有测试用例描述和错误消息必须使用中文。

## 依赖任务

- TASK003-60: 实现获取模块列表API（GET）

## 实现指南

### 1. 创建测试文件

在 `internal/api/v1/handler/module_handler_test.go` 文件中创建测试：

```go
package handler

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
    
    "github.com/gin-gonic/gin"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
    "github.com/stretchr/testify/require"
    "yourproject/internal/api/v1/dto"
    "yourproject/internal/pkg/model"
    "yourproject/internal/pkg/service"
)
```

### 2. 创建Mock ModuleService

使用testify/mock创建Mock ModuleService：

```go
// MockModuleService Mock模块服务
type MockModuleService struct {
    mock.Mock
}

func (m *MockModuleService) ListModules(ctx context.Context, limit, offset int) ([]*model.Module, int64, error) {
    args := m.Called(ctx, limit, offset)
    if args.Get(0) == nil {
        return nil, int64(0), args.Error(2)
    }
    return args.Get(0).([]*model.Module), args.Get(1).(int64), args.Error(2)
}

// 其他方法...
```

### 3. 测试正常情况

编写正常情况的测试用例：

```go
func TestModuleHandler_GetModuleList(t *testing.T) {
    gin.SetMode(gin.TestMode)
    
    tests := []struct {
        name           string
        queryParams    string
        setupMock      func(*MockModuleService)
        wantStatusCode int
        wantErr        bool
        errContains    string
    }{
        {
            name:        "成功获取模块列表",
            queryParams: "?page=1&limit=20",
            setupMock: func(m *MockModuleService) {
                modules := []*model.Module{
                    {
                        ID:           1,
                        ModuleID:      "test-module-1",
                        ModuleName:    "测试模块1",
                        ModuleType:    "crawler",
                        ModuleStatus:  string(model.ModuleStatusActive),
                    },
                    {
                        ID:           2,
                        ModuleID:      "test-module-2",
                        ModuleName:    "测试模块2",
                        ModuleType:    "storage",
                        ModuleStatus:  string(model.ModuleStatusInactive),
                    },
                }
                m.On("ListModules", mock.Anything, 20, 0).Return(modules, int64(2), nil)
            },
            wantStatusCode: http.StatusOK,
            wantErr:        false,
        },
        {
            name:        "空列表",
            queryParams: "?page=1&limit=20",
            setupMock: func(m *MockModuleService) {
                m.On("ListModules", mock.Anything, 20, 0).Return([]*model.Module{}, int64(0), nil)
            },
            wantStatusCode: http.StatusOK,
            wantErr:        false,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            mockService := new(MockModuleService)
            tt.setupMock(mockService)
            
            handler := NewModuleHandler(mockService)
            
            router := gin.New()
            router.GET("/api/v1/modules", handler.GetModuleList)
            
            req, _ := http.NewRequest("GET", "/api/v1/modules"+tt.queryParams, nil)
            w := httptest.NewRecorder()
            
            router.ServeHTTP(w, req)
            
            assert.Equal(t, tt.wantStatusCode, w.Code)
            
            if !tt.wantErr {
                var envelope response.Envelope
                err := json.Unmarshal(w.Body.Bytes(), &envelope)
                require.NoError(t, err)
                assert.True(t, envelope.Meta.Success)
                
                var listResp dto.ModuleListResponse
                dataBytes, _ := json.Marshal(envelope.Data)
                json.Unmarshal(dataBytes, &listResp)
                
                assert.NotNil(t, listResp.Items)
            }
            
            mockService.AssertExpectations(t)
        })
    }
}
```

### 4. 测试分页功能

编写分页功能的测试用例：

```go
func TestModuleHandler_GetModuleList_Pagination(t *testing.T) {
    gin.SetMode(gin.TestMode)
    
    tests := []struct {
        name        string
        queryParams string
        setupMock   func(*MockModuleService)
        wantPage    int
        wantLimit   int
        wantTotal   int64
    }{
        {
            name:        "第一页",
            queryParams: "?page=1&limit=10",
            setupMock: func(m *MockModuleService) {
                modules := make([]*model.Module, 10)
                for i := 0; i < 10; i++ {
                    modules[i] = &model.Module{ID: int64(i + 1)}
                }
                m.On("ListModules", mock.Anything, 10, 0).Return(modules, int64(25), nil)
            },
            wantPage:  1,
            wantLimit: 10,
            wantTotal: 25,
        },
        {
            name:        "第二页",
            queryParams: "?page=2&limit=10",
            setupMock: func(m *MockModuleService) {
                modules := make([]*model.Module, 10)
                for i := 0; i < 10; i++ {
                    modules[i] = &model.Module{ID: int64(i + 11)}
                }
                m.On("ListModules", mock.Anything, 10, 10).Return(modules, int64(25), nil)
            },
            wantPage:  2,
            wantLimit: 10,
            wantTotal: 25,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            mockService := new(MockModuleService)
            tt.setupMock(mockService)
            
            handler := NewModuleHandler(mockService)
            
            router := gin.New()
            router.GET("/api/v1/modules", handler.GetModuleList)
            
            req, _ := http.NewRequest("GET", "/api/v1/modules"+tt.queryParams, nil)
            w := httptest.NewRecorder()
            
            router.ServeHTTP(w, req)
            
            assert.Equal(t, http.StatusOK, w.Code)
            
            var envelope response.Envelope
            err := json.Unmarshal(w.Body.Bytes(), &envelope)
            require.NoError(t, err)
            
            assert.NotNil(t, envelope.Meta.Pagination)
            assert.Equal(t, tt.wantPage, envelope.Meta.Pagination.Page)
            assert.Equal(t, tt.wantLimit, envelope.Meta.Pagination.Limit)
            assert.Equal(t, tt.wantTotal, int64(envelope.Meta.Pagination.Total))
            
            mockService.AssertExpectations(t)
        })
    }
}
```

### 5. 测试边界情况

编写边界情况的测试用例：

```go
func TestModuleHandler_GetModuleList_EdgeCases(t *testing.T) {
    gin.SetMode(gin.TestMode)
    
    tests := []struct {
        name        string
        queryParams string
        setupMock   func(*MockModuleService)
        wantLimit   int
        wantOffset  int
    }{
        {
            name:        "默认分页参数",
            queryParams: "",
            setupMock: func(m *MockModuleService) {
                m.On("ListModules", mock.Anything, 20, 0).Return([]*model.Module{}, int64(0), nil)
            },
            wantLimit:  20,
            wantOffset: 0,
        },
        {
            name:        "页码小于1",
            queryParams: "?page=0&limit=20",
            setupMock: func(m *MockModuleService) {
                m.On("ListModules", mock.Anything, 20, 0).Return([]*model.Module{}, int64(0), nil)
            },
            wantLimit:  20,
            wantOffset: 0,
        },
        {
            name:        "每页数量超过最大值",
            queryParams: "?page=1&limit=200",
            setupMock: func(m *MockModuleService) {
                m.On("ListModules", mock.Anything, 100, 0).Return([]*model.Module{}, int64(0), nil)
            },
            wantLimit:  100,
            wantOffset: 0,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            mockService := new(MockModuleService)
            tt.setupMock(mockService)
            
            handler := NewModuleHandler(mockService)
            
            router := gin.New()
            router.GET("/api/v1/modules", handler.GetModuleList)
            
            req, _ := http.NewRequest("GET", "/api/v1/modules"+tt.queryParams, nil)
            w := httptest.NewRecorder()
            
            router.ServeHTTP(w, req)
            
            assert.Equal(t, http.StatusOK, w.Code)
            mockService.AssertExpectations(t)
        })
    }
}
```

### 6. 测试异常情况

编写异常情况的测试用例：

```go
func TestModuleHandler_GetModuleList_ErrorCases(t *testing.T) {
    gin.SetMode(gin.TestMode)
    
    tests := []struct {
        name           string
        queryParams    string
        setupMock      func(*MockModuleService)
        wantStatusCode int
        errContains    string
    }{
        {
            name:        "服务层错误",
            queryParams: "?page=1&limit=20",
            setupMock: func(m *MockModuleService) {
                m.On("ListModules", mock.Anything, 20, 0).Return(nil, int64(0), errors.New("数据库连接失败"))
            },
            wantStatusCode: http.StatusInternalServerError,
            errContains:    "获取模块列表失败",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            mockService := new(MockModuleService)
            tt.setupMock(mockService)
            
            handler := NewModuleHandler(mockService)
            
            router := gin.New()
            router.GET("/api/v1/modules", handler.GetModuleList)
            
            req, _ := http.NewRequest("GET", "/api/v1/modules"+tt.queryParams, nil)
            w := httptest.NewRecorder()
            
            router.ServeHTTP(w, req)
            
            assert.Equal(t, tt.wantStatusCode, w.Code)
            
            var envelope response.Envelope
            err := json.Unmarshal(w.Body.Bytes(), &envelope)
            require.NoError(t, err)
            assert.False(t, envelope.Meta.Success)
            
            if tt.errContains != "" {
                assert.Contains(t, envelope.Meta.Message, tt.errContains)
            }
            
            mockService.AssertExpectations(t)
        })
    }
}
```

## 验收标准

1. **测试覆盖完整**
   - 测试正常情况、边界情况和异常情况
   - 测试分页功能
   - 测试参数验证

2. **测试用例质量**
   - 使用表驱动测试
   - 测试用例名称清晰（使用中文）
   - 测试独立，不依赖执行顺序

3. **Mock使用正确**
   - 正确使用Mock ModuleService
   - Mock期望设置正确
   - 验证Mock调用

4. **代码规范符合要求**
   - 代码通过golangci-lint检查，无错误和警告
   - 测试用例描述和错误消息使用中文
   - 遵循Golang单元测试规范

## 相关文件

- `internal/api/v1/handler/module_handler_test.go` - 模块处理器API测试
- `internal/api/v1/handler/module_handler.go` - 模块处理器实现
- `docs/Requirements/Core.md` - 核心模块需求文档
- `.cursor/rules/api.mdc` - API设计规范
- `.cursor/rules/testing.mdc` - 单元测试规范

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 2.0.0  
**最后更新**: 2026-01-03 14:22:42 CST

