# TASK003-57: 实现定时健康检查任务

## 任务信息

**任务编号**: TASK003-57  
**父任务**: TASK003  
**任务名称**: 实现定时健康检查任务  
**版本信息**: v2.0.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 14:22:42 CST

## 任务描述

实现定时健康检查任务（使用goroutine）。包括：1) 实现定时任务调度逻辑；2) 实现健康检查任务执行；3) 实现任务生命周期管理。所有代码必须遵循Golang编码规范，错误消息使用中文。

## 依赖任务

- TASK003-56: 实现gRPC健康检查机制

## 实现指南

### 1. 定义健康检查任务接口

在 `internal/pkg/service/health_check_task.go` 文件中定义健康检查任务接口：

```go
package service

import (
    "context"
)

// HealthCheckTask 健康检查任务接口
type HealthCheckTask interface {
    // Start 启动健康检查任务
    Start(ctx context.Context) error
    
    // Stop 停止健康检查任务
    Stop() error
    
    // IsRunning 检查任务是否正在运行
    IsRunning() bool
}
```

### 2. 实现定时健康检查任务

在 `internal/pkg/service/health_check_task.go` 文件中实现定时健康检查任务：

```go
package service

import (
    "context"
    "fmt"
    "sync"
    "time"
    
    "yourproject/internal/pkg/repository"
)

// healthCheckTask 定时健康检查任务实现
type healthCheckTask struct {
    moduleService ModuleService
    repo          repository.ModuleRepository
    interval      time.Duration
    running       bool
    mu            sync.RWMutex
    stopCh        chan struct{}
    wg            sync.WaitGroup
}

// NewHealthCheckTask 创建定时健康检查任务
func NewHealthCheckTask(moduleService ModuleService, repo repository.ModuleRepository, interval time.Duration) HealthCheckTask {
    return &healthCheckTask{
        moduleService: moduleService,
        repo:          repo,
        interval:      interval,
        stopCh:        make(chan struct{}),
    }
}

// Start 启动健康检查任务
func (t *healthCheckTask) Start(ctx context.Context) error {
    t.mu.Lock()
    defer t.mu.Unlock()
    
    if t.running {
        return fmt.Errorf("健康检查任务已在运行")
    }
    
    t.running = true
    t.wg.Add(1)
    
    go t.run(ctx)
    
    return nil
}

// Stop 停止健康检查任务
func (t *healthCheckTask) Stop() error {
    t.mu.Lock()
    defer t.mu.Unlock()
    
    if !t.running {
        return fmt.Errorf("健康检查任务未运行")
    }
    
    t.running = false
    close(t.stopCh)
    t.wg.Wait()
    
    // 重新创建stopCh，以便下次启动
    t.stopCh = make(chan struct{})
    
    return nil
}

// IsRunning 检查任务是否正在运行
func (t *healthCheckTask) IsRunning() bool {
    t.mu.RLock()
    defer t.mu.RUnlock()
    return t.running
}

// run 执行健康检查任务
func (t *healthCheckTask) run(ctx context.Context) {
    defer t.wg.Done()
    
    ticker := time.NewTicker(t.interval)
    defer ticker.Stop()
    
    // 立即执行一次健康检查
    t.checkAllModules(ctx)
    
    for {
        select {
        case <-ticker.C:
            t.checkAllModules(ctx)
        case <-t.stopCh:
            return
        case <-ctx.Done():
            return
        }
    }
}

// checkAllModules 检查所有模块的健康状态
func (t *healthCheckTask) checkAllModules(ctx context.Context) {
    // 获取所有模块
    modules, _, err := t.repo.List(ctx, 1000, 0) // 假设最多1000个模块
    if err != nil {
        // 记录错误，但不中断任务
        return
    }
    
    // 并发检查所有模块的健康状态
    for _, module := range modules {
        // 只检查已启用且有健康检查URL的模块
        if module.ModuleStatus == string(model.ModuleStatusActive) && module.HealthCheckURL != "" {
            go func(m *model.Module) {
                if err := t.moduleService.UpdateModuleHealthStatus(ctx, m.ModuleID); err != nil {
                    // 记录错误，但不中断任务
                }
            }(module)
        }
    }
}
```

### 3. 在服务启动时启动健康检查任务

在 `internal/cmd/server/main.go` 或相应的启动文件中启动健康检查任务：

```go
// 创建健康检查任务
healthCheckTask := service.NewHealthCheckTask(
    moduleService,
    moduleRepo,
    30*time.Second, // 每30秒检查一次
)

// 启动健康检查任务
if err := healthCheckTask.Start(context.Background()); err != nil {
    log.Fatalf("启动健康检查任务失败: %v", err)
}

// 在服务关闭时停止健康检查任务
defer func() {
    if err := healthCheckTask.Stop(); err != nil {
        log.Printf("停止健康检查任务失败: %v", err)
    }
}()
```

### 4. 实现优雅关闭

在服务关闭时实现优雅关闭：

```go
// 创建信号通道
sigCh := make(chan os.Signal, 1)
signal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)

// 等待信号
<-sigCh

// 停止健康检查任务
if err := healthCheckTask.Stop(); err != nil {
    log.Printf("停止健康检查任务失败: %v", err)
}

// 其他清理工作...
```

## 验收标准

1. **定时任务正确实现**
   - 任务可以正确启动和停止
   - 任务按照指定间隔执行
   - 任务生命周期管理正确

2. **健康检查执行正确**
   - 正确获取所有模块
   - 正确检查模块健康状态
   - 正确更新模块状态

3. **并发处理正确**
   - 使用goroutine并发检查模块
   - 正确处理并发安全
   - 使用sync包保护共享状态

4. **错误处理正确**
   - 所有错误消息使用中文
   - 错误不影响任务继续执行
   - 正确处理任务启动和停止错误

5. **代码规范符合要求**
   - 代码通过golangci-lint检查，无错误和警告
   - 代码注释完整，使用中文
   - 遵循Golang编码规范

## 相关文件

- `internal/pkg/service/health_check_task.go` - 定时健康检查任务实现
- `internal/pkg/service/module_service.go` - ModuleService接口和实现
- `internal/cmd/server/main.go` - 服务启动文件
- `docs/Requirements/Core.md` - 核心模块需求文档
- `.cursor/rules/golang.mdc` - Golang编码规范

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 2.0.0  
**最后更新**: 2026-01-03 14:22:42 CST

