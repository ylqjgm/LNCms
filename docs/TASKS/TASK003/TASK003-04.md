# TASK003-04: 编写系统配置仓储层单元测试

## 任务信息

**任务编号**: TASK003-04  
**父任务**: TASK003  
**任务名称**: 编写系统配置仓储层单元测试  
**版本信息**: v2.0.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 13:31:24 CST

## 任务描述

编写系统配置仓储层单元测试。包括：1) 测试ConfigRepository的所有方法；2) 测试正常情况、边界情况和异常情况；3) 使用Mock数据库进行测试；4) 确保测试覆盖率达标。所有测试用例描述和错误消息必须使用中文。

## 依赖任务

- TASK003-02: 实现ConfigRepository接口

## 实现指南

### 1. 创建测试文件

在 `internal/pkg/repository/config_repository_test.go` 文件中创建测试：

```go
package repository

import (
    "context"
    "testing"
    "time"
    
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
    "gorm.io/datatypes"
    "yourproject/internal/pkg/model"
)
```

### 2. 设置测试数据库

创建测试辅助函数，设置测试数据库：

```go
// setupTestDB 设置测试数据库
func setupTestDB(t *testing.T) *gorm.DB {
    t.Helper()
    db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
    require.NoError(t, err, "设置测试数据库失败")
    
    // 自动迁移
    err = db.AutoMigrate(&model.SystemConfig{})
    require.NoError(t, err, "数据库迁移失败")
    
    return db
}

// teardownTestDB 清理测试数据库
func teardownTestDB(t *testing.T, db *gorm.DB) {
    t.Helper()
    sqlDB, err := db.DB()
    if err != nil {
        return
    }
    sqlDB.Close()
}
```

### 3. 测试GetByType方法

编写GetByType方法的测试用例：

```go
func TestConfigRepository_GetByType(t *testing.T) {
    db := setupTestDB(t)
    defer teardownTestDB(t, db)
    
    repo := NewConfigRepository(db)
    ctx := context.Background()
    
    // 准备测试数据
    testConfig := &model.SystemConfig{
        ConfigType: "site",
        ConfigData: datatypes.JSON(`{"site_name": "测试网站"}`),
        CreatedAt:  time.Now(),
        UpdatedAt:  time.Now(),
    }
    err := db.Create(testConfig).Error
    require.NoError(t, err, "创建测试数据失败")
    
    tests := []struct {
        name      string
        configType string
        wantErr   bool
        errMsg    string
    }{
        {
            name:      "正常获取配置",
            configType: "site",
            wantErr:   false,
        },
        {
            name:      "配置不存在",
            configType: "not_exist",
            wantErr:   true,
            errMsg:    "配置类型 not_exist 不存在",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            config, err := repo.GetByType(ctx, tt.configType)
            if tt.wantErr {
                assert.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
                assert.Nil(t, config)
            } else {
                assert.NoError(t, err)
                assert.NotNil(t, config)
                assert.Equal(t, tt.configType, config.ConfigType)
            }
        })
    }
}
```

### 4. 测试Create方法

编写Create方法的测试用例：

```go
func TestConfigRepository_Create(t *testing.T) {
    db := setupTestDB(t)
    defer teardownTestDB(t, db)
    
    repo := NewConfigRepository(db)
    ctx := context.Background()
    
    tests := []struct {
        name    string
        config  *model.SystemConfig
        wantErr bool
        errMsg  string
    }{
        {
            name: "正常创建配置",
            config: &model.SystemConfig{
                ConfigType: "site",
                ConfigData: datatypes.JSON(`{"site_name": "测试网站"}`),
            },
            wantErr: false,
        },
        {
            name:    "配置为空",
            config:  nil,
            wantErr: true,
            errMsg:  "配置不能为空",
        },
        {
            name: "配置类型重复",
            config: &model.SystemConfig{
                ConfigType: "site",
                ConfigData: datatypes.JSON(`{"site_name": "另一个网站"}`),
            },
            wantErr: true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 如果是重复配置类型测试，先创建一个配置
            if tt.name == "配置类型重复" {
                firstConfig := &model.SystemConfig{
                    ConfigType: "site",
                    ConfigData: datatypes.JSON(`{"site_name": "第一个网站"}`),
                }
                err := repo.Create(ctx, firstConfig)
                require.NoError(t, err)
            }
            
            err := repo.Create(ctx, tt.config)
            if tt.wantErr {
                assert.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
            } else {
                assert.NoError(t, err)
                
                // 验证数据已创建
                var count int64
                db.Model(&model.SystemConfig{}).
                    Where("config_type = ?", tt.config.ConfigType).
                    Count(&count)
                assert.Equal(t, int64(1), count)
            }
        })
    }
}
```

### 5. 测试Update方法

编写Update方法的测试用例：

```go
func TestConfigRepository_Update(t *testing.T) {
    db := setupTestDB(t)
    defer teardownTestDB(t, db)
    
    repo := NewConfigRepository(db)
    ctx := context.Background()
    
    // 准备测试数据
    testConfig := &model.SystemConfig{
        ConfigType: "site",
        ConfigData: datatypes.JSON(`{"site_name": "原始网站"}`),
        CreatedAt:  time.Now(),
        UpdatedAt:  time.Now(),
    }
    err := db.Create(testConfig).Error
    require.NoError(t, err)
    
    tests := []struct {
        name    string
        config  *model.SystemConfig
        wantErr bool
        errMsg  string
    }{
        {
            name: "正常更新配置",
            config: &model.SystemConfig{
                ConfigType: "site",
                ConfigData: datatypes.JSON(`{"site_name": "更新后的网站"}`),
            },
            wantErr: false,
        },
        {
            name:    "配置为空",
            config:  nil,
            wantErr: true,
            errMsg:  "配置不能为空",
        },
        {
            name: "配置不存在",
            config: &model.SystemConfig{
                ConfigType: "not_exist",
                ConfigData: datatypes.JSON(`{"site_name": "不存在的配置"}`),
            },
            wantErr: true,
            errMsg:  "配置类型 not_exist 不存在",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := repo.Update(ctx, tt.config)
            if tt.wantErr {
                assert.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
            } else {
                assert.NoError(t, err)
                
                // 验证数据已更新
                var config model.SystemConfig
                db.Where("config_type = ?", tt.config.ConfigType).First(&config)
                assert.Equal(t, string(tt.config.ConfigData), string(config.ConfigData))
            }
        })
    }
}
```

### 6. 测试Delete方法

编写Delete方法的测试用例：

```go
func TestConfigRepository_Delete(t *testing.T) {
    db := setupTestDB(t)
    defer teardownTestDB(t, db)
    
    repo := NewConfigRepository(db)
    ctx := context.Background()
    
    // 准备测试数据
    testConfig := &model.SystemConfig{
        ConfigType: "site",
        ConfigData: datatypes.JSON(`{"site_name": "测试网站"}`),
        CreatedAt:  time.Now(),
        UpdatedAt:  time.Now(),
    }
    err := db.Create(testConfig).Error
    require.NoError(t, err)
    
    tests := []struct {
        name      string
        configType string
        wantErr   bool
        errMsg    string
    }{
        {
            name:      "正常删除配置",
            configType: "site",
            wantErr:   false,
        },
        {
            name:      "配置不存在",
            configType: "not_exist",
            wantErr:   true,
            errMsg:    "配置类型 not_exist 不存在",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := repo.Delete(ctx, tt.configType)
            if tt.wantErr {
                assert.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
            } else {
                assert.NoError(t, err)
                
                // 验证数据已删除
                var count int64
                db.Model(&model.SystemConfig{}).
                    Where("config_type = ?", tt.configType).
                    Count(&count)
                assert.Equal(t, int64(0), count)
            }
        })
    }
}
```

### 7. 运行测试并检查覆盖率

运行测试并检查覆盖率：

```bash
# 运行测试
go test ./internal/pkg/repository -v

# 生成覆盖率报告
go test ./internal/pkg/repository -coverprofile=coverage.out

# 查看覆盖率
go tool cover -func=coverage.out

# 查看HTML覆盖率报告
go tool cover -html=coverage.out
```

## 验收标准

1. **测试覆盖所有方法**
   - GetByType方法有完整的测试用例
   - Create方法有完整的测试用例
   - Update方法有完整的测试用例
   - Delete方法有完整的测试用例

2. **测试覆盖所有场景**
   - 正常情况测试通过
   - 边界情况测试通过
   - 异常情况测试通过
   - 错误消息测试正确

3. **测试覆盖率达标**
   - 代码覆盖率达到80%以上
   - 关键路径覆盖率达到100%

4. **测试代码规范**
   - 使用表驱动测试
   - 测试用例描述清晰，使用中文
   - 使用testify库进行断言
   - 测试代码遵循Golang编码规范

## 相关文件

- `internal/pkg/repository/config_repository_test.go` - 配置仓储层单元测试
- `internal/pkg/repository/config_repository.go` - 配置仓储层实现
- `docs/Requirements/Core.md` - 核心模块需求文档
- `.cursor/rules/golang.mdc` - Golang编码规范
- `.cursor/rules/testing.mdc` - 单元测试规范

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 2.0.0  
**最后更新**: 2026-01-03 13:31:24 CST
