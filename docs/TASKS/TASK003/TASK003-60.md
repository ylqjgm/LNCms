# TASK003-60: 实现获取模块列表API（GET）

## 任务信息

**任务编号**: TASK003-60  
**父任务**: TASK003  
**任务名称**: 实现获取模块列表API（GET）  
**版本信息**: v2.0.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 14:22:42 CST

## 任务描述

实现获取模块列表API接口。包括：1) 实现 GET /api/v1/modules 端点；2) 实现分页支持；3) 实现请求处理和响应构建；4) 遵循OpenAPI 3.1.1规范和Envelope响应格式。所有错误消息必须使用中文。

## 依赖任务

- TASK003-59: 编写模块健康检查单元测试

## 实现指南

### 1. 定义响应结构体

在 `internal/api/v1/dto/module_dto.go` 文件中定义模块列表响应结构体：

```go
package dto

// ModuleListItem 模块列表项
type ModuleListItem struct {
    ID              int64  `json:"id"`                // 模块ID
    ModuleID        string `json:"module_id"`         // 模块标识符
    ModuleName      string `json:"module_name"`       // 模块名称
    ModuleType      string `json:"module_type"`       // 模块类型
    ModuleURL       string `json:"module_url"`        // 模块URL
    ModuleStatus    string `json:"module_status"`     // 模块状态
    HealthCheckURL  string `json:"health_check_url"`  // 健康检查URL
    LastHealthCheck string `json:"last_health_check"` // 最后健康检查时间
    CreatedAt       string `json:"created_at"`       // 创建时间
    UpdatedAt       string `json:"updated_at"`       // 更新时间
}

// ModuleListResponse 模块列表响应
type ModuleListResponse struct {
    Items []ModuleListItem `json:"items"` // 模块列表
}
```

### 2. 实现GetModuleList方法

在 `internal/api/v1/handler/module_handler.go` 文件中实现GetModuleList方法：

```go
package handler

import (
    "net/http"
    "strconv"
    
    "github.com/gin-gonic/gin"
    "yourproject/internal/api/v1/dto"
    "yourproject/internal/pkg/service"
    "yourproject/internal/pkg/response"
)

// ModuleHandler 模块处理器
type ModuleHandler struct {
    moduleService service.ModuleService
}

// NewModuleHandler 创建模块处理器实例
func NewModuleHandler(moduleService service.ModuleService) *ModuleHandler {
    return &ModuleHandler{
        moduleService: moduleService,
    }
}

// GetModuleList 获取模块列表
// @Summary 获取模块列表
// @Description 获取系统所有模块列表，支持分页
// @Tags 模块管理
// @Accept json
// @Produce json
// @Param page query int false "页码" default(1)
// @Param limit query int false "每页数量" default(20)
// @Success 200 {object} response.Envelope{data=dto.ModuleListResponse,meta=response.Meta{pagination=response.Pagination}} "成功响应"
// @Failure 400 {object} response.Envelope "请求参数错误"
// @Failure 500 {object} response.Envelope "服务器错误"
// @Router /api/v1/modules [get]
func (h *ModuleHandler) GetModuleList(c *gin.Context) {
    ctx := c.Request.Context()
    
    // 获取分页参数
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))
    
    // 验证分页参数
    if page < 1 {
        page = 1
    }
    if limit < 1 {
        limit = 20
    }
    if limit > 100 {
        limit = 100
    }
    
    // 计算偏移量
    offset := (page - 1) * limit
    
    // 从服务层获取模块列表
    modules, total, err := h.moduleService.ListModules(ctx, limit, offset)
    if err != nil {
        response.Error(c, http.StatusInternalServerError, "MODULE_LIST_FAILED", "获取模块列表失败", err)
        return
    }
    
    // 转换为响应结构体
    items := make([]dto.ModuleListItem, 0, len(modules))
    for _, module := range modules {
        items = append(items, dto.ModuleListItem{
            ID:              module.ID,
            ModuleID:        module.ModuleID,
            ModuleName:      module.ModuleName,
            ModuleType:      module.ModuleType,
            ModuleURL:       module.ModuleURL,
            ModuleStatus:    module.ModuleStatus,
            HealthCheckURL:  module.HealthCheckURL,
            LastHealthCheck: module.LastHealthCheck.Format("2006-01-02 15:04:05"),
            CreatedAt:       module.CreatedAt.Format("2006-01-02 15:04:05"),
            UpdatedAt:       module.UpdatedAt.Format("2006-01-02 15:04:05"),
        })
    }
    
    // 构建分页响应
    response.Paginated(c, dto.ModuleListResponse{Items: items}, page, limit, int(total))
}
```

### 3. 在ModuleService中添加ListModules方法

在 `internal/pkg/service/module_service.go` 文件中添加ListModules方法：

```go
// ModuleService 模块服务接口
type ModuleService interface {
    // RegisterModule 注册模块
    RegisterModule(ctx context.Context, moduleID, moduleName, moduleType, moduleURL, healthCheckURL string, configData map[string]interface{}) (*model.Module, error)
    
    // EnableModule 启用模块
    EnableModule(ctx context.Context, moduleID string) error
    
    // DisableModule 禁用模块
    DisableModule(ctx context.Context, moduleID string) error
    
    // CheckModuleHealth 检查模块健康状态
    CheckModuleHealth(ctx context.Context, moduleID string) (grpc_health_v1.HealthCheckResponse_ServingStatus, error)
    
    // ListModules 获取模块列表
    ListModules(ctx context.Context, limit, offset int) ([]*model.Module, int64, error)
}

// ListModules 获取模块列表
func (s *moduleService) ListModules(ctx context.Context, limit, offset int) ([]*model.Module, int64, error) {
    return s.repo.List(ctx, limit, offset)
}
```

### 4. 注册路由

在 `internal/api/v1/router/router.go` 文件中注册路由：

```go
// RegisterModuleRoutes 注册模块相关路由
func RegisterModuleRoutes(r *gin.RouterGroup, moduleHandler *handler.ModuleHandler) {
    modules := r.Group("/modules")
    {
        modules.GET("", moduleHandler.GetModuleList)
    }
}
```

## 验收标准

1. **API端点正确实现**
   - GET /api/v1/modules 端点正确实现
   - 路由正确注册

2. **分页功能正确**
   - 支持page和limit查询参数
   - 分页参数验证正确
   - 分页响应包含pagination信息

3. **响应格式符合要求**
   - 响应使用Envelope格式
   - meta字段包含success、code、message、timestamp、request_id、pagination
   - data字段包含ModuleListResponse结构体
   - links字段包含分页链接

4. **错误处理正确**
   - 参数验证失败时返回适当的错误响应
   - 服务层错误时返回适当的错误响应
   - 所有错误消息使用中文

5. **代码规范符合要求**
   - 代码通过golangci-lint检查，无错误和警告
   - 代码注释完整，使用中文
   - 遵循Golang编码规范和API设计规范

## 相关文件

- `internal/api/v1/handler/module_handler.go` - 模块处理器实现
- `internal/api/v1/dto/module_dto.go` - 模块DTO定义
- `internal/api/v1/router/router.go` - 路由注册
- `internal/pkg/service/module_service.go` - ModuleService接口和实现
- `docs/Requirements/Core.md` - 核心模块需求文档
- `.cursor/rules/api.mdc` - API设计规范
- `.cursor/rules/golang.mdc` - Golang编码规范

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 2.0.0  
**最后更新**: 2026-01-03 14:22:42 CST

