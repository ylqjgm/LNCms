# TASK004-18: 编写LevelRepository单元测试

## 任务信息

**任务编号**: TASK004-18  
**父任务**: TASK004  
**任务名称**: 编写LevelRepository单元测试  
**版本信息**: v1.1.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 14:54:20 CST

## 任务描述

编写等级仓储层单元测试。包括：1) 测试LevelRepository的所有方法；2) 测试正常情况、边界情况和异常情况；3) 测试JSONB字段的存储和读取；4) 使用Mock数据库进行测试；5) 确保测试覆盖率达标。所有测试用例描述和错误消息必须使用中文。

## 依赖任务

- TASK004-17: 实现LevelRepository接口和实现

## 实现指南

### 1. 设置测试环境

在 `internal/pkg/repository/level_repository_test.go` 文件中创建测试文件：

```go
package repository

import (
    "context"
    "testing"
    
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
    "github.com/stretchr/testify/suite"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
    "yourproject/internal/pkg/model"
)

// LevelRepositoryTestSuite 等级仓储测试套件
type LevelRepositoryTestSuite struct {
    suite.Suite
    db   *gorm.DB
    repo LevelRepository
    ctx  context.Context
}

// SetupTest 每个测试前的设置
func (s *LevelRepositoryTestSuite) SetupTest() {
    // 使用SQLite内存数据库进行测试
    db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
    require.NoError(s.T(), err)
    
    // 自动迁移表结构
    err = db.AutoMigrate(&model.Level{})
    require.NoError(s.T(), err)
    
    s.db = db
    s.repo = NewLevelRepository(db)
    s.ctx = context.Background()
}

// TearDownTest 每个测试后的清理
func (s *LevelRepositoryTestSuite) TearDownTest() {
    if s.db != nil {
        sqlDB, _ := s.db.DB()
        if sqlDB != nil {
            sqlDB.Close()
        }
    }
}
```

### 2. 测试GetByID方法

测试GetByID方法的正常情况和异常情况：

```go
// TestGetByID 测试GetByID方法
func (s *LevelRepositoryTestSuite) TestGetByID() {
    // 创建测试数据
    level := &model.Level{
        Name:        "测试等级",
        Description: stringPtr("测试等级描述"),
        Conditions: model.LevelConditions{
            ConditionType:  "points",
            ConditionValue: 1000,
        },
    }
    err := s.repo.Create(s.ctx, level)
    require.NoError(s.T(), err)
    
    tests := []struct {
        name    string
        id      int64
        wantErr bool
        errMsg  string
    }{
        {
            name:    "正常情况：获取存在的等级",
            id:      level.ID,
            wantErr: false,
        },
        {
            name:    "异常情况：获取不存在的等级",
            id:      99999,
            wantErr: true,
            errMsg:  "等级不存在",
        },
    }
    
    for _, tt := range tests {
        s.T().Run(tt.name, func(t *testing.T) {
            got, err := s.repo.GetByID(s.ctx, tt.id)
            if tt.wantErr {
                assert.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
                assert.Nil(t, got)
            } else {
                assert.NoError(t, err)
                assert.NotNil(t, got)
                assert.Equal(t, tt.id, got.ID)
            }
        })
    }
}
```

### 3. 测试GetAll方法

测试GetAll方法：

```go
// TestGetAll 测试GetAll方法
func (s *LevelRepositoryTestSuite) TestGetAll() {
    // 创建测试数据
    levels := []*model.Level{
        {
            Name: "等级1",
            Conditions: model.LevelConditions{
                ConditionType:  "points",
                ConditionValue: 1000,
            },
        },
        {
            Name: "等级2",
            Conditions: model.LevelConditions{
                ConditionType:  "currency",
                ConditionValue: 500,
            },
        },
    }
    for _, level := range levels {
        err := s.repo.Create(s.ctx, level)
        require.NoError(s.T(), err)
    }
    
    // 测试获取所有等级
    got, err := s.repo.GetAll(s.ctx)
    assert.NoError(s.T(), err)
    assert.GreaterOrEqual(s.T(), len(got), len(levels))
    
    // 验证返回的等级数据
    levelMap := make(map[int64]*model.Level)
    for _, level := range got {
        levelMap[level.ID] = level
    }
    for _, expected := range levels {
        actual, exists := levelMap[expected.ID]
        assert.True(s.T(), exists, "等级 %d 应该存在", expected.ID)
        assert.Equal(s.T(), expected.Name, actual.Name)
    }
}
```

### 4. 测试Create方法（包括JSONB字段）

测试Create方法，特别关注JSONB字段的存储：

```go
// TestCreate 测试Create方法
func (s *LevelRepositoryTestSuite) TestCreate() {
    tests := []struct {
        name    string
        level   *model.Level
        wantErr bool
    }{
        {
            name: "正常情况：创建等级（积分条件）",
            level: &model.Level{
                Name:        "新等级",
                Description: stringPtr("新等级描述"),
                Conditions: model.LevelConditions{
                    ConditionType:  "points",
                    ConditionValue: 1000,
                },
            },
            wantErr: false,
        },
        {
            name: "正常情况：创建等级（货币条件）",
            level: &model.Level{
                Name: "货币等级",
                Conditions: model.LevelConditions{
                    ConditionType:  "currency",
                    ConditionValue: 500,
                },
            },
            wantErr: false,
        },
    }
    
    for _, tt := range tests {
        s.T().Run(tt.name, func(t *testing.T) {
            err := s.repo.Create(s.ctx, tt.level)
            if tt.wantErr {
                assert.Error(t, err)
            } else {
                assert.NoError(t, err)
                assert.NotZero(t, tt.level.ID)
                
                // 验证JSONB字段是否正确存储
                retrieved, err := s.repo.GetByID(s.ctx, tt.level.ID)
                assert.NoError(t, err)
                assert.Equal(t, tt.level.Conditions.ConditionType, retrieved.Conditions.ConditionType)
                assert.Equal(t, tt.level.Conditions.ConditionValue, retrieved.Conditions.ConditionValue)
            }
        })
    }
}
```

### 5. 测试Update方法（包括JSONB字段）

测试Update方法，特别关注JSONB字段的更新：

```go
// TestUpdate 测试Update方法
func (s *LevelRepositoryTestSuite) TestUpdate() {
    // 创建测试数据
    level := &model.Level{
        Name: "待更新等级",
        Conditions: model.LevelConditions{
            ConditionType:  "points",
            ConditionValue: 1000,
        },
    }
    err := s.repo.Create(s.ctx, level)
    require.NoError(s.T(), err)
    
    tests := []struct {
        name    string
        level   *model.Level
        wantErr bool
        errMsg  string
    }{
        {
            name: "正常情况：更新等级（包括JSONB字段）",
            level: &model.Level{
                ID:          level.ID,
                Name:        "更新后的等级名",
                Description: stringPtr("更新后的描述"),
                Conditions: model.LevelConditions{
                    ConditionType:  "currency",
                    ConditionValue: 2000,
                },
            },
            wantErr: false,
        },
        {
            name: "异常情况：更新不存在的等级",
            level: &model.Level{
                ID:   99999,
                Name: "不存在的等级",
            },
            wantErr: true,
            errMsg:  "等级不存在",
        },
    }
    
    for _, tt := range tests {
        s.T().Run(tt.name, func(t *testing.T) {
            err := s.repo.Update(s.ctx, tt.level)
            if tt.wantErr {
                assert.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
            } else {
                assert.NoError(t, err)
                // 验证更新结果（包括JSONB字段）
                updated, err := s.repo.GetByID(s.ctx, tt.level.ID)
                assert.NoError(t, err)
                assert.Equal(t, tt.level.Name, updated.Name)
                assert.Equal(t, tt.level.Conditions.ConditionType, updated.Conditions.ConditionType)
                assert.Equal(t, tt.level.Conditions.ConditionValue, updated.Conditions.ConditionValue)
            }
        })
    }
}
```

### 6. 测试Delete方法

测试Delete方法：

```go
// TestDelete 测试Delete方法
func (s *LevelRepositoryTestSuite) TestDelete() {
    // 创建测试数据
    level := &model.Level{
        Name: "待删除等级",
        Conditions: model.LevelConditions{
            ConditionType:  "points",
            ConditionValue: 1000,
        },
    }
    err := s.repo.Create(s.ctx, level)
    require.NoError(s.T(), err)
    
    tests := []struct {
        name    string
        id      int64
        wantErr bool
        errMsg  string
    }{
        {
            name:    "正常情况：删除等级",
            id:      level.ID,
            wantErr: false,
        },
        {
            name:    "异常情况：删除不存在的等级",
            id:      99999,
            wantErr: true,
            errMsg:  "等级不存在",
        },
    }
    
    for _, tt := range tests {
        s.T().Run(tt.name, func(t *testing.T) {
            err := s.repo.Delete(s.ctx, tt.id)
            if tt.wantErr {
                assert.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
            } else {
                assert.NoError(t, err)
                // 验证删除结果（软删除，记录仍然存在但被标记为已删除）
                _, err := s.repo.GetByID(s.ctx, tt.id)
                assert.Error(t, err, "删除后应该无法查询到记录")
            }
        })
    }
}
```

### 7. 测试GetByName方法

测试GetByName方法：

```go
// TestGetByName 测试GetByName方法
func (s *LevelRepositoryTestSuite) TestGetByName() {
    // 创建测试数据
    level := &model.Level{
        Name: "特定名称等级",
        Conditions: model.LevelConditions{
            ConditionType:  "points",
            ConditionValue: 1000,
        },
    }
    err := s.repo.Create(s.ctx, level)
    require.NoError(s.T(), err)
    
    tests := []struct {
        name      string
        levelName string
        wantErr   bool
        errMsg    string
    }{
        {
            name:      "正常情况：根据名称获取等级",
            levelName: level.Name,
            wantErr:   false,
        },
        {
            name:      "异常情况：获取不存在的等级名称",
            levelName: "不存在的等级名称",
            wantErr:   true,
            errMsg:    "等级不存在",
        },
    }
    
    for _, tt := range tests {
        s.T().Run(tt.name, func(t *testing.T) {
            got, err := s.repo.GetByName(s.ctx, tt.levelName)
            if tt.wantErr {
                assert.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
                assert.Nil(t, got)
            } else {
                assert.NoError(t, err)
                assert.NotNil(t, got)
                assert.Equal(t, tt.levelName, got.Name)
            }
        })
    }
}

// stringPtr 辅助函数：将字符串转换为指针
func stringPtr(s string) *string {
    return &s
}

// TestLevelRepositoryTestSuite 运行测试套件
func TestLevelRepositoryTestSuite(t *testing.T) {
    suite.Run(t, new(LevelRepositoryTestSuite))
}
```

### 8. 运行测试和覆盖率检查

```bash
# 运行测试
go test ./internal/pkg/repository -v -run TestLevelRepositoryTestSuite

# 生成覆盖率报告
go test ./internal/pkg/repository -coverprofile=coverage.out -run TestLevelRepositoryTestSuite

# 查看覆盖率报告
go tool cover -html=coverage.out

# 检查覆盖率是否达标（应达到80%以上）
go tool cover -func=coverage.out | grep level_repository
```

## 验收标准

1. **测试覆盖完整**
   - 测试覆盖LevelRepository的所有方法：GetByID、GetAll、Create、Update、Delete、GetByName
   - 每个方法都测试了正常情况和异常情况
   - 测试覆盖边界情况（如空数据、不存在的记录等）
   - 特别测试了JSONB字段的存储和读取

2. **测试用例质量**
   - 使用表驱动测试（table-driven tests）处理多个测试场景
   - 测试用例名称清晰描述测试场景（使用中文）
   - 测试用例独立，不依赖执行顺序
   - 使用testify/suite组织测试代码

3. **测试环境设置**
   - 使用SQLite内存数据库进行测试（避免依赖外部数据库）
   - 每个测试前正确设置测试环境（SetupTest）
   - 每个测试后正确清理测试环境（TearDownTest）
   - 使用AutoMigrate创建测试表结构

4. **JSONB字段测试**
   - 测试JSONB字段的正确存储
   - 测试JSONB字段的正确读取
   - 测试JSONB字段的更新
   - 验证JSONB字段的数据完整性

5. **断言和验证**
   - 使用testify/assert和testify/require进行断言
   - 验证返回值正确性
   - 验证错误消息正确性（使用中文）
   - 验证数据库状态变化

6. **代码覆盖率达标**
   - 测试覆盖率应达到80%以上
   - 关键代码路径都有测试覆盖
   - 错误处理路径都有测试覆盖

7. **代码规范符合要求**
   - 测试代码通过golangci-lint检查，无错误和警告
   - 测试用例描述和错误消息使用中文
   - 遵循Golang单元测试规范
   - 测试代码清晰、易读、易维护

## 相关文件

- `internal/pkg/repository/level_repository_test.go` - 等级仓储单元测试文件
- `internal/pkg/repository/level_repository.go` - 等级仓储接口和实现
- `internal/pkg/model/level.go` - 等级模型定义
- `docs/TASKS/TASK004/TASK004-17.md` - 实现LevelRepository接口任务文档
- `.cursor/rules/testing.mdc` - 单元测试规范
- `docs/TASKS/TASK004/TASK004.md` - 主任务文档

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.1.0  
**最后更新**: 2026-01-03 14:54:20 CST

