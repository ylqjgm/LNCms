# TASK004-52: 编写权限中间件单元测试

## 任务信息

**任务编号**: TASK004-52  
**父任务**: TASK004  
**任务名称**: 编写权限中间件单元测试  
**版本信息**: v1.1.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 15:00:00 CST

## 任务描述

编写权限中间件单元测试。包括：1) 测试权限检查中间件的所有功能；2) 测试基于角色的权限检查；3) 测试基于用户组的权限检查；4) 测试权限缓存功能；5) 使用Mock Service和Mock Redis进行测试；6) 确保测试覆盖率达标。所有测试用例描述和错误消息必须使用中文。

## 依赖任务

- TASK004-51: 实现权限缓存机制

## 实现指南

### 1. 测试文件组织

创建测试文件：
- `internal/pkg/middleware/permission_middleware_test.go` - 权限中间件测试

### 2. 测试辅助函数和Mock

在测试文件中创建Mock Service和Mock Redis：

```go
package middleware

import (
    "context"
    "net/http"
    "net/http/httptest"
    "testing"
    
    "github.com/gin-gonic/gin"
    "github.com/redis/go-redis/v9"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
    "github.com/stretchr/testify/require"
    "yourproject/internal/pkg/model"
    "yourproject/internal/pkg/service"
)

// MockPermissionService Mock权限服务
type MockPermissionService struct {
    mock.Mock
}

func (m *MockPermissionService) GetRolePermissions(ctx context.Context, roleID int64) ([]*model.Permission, error) {
    args := m.Called(ctx, roleID)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).([]*model.Permission), args.Error(1)
}

func (m *MockPermissionService) GetUserGroupPermissions(ctx context.Context, userGroupID int64) ([]*model.Permission, error) {
    args := m.Called(ctx, userGroupID)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).([]*model.Permission), args.Error(1)
}

// MockRedisClient Mock Redis客户端（参考TASK004-46的实现）
type MockRedisClient struct {
    mock.Mock
    data map[string]string
}

func NewMockRedisClient() *MockRedisClient {
    return &MockRedisClient{
        data: make(map[string]string),
    }
}

// 实现Redis客户端方法（参考TASK004-46）
```

### 3. 测试RequirePermission方法

```go
func TestPermissionMiddleware_RequirePermission(t *testing.T) {
    mockPermissionService := new(MockPermissionService)
    mockRedis := NewMockRedisClient()
    
    middleware := NewPermissionMiddleware(mockPermissionService, mockRedis)
    
    tests := []struct {
        name           string
        setupContext   func(c *gin.Context)
        setupMock      func()
        permissionName string
        wantStatus     int
        wantErr        bool
    }{
        {
            name: "用户具有权限",
            setupContext: func(c *gin.Context) {
                c.Set("user_id", int64(1))
                roleID := int64(1)
                c.Set("role_id", roleID)
            },
            setupMock: func() {
                permissions := []*model.Permission{
                    {ID: 1, PermissionName: "test.permission", IsActive: true},
                }
                mockPermissionService.On("GetRolePermissions", mock.Anything, int64(1)).Return(permissions, nil)
            },
            permissionName: "test.permission",
            wantStatus:     http.StatusOK,
            wantErr:        false,
        },
        {
            name: "用户未登录",
            setupContext: func(c *gin.Context) {
                // 不设置user_id
            },
            setupMock: func() {},
            permissionName: "test.permission",
            wantStatus:     http.StatusUnauthorized,
            wantErr:        true,
        },
        {
            name: "用户没有权限",
            setupContext: func(c *gin.Context) {
                c.Set("user_id", int64(1))
                roleID := int64(1)
                c.Set("role_id", roleID)
            },
            setupMock: func() {
                permissions := []*model.Permission{
                    {ID: 1, PermissionName: "other.permission", IsActive: true},
                }
                mockPermissionService.On("GetRolePermissions", mock.Anything, int64(1)).Return(permissions, nil)
            },
            permissionName: "test.permission",
            wantStatus:     http.StatusForbidden,
            wantErr:        true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            gin.SetMode(gin.TestMode)
            w := httptest.NewRecorder()
            c, _ := gin.CreateTestContext(w)
            c.Request = httptest.NewRequest("GET", "/test", nil)
            
            tt.setupContext(c)
            tt.setupMock()
            
            handler := middleware.RequirePermission(tt.permissionName)
            handler(c)
            
            assert.Equal(t, tt.wantStatus, w.Code)
            mockPermissionService.AssertExpectations(t)
        })
    }
}
```

### 4. 测试RequireAnyPermission方法

```go
func TestPermissionMiddleware_RequireAnyPermission(t *testing.T) {
    mockPermissionService := new(MockPermissionService)
    mockRedis := NewMockRedisClient()
    
    middleware := NewPermissionMiddleware(mockPermissionService, mockRedis)
    
    tests := []struct {
        name            string
        setupContext    func(c *gin.Context)
        setupMock       func()
        permissionNames []string
        wantStatus      int
    }{
        {
            name: "用户具有任意一个权限",
            setupContext: func(c *gin.Context) {
                c.Set("user_id", int64(1))
                roleID := int64(1)
                c.Set("role_id", roleID)
            },
            setupMock: func() {
                permissions := []*model.Permission{
                    {ID: 1, PermissionName: "permission1", IsActive: true},
                }
                mockPermissionService.On("GetRolePermissions", mock.Anything, int64(1)).Return(permissions, nil)
            },
            permissionNames: []string{"permission1", "permission2"},
            wantStatus:      http.StatusOK,
        },
        {
            name: "用户没有任何权限",
            setupContext: func(c *gin.Context) {
                c.Set("user_id", int64(1))
                roleID := int64(1)
                c.Set("role_id", roleID)
            },
            setupMock: func() {
                permissions := []*model.Permission{}
                mockPermissionService.On("GetRolePermissions", mock.Anything, int64(1)).Return(permissions, nil)
            },
            permissionNames: []string{"permission1", "permission2"},
            wantStatus:      http.StatusForbidden,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            gin.SetMode(gin.TestMode)
            w := httptest.NewRecorder()
            c, _ := gin.CreateTestContext(w)
            c.Request = httptest.NewRequest("GET", "/test", nil)
            
            tt.setupContext(c)
            tt.setupMock()
            
            handler := middleware.RequireAnyPermission(tt.permissionNames...)
            handler(c)
            
            assert.Equal(t, tt.wantStatus, w.Code)
        })
    }
}
```

### 5. 测试RequireAllPermissions方法

```go
func TestPermissionMiddleware_RequireAllPermissions(t *testing.T) {
    mockPermissionService := new(MockPermissionService)
    mockRedis := NewMockRedisClient()
    
    middleware := NewPermissionMiddleware(mockPermissionService, mockRedis)
    
    tests := []struct {
        name            string
        setupContext    func(c *gin.Context)
        setupMock       func()
        permissionNames []string
        wantStatus      int
    }{
        {
            name: "用户具有所有权限",
            setupContext: func(c *gin.Context) {
                c.Set("user_id", int64(1))
                roleID := int64(1)
                c.Set("role_id", roleID)
            },
            setupMock: func() {
                permissions := []*model.Permission{
                    {ID: 1, PermissionName: "permission1", IsActive: true},
                    {ID: 2, PermissionName: "permission2", IsActive: true},
                }
                mockPermissionService.On("GetRolePermissions", mock.Anything, int64(1)).Return(permissions, nil)
            },
            permissionNames: []string{"permission1", "permission2"},
            wantStatus:      http.StatusOK,
        },
        {
            name: "用户缺少部分权限",
            setupContext: func(c *gin.Context) {
                c.Set("user_id", int64(1))
                roleID := int64(1)
                c.Set("role_id", roleID)
            },
            setupMock: func() {
                permissions := []*model.Permission{
                    {ID: 1, PermissionName: "permission1", IsActive: true},
                }
                mockPermissionService.On("GetRolePermissions", mock.Anything, int64(1)).Return(permissions, nil)
            },
            permissionNames: []string{"permission1", "permission2"},
            wantStatus:      http.StatusForbidden,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            gin.SetMode(gin.TestMode)
            w := httptest.NewRecorder()
            c, _ := gin.CreateTestContext(w)
            c.Request = httptest.NewRequest("GET", "/test", nil)
            
            tt.setupContext(c)
            tt.setupMock()
            
            handler := middleware.RequireAllPermissions(tt.permissionNames...)
            handler(c)
            
            assert.Equal(t, tt.wantStatus, w.Code)
        })
    }
}
```

### 6. 测试基于用户组的权限检查

```go
func TestPermissionMiddleware_UserGroupPermission(t *testing.T) {
    mockPermissionService := new(MockPermissionService)
    mockRedis := NewMockRedisClient()
    
    middleware := NewPermissionMiddleware(mockPermissionService, mockRedis)
    
    tests := []struct {
        name         string
        setupContext func(c *gin.Context)
        setupMock    func()
        wantStatus   int
    }{
        {
            name: "用户组具有权限",
            setupContext: func(c *gin.Context) {
                c.Set("user_id", int64(1))
                c.Set("user_group_ids", []int64{1, 2})
            },
            setupMock: func() {
                permissions := []*model.Permission{
                    {ID: 1, PermissionName: "test.permission", IsActive: true},
                }
                mockPermissionService.On("GetUserGroupPermissions", mock.Anything, int64(1)).Return(permissions, nil)
            },
            wantStatus: http.StatusOK,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            gin.SetMode(gin.TestMode)
            w := httptest.NewRecorder()
            c, _ := gin.CreateTestContext(w)
            c.Request = httptest.NewRequest("GET", "/test", nil)
            
            tt.setupContext(c)
            tt.setupMock()
            
            handler := middleware.RequirePermission("test.permission")
            handler(c)
            
            assert.Equal(t, tt.wantStatus, w.Code)
        })
    }
}
```

### 7. 测试权限缓存功能

```go
func TestPermissionMiddleware_Cache(t *testing.T) {
    mockPermissionService := new(MockPermissionService)
    mockRedis := NewMockRedisClient()
    
    middleware := NewPermissionMiddleware(mockPermissionService, mockRedis)
    
    // 测试从缓存读取权限
    t.Run("从缓存读取权限", func(t *testing.T) {
        gin.SetMode(gin.TestMode)
        w := httptest.NewRecorder()
        c, _ := gin.CreateTestContext(w)
        c.Request = httptest.NewRequest("GET", "/test", nil)
        
        c.Set("user_id", int64(1))
        roleID := int64(1)
        c.Set("role_id", roleID)
        
        // 设置缓存
        cacheKey := "permission:check:user:1:permission:test.permission"
        mockRedis.data[cacheKey] = "true"
        
        handler := middleware.RequirePermission("test.permission")
        handler(c)
        
        assert.Equal(t, http.StatusOK, w.Code)
        // 验证没有调用Service（因为从缓存读取）
        mockPermissionService.AssertNotCalled(t, "GetRolePermissions")
    })
}
```

### 8. 代码规范要求

- 所有测试用例描述使用中文
- 使用表驱动测试处理多个测试场景
- 使用testify的assert和require包
- 使用Mock Service和Mock Redis
- 每个测试用例独立，不依赖其他测试
- 测试覆盖率应达到80%以上

## 验收标准

1. **测试覆盖完整**
   - 权限检查中间件的所有方法都有测试用例
   - 测试覆盖正常情况、边界情况和异常情况
   - 测试覆盖基于角色的权限检查
   - 测试覆盖基于用户组的权限检查
   - 测试覆盖权限缓存功能

2. **测试用例质量**
   - 测试用例描述清晰，使用中文
   - 使用表驱动测试处理多个场景
   - 测试用例独立，不依赖执行顺序
   - 使用适当的断言和验证

3. **Mock使用正确**
   - 正确使用Mock Service
   - 正确使用Mock Redis
   - Mock设置和验证正确

4. **测试覆盖率达标**
   - 代码覆盖率应达到80%以上
   - 关键路径覆盖率应达到90%以上
   - 使用go test -cover检查覆盖率

5. **代码规范符合要求**
   - 代码通过golangci-lint检查
   - 测试代码注释完整，使用中文
   - 遵循Golang编码规范和测试规范

## 相关文件

- `internal/pkg/middleware/permission_middleware_test.go` - 权限中间件测试
- `internal/pkg/middleware/permission_middleware.go` - 权限中间件实现
- `.cursor/rules/testing.mdc` - 单元测试规范
- `docs/TASKS/TASK004/TASK004-51.md` - 实现权限缓存机制任务文档
- `docs/TASKS/TASK004/TASK004.md` - 主任务文档

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.1.0  
**最后更新**: 2026-01-03 15:00:00 CST

