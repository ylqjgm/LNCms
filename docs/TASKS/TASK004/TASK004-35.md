# TASK004-35: 编写AuthorLevelService单元测试

## 任务信息

**任务编号**: TASK004-35  
**父任务**: TASK004  
**任务名称**: 编写AuthorLevelService单元测试  
**版本信息**: v1.1.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 15:34:33 CST

## 任务描述

编写作者等级服务层单元测试。包括：1) 测试AuthorLevelService的所有方法；2) 测试输入验证功能；3) 测试作者等级达成条件验证逻辑；4) 使用Mock Repository进行测试；5) 确保测试覆盖率达标。所有测试用例描述和错误消息必须使用中文。

## 依赖任务

- TASK004-34: 创建AuthorLevelService接口和实现

## 实现指南

### 1. 设置测试环境

在 `internal/pkg/service/author_level_service_test.go` 文件中创建测试文件：

```go
package service

import (
    "context"
    "testing"
    
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
    "github.com/stretchr/testify/suite"
    "yourproject/internal/pkg/model"
    "yourproject/internal/pkg/repository"
)

// MockAuthorLevelRepository Mock作者等级仓储
type MockAuthorLevelRepository struct {
    mock.Mock
}

func (m *MockAuthorLevelRepository) GetByID(ctx context.Context, id int64) (*model.AuthorLevel, error) {
    args := m.Called(ctx, id)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*model.AuthorLevel), args.Error(1)
}

func (m *MockAuthorLevelRepository) GetAll(ctx context.Context) ([]*model.AuthorLevel, error) {
    args := m.Called(ctx)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).([]*model.AuthorLevel), args.Error(1)
}

func (m *MockAuthorLevelRepository) Create(ctx context.Context, authorLevel *model.AuthorLevel) error {
    args := m.Called(ctx, authorLevel)
    return args.Error(0)
}

func (m *MockAuthorLevelRepository) Update(ctx context.Context, authorLevel *model.AuthorLevel) error {
    args := m.Called(ctx, authorLevel)
    return args.Error(0)
}

func (m *MockAuthorLevelRepository) Delete(ctx context.Context, id int64) error {
    args := m.Called(ctx, id)
    return args.Error(0)
}

func (m *MockAuthorLevelRepository) GetByName(ctx context.Context, name string) (*model.AuthorLevel, error) {
    args := m.Called(ctx, name)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*model.AuthorLevel), args.Error(1)
}

// AuthorLevelServiceTestSuite 作者等级服务测试套件
type AuthorLevelServiceTestSuite struct {
    suite.Suite
    service AuthorLevelService
    mockRepo *MockAuthorLevelRepository
    ctx      context.Context
}

// SetupTest 每个测试前的设置
func (s *AuthorLevelServiceTestSuite) SetupTest() {
    s.mockRepo = new(MockAuthorLevelRepository)
    s.service = NewAuthorLevelService(s.mockRepo)
    s.ctx = context.Background()
}
```

### 2. 测试GetByID方法

测试GetByID方法的正常情况和异常情况：

```go
// TestGetByID 测试GetByID方法
func (s *AuthorLevelServiceTestSuite) TestGetByID() {
    tests := []struct {
        name    string
        id      int64
        setup   func()
        wantErr bool
        errMsg  string
    }{
        {
            name: "正常情况：获取存在的作者等级",
            id:   1,
            setup: func() {
                authorLevel := &model.AuthorLevel{
                    ID:   1,
                    Name: "测试等级",
                }
                s.mockRepo.On("GetByID", s.ctx, int64(1)).Return(authorLevel, nil)
            },
            wantErr: false,
        },
        {
            name: "异常情况：ID无效",
            id:   0,
            setup: func() {},
            wantErr: true,
            errMsg:  "作者等级ID无效",
        },
        {
            name: "异常情况：作者等级不存在",
            id:   999,
            setup: func() {
                s.mockRepo.On("GetByID", s.ctx, int64(999)).Return(nil, fmt.Errorf("作者等级不存在"))
            },
            wantErr: true,
        },
    }
    
    for _, tt := range tests {
        s.Run(tt.name, func() {
            tt.setup()
            result, err := s.service.GetByID(s.ctx, tt.id)
            if tt.wantErr {
                assert.Error(s.T(), err)
                if tt.errMsg != "" {
                    assert.Contains(s.T(), err.Error(), tt.errMsg)
                }
                assert.Nil(s.T(), result)
            } else {
                assert.NoError(s.T(), err)
                assert.NotNil(s.T(), result)
            }
            s.mockRepo.AssertExpectations(s.T())
        })
    }
}
```

### 3. 测试Create方法

测试Create方法，包括输入验证和作者等级达成条件验证：

```go
// TestCreate 测试Create方法
func (s *AuthorLevelServiceTestSuite) TestCreate() {
    tests := []struct {
        name    string
        req     *CreateAuthorLevelRequest
        setup   func()
        wantErr bool
        errMsg  string
    }{
        {
            name: "正常情况：创建作者等级",
            req: &CreateAuthorLevelRequest{
                Name: "测试等级",
                Conditions: model.AuthorLevelConditions{
                    ConditionType:  "works_count",
                    ConditionValue: 10,
                },
            },
            setup: func() {
                s.mockRepo.On("GetByName", s.ctx, "测试等级").Return(nil, fmt.Errorf("作者等级不存在"))
                s.mockRepo.On("Create", s.ctx, mock.AnythingOfType("*model.AuthorLevel")).Return(nil)
            },
            wantErr: false,
        },
        {
            name: "异常情况：名称为空",
            req: &CreateAuthorLevelRequest{
                Name: "",
                Conditions: model.AuthorLevelConditions{
                    ConditionType:  "works_count",
                    ConditionValue: 10,
                },
            },
            setup:   func() {},
            wantErr: true,
            errMsg:  "作者等级名称不能为空",
        },
        {
            name: "异常情况：名称已存在",
            req: &CreateAuthorLevelRequest{
                Name: "已存在等级",
                Conditions: model.AuthorLevelConditions{
                    ConditionType:  "works_count",
                    ConditionValue: 10,
                },
            },
            setup: func() {
                existing := &model.AuthorLevel{ID: 1, Name: "已存在等级"}
                s.mockRepo.On("GetByName", s.ctx, "已存在等级").Return(existing, nil)
            },
            wantErr: true,
            errMsg:  "作者等级名称已存在",
        },
        {
            name: "异常情况：无效的条件类型",
            req: &CreateAuthorLevelRequest{
                Name: "测试等级",
                Conditions: model.AuthorLevelConditions{
                    ConditionType:  "invalid_type",
                    ConditionValue: 10,
                },
            },
            setup:   func() {},
            wantErr: true,
            errMsg:  "无效的作者等级达成条件类型",
        },
    }
    
    for _, tt := range tests {
        s.Run(tt.name, func() {
            tt.setup()
            result, err := s.service.Create(s.ctx, tt.req)
            if tt.wantErr {
                assert.Error(s.T(), err)
                if tt.errMsg != "" {
                    assert.Contains(s.T(), err.Error(), tt.errMsg)
                }
                assert.Nil(s.T(), result)
            } else {
                assert.NoError(s.T(), err)
                assert.NotNil(s.T(), result)
            }
            s.mockRepo.AssertExpectations(s.T())
        })
    }
}
```

### 4. 测试Update方法

测试Update方法：

```go
// TestUpdate 测试Update方法
func (s *AuthorLevelServiceTestSuite) TestUpdate() {
    tests := []struct {
        name    string
        id      int64
        req     *UpdateAuthorLevelRequest
        setup   func()
        wantErr bool
        errMsg  string
    }{
        {
            name: "正常情况：更新作者等级",
            id:   1,
            req: &UpdateAuthorLevelRequest{
                Name: "更新后的等级",
                Conditions: model.AuthorLevelConditions{
                    ConditionType:  "works_count",
                    ConditionValue: 20,
                },
            },
            setup: func() {
                existing := &model.AuthorLevel{ID: 1, Name: "原始等级"}
                s.mockRepo.On("GetByID", s.ctx, int64(1)).Return(existing, nil)
                s.mockRepo.On("GetByName", s.ctx, "更新后的等级").Return(nil, fmt.Errorf("作者等级不存在"))
                s.mockRepo.On("Update", s.ctx, mock.AnythingOfType("*model.AuthorLevel")).Return(nil)
            },
            wantErr: false,
        },
        {
            name: "异常情况：ID无效",
            id:   0,
            req: &UpdateAuthorLevelRequest{
                Name: "测试等级",
                Conditions: model.AuthorLevelConditions{
                    ConditionType:  "works_count",
                    ConditionValue: 10,
                },
            },
            setup:   func() {},
            wantErr: true,
            errMsg:  "作者等级ID无效",
        },
    }
    
    for _, tt := range tests {
        s.Run(tt.name, func() {
            tt.setup()
            result, err := s.service.Update(s.ctx, tt.id, tt.req)
            if tt.wantErr {
                assert.Error(s.T(), err)
                if tt.errMsg != "" {
                    assert.Contains(s.T(), err.Error(), tt.errMsg)
                }
                assert.Nil(s.T(), result)
            } else {
                assert.NoError(s.T(), err)
                assert.NotNil(s.T(), result)
            }
            s.mockRepo.AssertExpectations(s.T())
        })
    }
}
```

### 5. 测试Delete方法

测试Delete方法：

```go
// TestDelete 测试Delete方法
func (s *AuthorLevelServiceTestSuite) TestDelete() {
    tests := []struct {
        name    string
        id      int64
        setup   func()
        wantErr bool
        errMsg  string
    }{
        {
            name: "正常情况：删除作者等级",
            id:   1,
            setup: func() {
                existing := &model.AuthorLevel{ID: 1}
                s.mockRepo.On("GetByID", s.ctx, int64(1)).Return(existing, nil)
                s.mockRepo.On("Delete", s.ctx, int64(1)).Return(nil)
            },
            wantErr: false,
        },
        {
            name: "异常情况：ID无效",
            id:   0,
            setup: func() {},
            wantErr: true,
            errMsg:  "作者等级ID无效",
        },
        {
            name: "异常情况：作者等级不存在",
            id:   999,
            setup: func() {
                s.mockRepo.On("GetByID", s.ctx, int64(999)).Return(nil, fmt.Errorf("作者等级不存在"))
            },
            wantErr: true,
        },
    }
    
    for _, tt := range tests {
        s.Run(tt.name, func() {
            tt.setup()
            err := s.service.Delete(s.ctx, tt.id)
            if tt.wantErr {
                assert.Error(s.T(), err)
                if tt.errMsg != "" {
                    assert.Contains(s.T(), err.Error(), tt.errMsg)
                }
            } else {
                assert.NoError(s.T(), err)
            }
            s.mockRepo.AssertExpectations(s.T())
        })
    }
}
```

### 6. 运行测试套件

在文件末尾添加测试运行函数：

```go
// TestAuthorLevelServiceTestSuite 运行测试套件
func TestAuthorLevelServiceTestSuite(t *testing.T) {
    suite.Run(t, new(AuthorLevelServiceTestSuite))
}
```

### 7. 代码规范要求

- 所有测试用例描述使用中文
- 使用testify/suite组织测试
- 使用testify/mock创建Mock Repository
- 使用testify/assert和testify/require进行断言
- 测试覆盖正常情况、边界情况和异常情况
- 测试输入验证功能
- 测试作者等级达成条件验证逻辑
- 确保测试覆盖率达标（80%以上）

## 验收标准

1. **测试覆盖完整**
   - 测试了AuthorLevelService的所有方法：GetByID、GetAll、Create、Update、Delete
   - 测试了输入验证功能
   - 测试了作者等级达成条件验证逻辑
   - 测试了正常情况、边界情况和异常情况

2. **测试质量**
   - 使用testify/suite组织测试
   - 使用testify/mock创建Mock Repository
   - 测试用例描述清晰（使用中文）
   - 断言使用正确，错误消息清晰

3. **测试覆盖率达标**
   - 代码覆盖率达到80%以上
   - 所有关键路径都有测试覆盖

4. **代码规范符合要求**
   - 代码通过golangci-lint检查，无错误和警告
   - 测试代码注释完整，使用中文
   - 遵循Golang编码规范和测试规范

## 相关文件

- `internal/pkg/service/author_level_service_test.go` - 作者等级服务测试文件
- `internal/pkg/service/author_level_service.go` - 作者等级服务实现
- `docs/TASKS/TASK004/TASK004-34.md` - 创建AuthorLevelService任务文档
- `.cursor/rules/golang.mdc` - Golang编码规范
- `docs/TASKS/TASK004/TASK004.md` - 主任务文档

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.1.0  
**最后更新**: 2026-01-03 15:34:33 CST

