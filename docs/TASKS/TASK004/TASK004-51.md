# TASK004-51: 实现权限缓存机制

## 任务信息

**任务编号**: TASK004-51  
**父任务**: TASK004  
**任务名称**: 实现权限缓存机制  
**版本信息**: v1.1.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 15:00:00 CST

## 任务描述

实现权限缓存机制。包括：1) 实现权限数据的Redis缓存存储逻辑（缓存键设计：permission:role:{role_id}、permission:group:{group_id}）；2) 实现权限数据的Redis缓存读取逻辑；3) 实现权限变更时的缓存清除逻辑；4) 配置缓存过期时间（建议1小时）。所有代码必须遵循Golang编码规范。

## 依赖任务

- TASK004-50: 实现权限检查逻辑

## 实现指南

### 1. 定义缓存键常量

在 `internal/pkg/service/permission_cache.go` 文件中定义缓存键常量：

```go
package service

const (
    // CacheKeyRolePermissions 角色权限缓存键模板
    CacheKeyRolePermissions = "permission:role:%d"
    
    // CacheKeyUserGroupPermissions 用户组权限缓存键模板
    CacheKeyUserGroupPermissions = "permission:group:%d"
    
    // CacheKeyPermissionCheck 权限检查缓存键模板
    CacheKeyPermissionCheck = "permission:check:user:%d:permission:%s"
    
    // CacheExpiration 缓存过期时间（1小时）
    CacheExpiration = 1 * time.Hour
)
```

### 2. 实现角色权限缓存方法

在PermissionService中实现角色权限缓存相关方法：

```go
// cacheRolePermissions 缓存角色权限
func (s *permissionService) cacheRolePermissions(ctx context.Context, roleID int64, permissions []*model.Permission) error {
    cacheKey := fmt.Sprintf(CacheKeyRolePermissions, roleID)
    data, err := json.Marshal(permissions)
    if err != nil {
        return fmt.Errorf("序列化权限数据失败: %w", err)
    }
    
    err = s.redisClient.Set(ctx, cacheKey, data, CacheExpiration).Err()
    if err != nil {
        return fmt.Errorf("缓存角色权限失败: %w", err)
    }
    
    return nil
}

// getRolePermissionsFromCache 从缓存获取角色权限
func (s *permissionService) getRolePermissionsFromCache(ctx context.Context, roleID int64) ([]*model.Permission, error) {
    cacheKey := fmt.Sprintf(CacheKeyRolePermissions, roleID)
    data, err := s.redisClient.Get(ctx, cacheKey).Result()
    if err == redis.Nil {
        return nil, nil // 缓存不存在
    }
    if err != nil {
        return nil, fmt.Errorf("获取缓存失败: %w", err)
    }
    
    var permissions []*model.Permission
    if err := json.Unmarshal([]byte(data), &permissions); err != nil {
        return nil, fmt.Errorf("反序列化权限数据失败: %w", err)
    }
    
    return permissions, nil
}

// clearRolePermissionCache 清除角色权限缓存
func (s *permissionService) clearRolePermissionCache(ctx context.Context, roleID int64) error {
    cacheKey := fmt.Sprintf(CacheKeyRolePermissions, roleID)
    err := s.redisClient.Del(ctx, cacheKey).Err()
    if err != nil {
        return fmt.Errorf("清除角色权限缓存失败: %w", err)
    }
    
    // 同时清除该角色的所有权限检查缓存
    pattern := fmt.Sprintf("permission:check:*:role:%d:*", roleID)
    s.clearCacheByPattern(ctx, pattern)
    
    return nil
}
```

### 3. 实现用户组权限缓存方法

实现用户组权限缓存相关方法：

```go
// cacheUserGroupPermissions 缓存用户组权限
func (s *permissionService) cacheUserGroupPermissions(ctx context.Context, userGroupID int64, permissions []*model.Permission) error {
    cacheKey := fmt.Sprintf(CacheKeyUserGroupPermissions, userGroupID)
    data, err := json.Marshal(permissions)
    if err != nil {
        return fmt.Errorf("序列化权限数据失败: %w", err)
    }
    
    err = s.redisClient.Set(ctx, cacheKey, data, CacheExpiration).Err()
    if err != nil {
        return fmt.Errorf("缓存用户组权限失败: %w", err)
    }
    
    return nil
}

// getUserGroupPermissionsFromCache 从缓存获取用户组权限
func (s *permissionService) getUserGroupPermissionsFromCache(ctx context.Context, userGroupID int64) ([]*model.Permission, error) {
    cacheKey := fmt.Sprintf(CacheKeyUserGroupPermissions, userGroupID)
    data, err := s.redisClient.Get(ctx, cacheKey).Result()
    if err == redis.Nil {
        return nil, nil // 缓存不存在
    }
    if err != nil {
        return nil, fmt.Errorf("获取缓存失败: %w", err)
    }
    
    var permissions []*model.Permission
    if err := json.Unmarshal([]byte(data), &permissions); err != nil {
        return nil, fmt.Errorf("反序列化权限数据失败: %w", err)
    }
    
    return permissions, nil
}

// clearUserGroupPermissionCache 清除用户组权限缓存
func (s *permissionService) clearUserGroupPermissionCache(ctx context.Context, userGroupID int64) error {
    cacheKey := fmt.Sprintf(CacheKeyUserGroupPermissions, userGroupID)
    err := s.redisClient.Del(ctx, cacheKey).Err()
    if err != nil {
        return fmt.Errorf("清除用户组权限缓存失败: %w", err)
    }
    
    // 同时清除该用户组的所有权限检查缓存
    pattern := fmt.Sprintf("permission:check:*:group:%d:*", userGroupID)
    s.clearCacheByPattern(ctx, pattern)
    
    return nil
}
```

### 4. 实现缓存清除辅助方法

实现通用的缓存清除方法：

```go
// clearCacheByPattern 根据模式清除缓存
func (s *permissionService) clearCacheByPattern(ctx context.Context, pattern string) {
    // 使用SCAN命令扫描匹配的键（避免阻塞）
    iter := s.redisClient.Scan(ctx, 0, pattern, 100).Iterator()
    keys := make([]string, 0)
    
    for iter.Next(ctx) {
        keys = append(keys, iter.Val())
    }
    
    if err := iter.Err(); err != nil {
        // 记录错误但不中断流程
        return
    }
    
    if len(keys) > 0 {
        // 批量删除
        s.redisClient.Del(ctx, keys...)
    }
}

// clearPermissionCache 清除权限相关缓存
func (s *permissionService) clearPermissionCache(ctx context.Context, permissionID int64) {
    // 获取权限信息
    permission, err := s.permissionRepo.GetByID(ctx, permissionID)
    if err != nil {
        return
    }
    
    // 清除所有包含该权限的缓存
    // 这里可以通过扫描所有角色和用户组权限缓存来实现
    // 或者使用更高效的方式，如维护权限到角色/用户组的反向索引
    
    // 方式1：扫描所有缓存（性能较低，但实现简单）
    pattern := "permission:role:*"
    s.clearCacheByPattern(ctx, pattern)
    
    pattern = "permission:group:*"
    s.clearCacheByPattern(ctx, pattern)
    
    // 方式2：维护反向索引（推荐，但需要额外的数据结构）
    // 这里可以根据实际需求选择实现方式
}
```

### 5. 在权限变更时清除缓存

在权限变更的方法中调用缓存清除方法：

```go
// Update 更新权限（已实现，需要添加缓存清除）
func (s *permissionService) Update(ctx context.Context, id int64, req *UpdatePermissionRequest) (*model.Permission, error) {
    // ... 原有更新逻辑 ...
    
    // 清除权限相关缓存
    s.clearPermissionCache(ctx, id)
    
    return permission, nil
}

// Delete 删除权限（已实现，需要添加缓存清除）
func (s *permissionService) Delete(ctx context.Context, id int64) error {
    // ... 原有删除逻辑 ...
    
    // 清除权限相关缓存
    s.clearPermissionCache(ctx, id)
    
    return nil
}

// AssignPermissionsToRole 为角色分配权限（已实现，需要添加缓存清除）
func (s *permissionService) AssignPermissionsToRole(ctx context.Context, roleID int64, permissionIDs []int64) error {
    // ... 原有分配逻辑 ...
    
    // 清除角色权限缓存
    s.clearRolePermissionCache(ctx, roleID)
    
    return nil
}

// RemovePermissionsFromRole 移除角色的权限（已实现，需要添加缓存清除）
func (s *permissionService) RemovePermissionsFromRole(ctx context.Context, roleID int64, permissionIDs []int64) error {
    // ... 原有移除逻辑 ...
    
    // 清除角色权限缓存
    s.clearRolePermissionCache(ctx, roleID)
    
    return nil
}
```

### 6. 优化GetRolePermissions方法

优化GetRolePermissions方法，优先从缓存读取：

```go
// GetRolePermissions 获取角色的权限列表（已优化）
func (s *permissionService) GetRolePermissions(ctx context.Context, roleID int64) ([]*model.Permission, error) {
    if roleID <= 0 {
        return nil, fmt.Errorf("角色ID无效")
    }
    
    // 优先从缓存获取
    permissions, err := s.getRolePermissionsFromCache(ctx, roleID)
    if err == nil && permissions != nil {
        return permissions, nil
    }
    
    // 从数据库获取
    rolePermissions, err := s.rolePermissionRepo.GetByRoleID(ctx, roleID)
    if err != nil {
        return nil, fmt.Errorf("获取角色权限失败: %w", err)
    }
    
    // 获取权限详情
    permissionIDs := make([]int64, 0, len(rolePermissions))
    for _, rp := range rolePermissions {
        permissionIDs = append(permissionIDs, rp.PermissionID)
    }
    
    permissions = make([]*model.Permission, 0, len(permissionIDs))
    for _, permissionID := range permissionIDs {
        permission, err := s.permissionRepo.GetByID(ctx, permissionID)
        if err != nil {
            continue // 跳过不存在的权限
        }
        permissions = append(permissions, permission)
    }
    
    // 缓存权限列表
    s.cacheRolePermissions(ctx, roleID, permissions)
    
    return permissions, nil
}
```

### 7. 代码规范要求

- 缓存键设计清晰，易于理解
- 缓存数据序列化使用JSON格式
- 缓存过期时间配置合理
- 缓存清除逻辑完整
- 错误处理正确
- 所有方法都有清晰的注释（使用中文）

## 验收标准

1. **缓存存储逻辑正确**
   - 角色权限缓存正确存储
   - 用户组权限缓存正确存储
   - 缓存键设计合理
   - 缓存数据序列化正确

2. **缓存读取逻辑正确**
   - 优先从缓存读取权限数据
   - 缓存不存在时从数据库读取
   - 读取后正确缓存数据

3. **缓存清除逻辑完整**
   - 权限变更时正确清除相关缓存
   - 角色权限变更时清除角色权限缓存
   - 用户组权限变更时清除用户组权限缓存
   - 支持按模式清除缓存

4. **缓存配置合理**
   - 缓存过期时间配置为1小时
   - 缓存键命名规范
   - 缓存数据结构合理

5. **代码规范符合要求**
   - 代码通过golangci-lint检查，无错误和警告
   - 代码注释完整，使用中文
   - 遵循Golang编码规范

## 相关文件

- `internal/pkg/service/permission_service.go` - 权限服务实现（包含缓存逻辑）
- `internal/pkg/service/permission_cache.go` - 权限缓存相关方法（可选，如果单独文件）
- `docs/TASKS/TASK004/TASK004-50.md` - 实现权限检查逻辑任务文档
- `.cursor/rules/golang.mdc` - Golang编码规范
- `docs/TASKS/TASK004/TASK004.md` - 主任务文档

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.1.0  
**最后更新**: 2026-01-03 15:00:00 CST

