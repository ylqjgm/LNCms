# TASK004-45: 创建PermissionService接口和实现

## 任务信息

**任务编号**: TASK004-45  
**父任务**: TASK004  
**任务名称**: 创建PermissionService接口和实现  
**版本信息**: v1.1.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 15:00:00 CST

## 任务描述

创建PermissionService接口和实现，提供权限的业务逻辑处理。包括：1) 定义PermissionService接口；2) 实现权限的创建、查询、更新、删除方法；3) 实现权限分配逻辑（角色权限分配、用户组权限分配）；4) 实现权限查询逻辑（获取角色权限、获取用户组权限）；5) 实现权限缓存机制（使用Redis缓存权限数据）。所有代码必须遵循Golang编码规范，错误消息使用中文。

## 依赖任务

- TASK004-41: 实现PermissionRepository接口和实现
- TASK004-42: 实现RolePermissionRepository接口和实现
- TASK004-43: 实现UserGroupPermissionRepository接口和实现

## 实现指南

### 1. 定义PermissionService接口

在 `internal/pkg/service/permission_service.go` 文件中定义接口：

```go
package service

import (
    "context"
    "yourproject/internal/pkg/model"
)

// PermissionService 权限服务接口
type PermissionService interface {
    // GetByID 根据ID获取权限
    GetByID(ctx context.Context, id int64) (*model.Permission, error)
    
    // GetAll 获取所有权限
    GetAll(ctx context.Context) ([]*model.Permission, error)
    
    // Create 创建权限
    Create(ctx context.Context, req *CreatePermissionRequest) (*model.Permission, error)
    
    // Update 更新权限
    Update(ctx context.Context, id int64, req *UpdatePermissionRequest) (*model.Permission, error)
    
    // Delete 删除权限
    Delete(ctx context.Context, id int64) error
    
    // AssignPermissionsToRole 为角色分配权限
    AssignPermissionsToRole(ctx context.Context, roleID int64, permissionIDs []int64) error
    
    // RemovePermissionsFromRole 移除角色的权限
    RemovePermissionsFromRole(ctx context.Context, roleID int64, permissionIDs []int64) error
    
    // GetRolePermissions 获取角色的权限列表
    GetRolePermissions(ctx context.Context, roleID int64) ([]*model.Permission, error)
    
    // AssignPermissionsToUserGroup 为用户组分配权限
    AssignPermissionsToUserGroup(ctx context.Context, userGroupID int64, permissionIDs []int64) error
    
    // RemovePermissionsFromUserGroup 移除用户组的权限
    RemovePermissionsFromUserGroup(ctx context.Context, userGroupID int64, permissionIDs []int64) error
    
    // GetUserGroupPermissions 获取用户组的权限列表
    GetUserGroupPermissions(ctx context.Context, userGroupID int64) ([]*model.Permission, error)
}

// CreatePermissionRequest 创建权限请求
type CreatePermissionRequest struct {
    PermissionName        string  `json:"permission_name" binding:"required,min=1,max=100"`
    PermissionTarget      *string `json:"permission_target,omitempty"`
    PermissionDescription  *string `json:"permission_description,omitempty"`
    IsActive              bool    `json:"is_active"`
}

// UpdatePermissionRequest 更新权限请求
type UpdatePermissionRequest struct {
    PermissionName        string  `json:"permission_name" binding:"required,min=1,max=100"`
    PermissionTarget      *string `json:"permission_target,omitempty"`
    PermissionDescription *string `json:"permission_description,omitempty"`
    IsActive              bool    `json:"is_active"`
}
```

### 2. 实现permissionService结构体

在同一个文件中实现权限服务：

```go
import (
    "context"
    "encoding/json"
    "fmt"
    "time"
    
    "github.com/redis/go-redis/v9"
    "yourproject/internal/pkg/model"
    "yourproject/internal/pkg/repository"
)

// permissionService 权限服务实现
type permissionService struct {
    permissionRepo           repository.PermissionRepository
    rolePermissionRepo        repository.RolePermissionRepository
    userGroupPermissionRepo   repository.UserGroupPermissionRepository
    redisClient               *redis.Client
    cacheExpiration           time.Duration
}

// NewPermissionService 创建权限服务实例
func NewPermissionService(
    permissionRepo repository.PermissionRepository,
    rolePermissionRepo repository.RolePermissionRepository,
    userGroupPermissionRepo repository.UserGroupPermissionRepository,
    redisClient *redis.Client,
) PermissionService {
    return &permissionService{
        permissionRepo:         permissionRepo,
        rolePermissionRepo:      rolePermissionRepo,
        userGroupPermissionRepo: userGroupPermissionRepo,
        redisClient:            redisClient,
        cacheExpiration:        1 * time.Hour, // 缓存1小时
    }
}
```

### 3. 实现权限CRUD方法

实现权限的基本CRUD操作（参考TASK004-04的实现方式）：

```go
// GetByID 根据ID获取权限
func (s *permissionService) GetByID(ctx context.Context, id int64) (*model.Permission, error) {
    if id <= 0 {
        return nil, fmt.Errorf("权限ID无效")
    }
    
    permission, err := s.permissionRepo.GetByID(ctx, id)
    if err != nil {
        return nil, fmt.Errorf("获取权限失败: %w", err)
    }
    
    return permission, nil
}

// GetAll 获取所有权限
func (s *permissionService) GetAll(ctx context.Context) ([]*model.Permission, error) {
    permissions, err := s.permissionRepo.GetAll(ctx)
    if err != nil {
        return nil, fmt.Errorf("获取权限列表失败: %w", err)
    }
    
    return permissions, nil
}

// Create 创建权限
func (s *permissionService) Create(ctx context.Context, req *CreatePermissionRequest) (*model.Permission, error) {
    // 输入验证
    if err := s.validateCreateRequest(req); err != nil {
        return nil, err
    }
    
    // 检查权限名称是否已存在
    existing, err := s.permissionRepo.GetByPermissionName(ctx, req.PermissionName)
    if err == nil && existing != nil {
        return nil, fmt.Errorf("权限名称已存在")
    }
    
    // 创建权限
    permission := &model.Permission{
        PermissionName:       req.PermissionName,
        PermissionTarget:     req.PermissionTarget,
        PermissionDescription: req.PermissionDescription,
        IsActive:             req.IsActive,
    }
    
    if err := s.permissionRepo.Create(ctx, permission); err != nil {
        return nil, fmt.Errorf("创建权限失败: %w", err)
    }
    
    return permission, nil
}

// Update 更新权限
func (s *permissionService) Update(ctx context.Context, id int64, req *UpdatePermissionRequest) (*model.Permission, error) {
    if id <= 0 {
        return nil, fmt.Errorf("权限ID无效")
    }
    
    // 输入验证
    if err := s.validateUpdateRequest(req); err != nil {
        return nil, err
    }
    
    // 检查权限是否存在
    permission, err := s.permissionRepo.GetByID(ctx, id)
    if err != nil {
        return nil, fmt.Errorf("权限不存在")
    }
    
    // 检查权限名称是否与其他权限重复
    existing, err := s.permissionRepo.GetByPermissionName(ctx, req.PermissionName)
    if err == nil && existing != nil && existing.ID != id {
        return nil, fmt.Errorf("权限名称已存在")
    }
    
    // 更新权限
    permission.PermissionName = req.PermissionName
    permission.PermissionTarget = req.PermissionTarget
    permission.PermissionDescription = req.PermissionDescription
    permission.IsActive = req.IsActive
    
    if err := s.permissionRepo.Update(ctx, permission); err != nil {
        return nil, fmt.Errorf("更新权限失败: %w", err)
    }
    
    // 清除相关缓存
    s.clearPermissionCache(ctx, id)
    
    return permission, nil
}

// Delete 删除权限
func (s *permissionService) Delete(ctx context.Context, id int64) error {
    if id <= 0 {
        return fmt.Errorf("权限ID无效")
    }
    
    // 检查权限是否存在
    permission, err := s.permissionRepo.GetByID(ctx, id)
    if err != nil {
        return fmt.Errorf("权限不存在")
    }
    
    // 删除权限
    if err := s.permissionRepo.Delete(ctx, id); err != nil {
        return fmt.Errorf("删除权限失败: %w", err)
    }
    
    // 清除相关缓存
    s.clearPermissionCache(ctx, id)
    
    return nil
}
```

### 4. 实现角色权限分配方法

```go
// AssignPermissionsToRole 为角色分配权限
func (s *permissionService) AssignPermissionsToRole(ctx context.Context, roleID int64, permissionIDs []int64) error {
    if roleID <= 0 {
        return fmt.Errorf("角色ID无效")
    }
    
    if len(permissionIDs) == 0 {
        return nil
    }
    
    // 验证权限是否存在
    for _, permissionID := range permissionIDs {
        _, err := s.permissionRepo.GetByID(ctx, permissionID)
        if err != nil {
            return fmt.Errorf("权限ID %d 不存在", permissionID)
        }
    }
    
    // 创建角色权限关联
    rolePermissions := make([]*model.RolePermission, 0, len(permissionIDs))
    for _, permissionID := range permissionIDs {
        rolePermissions = append(rolePermissions, &model.RolePermission{
            RoleID:       roleID,
            PermissionID: permissionID,
        })
    }
    
    if err := s.rolePermissionRepo.BatchCreate(ctx, rolePermissions); err != nil {
        return fmt.Errorf("分配权限失败: %w", err)
    }
    
    // 清除角色权限缓存
    s.clearRolePermissionCache(ctx, roleID)
    
    return nil
}

// RemovePermissionsFromRole 移除角色的权限
func (s *permissionService) RemovePermissionsFromRole(ctx context.Context, roleID int64, permissionIDs []int64) error {
    if roleID <= 0 {
        return fmt.Errorf("角色ID无效")
    }
    
    if len(permissionIDs) == 0 {
        return nil
    }
    
    if err := s.rolePermissionRepo.BatchDelete(ctx, roleID, permissionIDs); err != nil {
        return fmt.Errorf("移除权限失败: %w", err)
    }
    
    // 清除角色权限缓存
    s.clearRolePermissionCache(ctx, roleID)
    
    return nil
}

// GetRolePermissions 获取角色的权限列表
func (s *permissionService) GetRolePermissions(ctx context.Context, roleID int64) ([]*model.Permission, error) {
    if roleID <= 0 {
        return nil, fmt.Errorf("角色ID无效")
    }
    
    // 尝试从缓存获取
    permissions, err := s.getRolePermissionsFromCache(ctx, roleID)
    if err == nil && permissions != nil {
        return permissions, nil
    }
    
    // 从数据库获取
    rolePermissions, err := s.rolePermissionRepo.GetByRoleID(ctx, roleID)
    if err != nil {
        return nil, fmt.Errorf("获取角色权限失败: %w", err)
    }
    
    // 获取权限详情
    permissionIDs := make([]int64, 0, len(rolePermissions))
    for _, rp := range rolePermissions {
        permissionIDs = append(permissionIDs, rp.PermissionID)
    }
    
    permissions = make([]*model.Permission, 0, len(permissionIDs))
    for _, permissionID := range permissionIDs {
        permission, err := s.permissionRepo.GetByID(ctx, permissionID)
        if err != nil {
            continue // 跳过不存在的权限
        }
        permissions = append(permissions, permission)
    }
    
    // 缓存权限列表
    s.cacheRolePermissions(ctx, roleID, permissions)
    
    return permissions, nil
}
```

### 5. 实现用户组权限分配方法

实现方式与角色权限分配类似：

```go
// AssignPermissionsToUserGroup 为用户组分配权限
func (s *permissionService) AssignPermissionsToUserGroup(ctx context.Context, userGroupID int64, permissionIDs []int64) error {
    // 实现逻辑与AssignPermissionsToRole类似
}

// RemovePermissionsFromUserGroup 移除用户组的权限
func (s *permissionService) RemovePermissionsFromUserGroup(ctx context.Context, userGroupID int64, permissionIDs []int64) error {
    // 实现逻辑与RemovePermissionsFromRole类似
}

// GetUserGroupPermissions 获取用户组的权限列表
func (s *permissionService) GetUserGroupPermissions(ctx context.Context, userGroupID int64) ([]*model.Permission, error) {
    // 实现逻辑与GetRolePermissions类似
}
```

### 6. 实现权限缓存机制

```go
// getRolePermissionsFromCache 从缓存获取角色权限
func (s *permissionService) getRolePermissionsFromCache(ctx context.Context, roleID int64) ([]*model.Permission, error) {
    cacheKey := fmt.Sprintf("permission:role:%d", roleID)
    data, err := s.redisClient.Get(ctx, cacheKey).Result()
    if err == redis.Nil {
        return nil, nil
    }
    if err != nil {
        return nil, err
    }
    
    var permissions []*model.Permission
    if err := json.Unmarshal([]byte(data), &permissions); err != nil {
        return nil, err
    }
    
    return permissions, nil
}

// cacheRolePermissions 缓存角色权限
func (s *permissionService) cacheRolePermissions(ctx context.Context, roleID int64, permissions []*model.Permission) {
    cacheKey := fmt.Sprintf("permission:role:%d", roleID)
    data, err := json.Marshal(permissions)
    if err != nil {
        return
    }
    
    s.redisClient.Set(ctx, cacheKey, data, s.cacheExpiration)
}

// clearRolePermissionCache 清除角色权限缓存
func (s *permissionService) clearRolePermissionCache(ctx context.Context, roleID int64) {
    cacheKey := fmt.Sprintf("permission:role:%d", roleID)
    s.redisClient.Del(ctx, cacheKey)
}

// clearPermissionCache 清除权限相关缓存
func (s *permissionService) clearPermissionCache(ctx context.Context, permissionID int64) {
    // 清除所有相关的角色和用户组权限缓存
    // 这里可以通过扫描缓存键或使用其他方式实现
}
```

### 7. 实现输入验证方法

```go
// validateCreateRequest 验证创建请求
func (s *permissionService) validateCreateRequest(req *CreatePermissionRequest) error {
    if req == nil {
        return fmt.Errorf("请求参数不能为空")
    }
    if req.PermissionName == "" {
        return fmt.Errorf("权限名称不能为空")
    }
    if len(req.PermissionName) > 100 {
        return fmt.Errorf("权限名称长度不能超过100个字符")
    }
    return nil
}

// validateUpdateRequest 验证更新请求
func (s *permissionService) validateUpdateRequest(req *UpdatePermissionRequest) error {
    if req == nil {
        return fmt.Errorf("请求参数不能为空")
    }
    if req.PermissionName == "" {
        return fmt.Errorf("权限名称不能为空")
    }
    if len(req.PermissionName) > 100 {
        return fmt.Errorf("权限名称长度不能超过100个字符")
    }
    return nil
}
```

### 8. 代码规范要求

- 所有错误消息使用中文
- 实现输入验证和业务规则验证
- 使用context.Context传递上下文
- 实现权限缓存机制，提高查询性能
- 权限变更时清除相关缓存
- 所有方法都有清晰的注释（使用中文）

## 验收标准

1. **接口定义完整**
   - PermissionService接口包含所有必需的方法
   - 请求结构体定义完整，包含验证标签
   - 接口注释完整，使用中文

2. **业务逻辑实现完整**
   - 所有接口方法都有对应的实现
   - 实现了输入验证逻辑
   - 实现了权限分配和移除逻辑
   - 实现了权限查询逻辑
   - 实现了权限缓存机制

3. **缓存机制实现正确**
   - 权限查询时优先从缓存读取
   - 权限变更时清除相关缓存
   - 缓存键设计合理
   - 缓存过期时间配置合理

4. **代码规范符合要求**
   - 代码通过golangci-lint检查，无错误和警告
   - 代码注释完整，使用中文
   - 遵循Golang编码规范
   - 业务逻辑与数据访问层分离

5. **功能正确性**
   - 权限CRUD操作正确
   - 角色权限分配和移除正确
   - 用户组权限分配和移除正确
   - 权限查询正确（包括缓存）
   - 缓存清除机制正确

## 相关文件

- `internal/pkg/service/permission_service.go` - 权限服务接口和实现
- `internal/pkg/repository/permission_repository.go` - 权限仓储接口
- `internal/pkg/repository/role_permission_repository.go` - 角色权限关联仓储接口
- `internal/pkg/repository/user_group_permission_repository.go` - 用户组权限关联仓储接口
- `docs/TASKS/TASK004/TASK004-41.md` - 实现PermissionRepository接口任务文档
- `.cursor/rules/golang.mdc` - Golang编码规范
- `docs/TASKS/TASK004/TASK004.md` - 主任务文档

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.1.0  
**最后更新**: 2026-01-03 15:00:00 CST

