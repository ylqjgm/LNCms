# TASK004-21: 创建LevelHandler接口和实现

## 任务信息

**任务编号**: TASK004-21  
**父任务**: TASK004  
**任务名称**: 创建LevelHandler接口和实现  
**版本信息**: v1.1.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 15:25:47 CST

## 任务描述

创建LevelHandler接口和实现，提供等级的HTTP API处理。包括：1) 定义LevelHandler接口；2) 实现等级的创建、查询、更新、删除HTTP处理函数；3) 实现请求参数绑定和响应格式化（Envelope格式）。所有代码必须遵循Golang编码规范和API设计规范，错误消息使用中文。

## 依赖任务

- TASK004-19: 创建LevelService接口和实现

## 实现指南

### 1. 定义LevelHandler接口

在 `internal/pkg/handler/level_handler.go` 文件中定义接口：

```go
package handler

import (
    "github.com/gin-gonic/gin"
)

// LevelHandler 等级处理器接口
type LevelHandler interface {
    // GetByID 根据ID获取等级
    GetByID(c *gin.Context)
    
    // GetAll 获取所有等级
    GetAll(c *gin.Context)
    
    // Create 创建等级
    Create(c *gin.Context)
    
    // Update 更新等级
    Update(c *gin.Context)
    
    // Delete 删除等级
    Delete(c *gin.Context)
}
```

### 2. 实现levelHandler结构体

在同一个文件中实现等级处理器：

```go
import (
    "net/http"
    "strconv"
    
    "github.com/gin-gonic/gin"
    "yourproject/internal/pkg/service"
    "yourproject/pkg/response"
)

// levelHandler 等级处理器实现
type levelHandler struct {
    levelService service.LevelService
}

// NewLevelHandler 创建等级处理器实例
func NewLevelHandler(levelService service.LevelService) LevelHandler {
    return &levelHandler{
        levelService: levelService,
    }
}
```

### 3. 实现GetByID方法

实现根据ID获取等级的HTTP处理函数：

```go
// GetByID 根据ID获取等级
// @Summary 获取等级详情
// @Description 根据等级ID获取等级详细信息
// @Tags 等级管理
// @Accept json
// @Produce json
// @Param id path int true "等级ID"
// @Success 200 {object} response.Envelope "成功响应"
// @Failure 400 {object} response.Envelope "请求参数错误"
// @Failure 404 {object} response.Envelope "等级不存在"
// @Failure 500 {object} response.Envelope "服务器内部错误"
// @Router /api/v1/levels/{id} [get]
func (h *levelHandler) GetByID(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.Error(c, http.StatusBadRequest, "INVALID_PARAM", "等级ID无效", nil)
        return
    }
    
    level, err := h.levelService.GetByID(c.Request.Context(), id)
    if err != nil {
        response.Error(c, http.StatusNotFound, "LEVEL_NOT_FOUND", err.Error(), nil)
        return
    }
    
    response.Success(c, http.StatusOK, level)
}
```

### 4. 实现GetAll方法

实现获取所有等级的HTTP处理函数：

```go
// GetAll 获取所有等级
// @Summary 获取等级列表
// @Description 获取所有等级列表
// @Tags 等级管理
// @Accept json
// @Produce json
// @Success 200 {object} response.Envelope "成功响应"
// @Failure 500 {object} response.Envelope "服务器内部错误"
// @Router /api/v1/levels [get]
func (h *levelHandler) GetAll(c *gin.Context) {
    levels, err := h.levelService.GetAll(c.Request.Context())
    if err != nil {
        response.Error(c, http.StatusInternalServerError, "INTERNAL_ERROR", err.Error(), nil)
        return
    }
    
    response.Success(c, http.StatusOK, levels)
}
```

### 5. 实现Create方法

实现创建等级的HTTP处理函数：

```go
// Create 创建等级
// @Summary 创建等级
// @Description 创建新的等级
// @Tags 等级管理
// @Accept json
// @Produce json
// @Param request body service.CreateLevelRequest true "创建等级请求"
// @Success 201 {object} response.Envelope "创建成功"
// @Failure 400 {object} response.Envelope "请求参数错误"
// @Failure 409 {object} response.Envelope "等级名称已存在"
// @Failure 500 {object} response.Envelope "服务器内部错误"
// @Router /api/v1/levels [post]
func (h *levelHandler) Create(c *gin.Context) {
    var req service.CreateLevelRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.Error(c, http.StatusBadRequest, "INVALID_PARAM", "请求参数错误", nil)
        return
    }
    
    level, err := h.levelService.Create(c.Request.Context(), &req)
    if err != nil {
        if err.Error() == "等级名称已存在" {
            response.Error(c, http.StatusConflict, "LEVEL_NAME_EXISTS", err.Error(), nil)
            return
        }
        response.Error(c, http.StatusBadRequest, "CREATE_FAILED", err.Error(), nil)
        return
    }
    
    response.Success(c, http.StatusCreated, level)
}
```

### 6. 实现Update方法

实现更新等级的HTTP处理函数：

```go
// Update 更新等级
// @Summary 更新等级
// @Description 更新等级信息
// @Tags 等级管理
// @Accept json
// @Produce json
// @Param id path int true "等级ID"
// @Param request body service.UpdateLevelRequest true "更新等级请求"
// @Success 200 {object} response.Envelope "更新成功"
// @Failure 400 {object} response.Envelope "请求参数错误"
// @Failure 404 {object} response.Envelope "等级不存在"
// @Failure 500 {object} response.Envelope "服务器内部错误"
// @Router /api/v1/levels/{id} [put]
func (h *levelHandler) Update(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.Error(c, http.StatusBadRequest, "INVALID_PARAM", "等级ID无效", nil)
        return
    }
    
    var req service.UpdateLevelRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.Error(c, http.StatusBadRequest, "INVALID_PARAM", "请求参数错误", nil)
        return
    }
    
    level, err := h.levelService.Update(c.Request.Context(), id, &req)
    if err != nil {
        if err.Error() == "等级不存在" || err.Error() == "等级名称已存在" {
            response.Error(c, http.StatusBadRequest, "UPDATE_FAILED", err.Error(), nil)
            return
        }
        response.Error(c, http.StatusBadRequest, "UPDATE_FAILED", err.Error(), nil)
        return
    }
    
    response.Success(c, http.StatusOK, level)
}
```

### 7. 实现Delete方法

实现删除等级的HTTP处理函数：

```go
// Delete 删除等级
// @Summary 删除等级
// @Description 删除等级
// @Tags 等级管理
// @Accept json
// @Produce json
// @Param id path int true "等级ID"
// @Success 204 "删除成功"
// @Failure 400 {object} response.Envelope "请求参数错误"
// @Failure 404 {object} response.Envelope "等级不存在"
// @Failure 500 {object} response.Envelope "服务器内部错误"
// @Router /api/v1/levels/{id} [delete]
func (h *levelHandler) Delete(c *gin.Context) {
    idStr := c.Param("id")
    id, err := strconv.ParseInt(idStr, 10, 64)
    if err != nil {
        response.Error(c, http.StatusBadRequest, "INVALID_PARAM", "等级ID无效", nil)
        return
    }
    
    err = h.levelService.Delete(c.Request.Context(), id)
    if err != nil {
        if err.Error() == "等级不存在" {
            response.Error(c, http.StatusNotFound, "LEVEL_NOT_FOUND", err.Error(), nil)
            return
        }
        response.Error(c, http.StatusInternalServerError, "DELETE_FAILED", err.Error(), nil)
        return
    }
    
    c.Status(http.StatusNoContent)
}
```

### 8. 代码规范要求

- 所有错误消息使用中文
- 使用Envelope格式返回响应
- 使用适当的HTTP状态码
- 实现请求参数验证
- 使用Gin的ShouldBindJSON绑定JSON请求体
- 所有方法都有Swagger注释

## 验收标准

1. **接口定义完整**
   - LevelHandler接口包含所有必需的方法
   - 接口注释完整，使用中文

2. **HTTP处理函数实现完整**
   - 所有接口方法都有对应的HTTP处理函数实现
   - 正确解析路径参数和请求体
   - 正确调用Service层方法
   - 正确格式化响应（Envelope格式）

3. **错误处理正确**
   - 所有错误都使用中文错误消息
   - 使用适当的HTTP状态码
   - 错误响应符合Envelope格式

4. **API规范符合要求**
   - 遵循OpenAPI 3.1.1规范
   - 所有接口都有Swagger注释
   - 响应格式符合Envelope格式
   - 路径参数和请求体验证正确

5. **代码规范符合要求**
   - 代码通过golangci-lint检查
   - 代码注释完整，使用中文
   - 遵循Golang编码规范

## 相关文件

- `internal/pkg/handler/level_handler.go` - 等级处理器接口和实现
- `internal/pkg/service/level_service.go` - 等级服务接口
- `pkg/response/response.go` - 响应格式化工具
- `docs/TASKS/TASK004/TASK004-19.md` - 创建LevelService接口任务文档
- `.cursor/rules/api-design.mdc` - API设计规范
- `docs/TASKS/TASK004/TASK004.md` - 主任务文档

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.1.0  
**最后更新**: 2026-01-03 15:25:47 CST

