# TASK004-50: 实现权限检查逻辑

## 任务信息

**任务编号**: TASK004-50  
**父任务**: TASK004  
**任务名称**: 实现权限检查逻辑  
**版本信息**: 1.1.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 15:00:00 CST

## 任务描述

实现权限检查逻辑。包括：1) 实现Gin中间件函数；2) 实现基于角色的权限检查逻辑；3) 实现基于用户组的权限检查逻辑；4) 实现权限缓存查询逻辑（从Redis缓存读取权限数据）；5) 实现权限验证失败时的错误响应。所有代码必须遵循Golang编码规范，错误消息使用中文。

## 依赖任务

- TASK004-49: 创建权限检查中间件结构

## 实现指南

### 1. 实现RequirePermission方法

实现要求用户具有指定权限的中间件函数：

```go
// RequirePermission 要求用户具有指定权限
func (m *permissionMiddleware) RequirePermission(permissionName string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 获取用户上下文
        userCtx, err := GetUserContext(c)
        if err != nil {
            response.Error(c, http.StatusUnauthorized, "UNAUTHORIZED", "用户未登录", nil)
            c.Abort()
            return
        }
        
        // 检查权限
        hasPermission, err := m.checkPermission(c.Request.Context(), userCtx, permissionName)
        if err != nil {
            response.Error(c, http.StatusInternalServerError, "INTERNAL_ERROR", "权限检查失败", nil)
            c.Abort()
            return
        }
        
        if !hasPermission {
            response.Error(c, http.StatusForbidden, "FORBIDDEN", "权限不足", nil)
            c.Abort()
            return
        }
        
        c.Next()
    }
}
```

### 2. 实现checkPermission方法

实现权限检查核心逻辑：

```go
// checkPermission 检查用户是否具有指定权限
func (m *permissionMiddleware) checkPermission(ctx context.Context, userCtx *UserContext, permissionName string) (bool, error) {
    // 优先从缓存获取权限
    hasPermission, err := m.getPermissionFromCache(ctx, userCtx, permissionName)
    if err == nil {
        return hasPermission, nil
    }
    
    // 从数据库检查权限
    hasPermission = false
    
    // 检查角色权限
    if userCtx.RoleID != nil {
        rolePermissions, err := m.permissionService.GetRolePermissions(ctx, *userCtx.RoleID)
        if err == nil {
            for _, perm := range rolePermissions {
                if perm.PermissionName == permissionName && perm.IsActive {
                    hasPermission = true
                    break
                }
            }
        }
    }
    
    // 如果角色权限检查通过，缓存结果
    if hasPermission {
        m.cachePermission(ctx, userCtx, permissionName, true)
        return true, nil
    }
    
    // 检查用户组权限
    for _, userGroupID := range userCtx.UserGroupIDs {
        userGroupPermissions, err := m.permissionService.GetUserGroupPermissions(ctx, userGroupID)
        if err != nil {
            continue
        }
        
        for _, perm := range userGroupPermissions {
            if perm.PermissionName == permissionName && perm.IsActive {
                hasPermission = true
                break
            }
        }
        
        if hasPermission {
            break
        }
    }
    
    // 缓存权限检查结果
    m.cachePermission(ctx, userCtx, permissionName, hasPermission)
    
    return hasPermission, nil
}
```

### 3. 实现RequireAnyPermission方法

实现要求用户具有任意一个指定权限的中间件函数：

```go
// RequireAnyPermission 要求用户具有任意一个指定权限
func (m *permissionMiddleware) RequireAnyPermission(permissionNames ...string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 获取用户上下文
        userCtx, err := GetUserContext(c)
        if err != nil {
            response.Error(c, http.StatusUnauthorized, "UNAUTHORIZED", "用户未登录", nil)
            c.Abort()
            return
        }
        
        // 检查是否有任意一个权限
        hasAnyPermission := false
        for _, permissionName := range permissionNames {
            hasPermission, err := m.checkPermission(c.Request.Context(), userCtx, permissionName)
            if err != nil {
                continue
            }
            if hasPermission {
                hasAnyPermission = true
                break
            }
        }
        
        if !hasAnyPermission {
            response.Error(c, http.StatusForbidden, "FORBIDDEN", "权限不足", nil)
            c.Abort()
            return
        }
        
        c.Next()
    }
}
```

### 4. 实现RequireAllPermissions方法

实现要求用户具有所有指定权限的中间件函数：

```go
// RequireAllPermissions 要求用户具有所有指定权限
func (m *permissionMiddleware) RequireAllPermissions(permissionNames ...string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 获取用户上下文
        userCtx, err := GetUserContext(c)
        if err != nil {
            response.Error(c, http.StatusUnauthorized, "UNAUTHORIZED", "用户未登录", nil)
            c.Abort()
            return
        }
        
        // 检查是否具有所有权限
        missingPermissions := make([]string, 0)
        for _, permissionName := range permissionNames {
            hasPermission, err := m.checkPermission(c.Request.Context(), userCtx, permissionName)
            if err != nil || !hasPermission {
                missingPermissions = append(missingPermissions, permissionName)
            }
        }
        
        if len(missingPermissions) > 0 {
            response.Error(c, http.StatusForbidden, "FORBIDDEN", fmt.Sprintf("缺少权限: %v", missingPermissions), nil)
            c.Abort()
            return
        }
        
        c.Next()
    }
}
```

### 5. 实现RequireRole方法

实现要求用户具有指定角色的中间件函数：

```go
// RequireRole 要求用户具有指定角色
func (m *permissionMiddleware) RequireRole(roleName string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 获取用户上下文
        userCtx, err := GetUserContext(c)
        if err != nil {
            response.Error(c, http.StatusUnauthorized, "UNAUTHORIZED", "用户未登录", nil)
            c.Abort()
            return
        }
        
        // 检查角色（这里需要根据实际的角色获取逻辑实现）
        if userCtx.RoleID == nil {
            response.Error(c, http.StatusForbidden, "FORBIDDEN", "用户没有角色", nil)
            c.Abort()
            return
        }
        
        // 从数据库或缓存获取角色信息并检查
        // 这里需要根据实际的角色服务实现
        // hasRole := m.checkRole(c.Request.Context(), userCtx, roleName)
        // if !hasRole {
        //     response.Error(c, http.StatusForbidden, "FORBIDDEN", "角色不足", nil)
        //     c.Abort()
        //     return
        // }
        
        c.Next()
    }
}
```

### 6. 实现RequireUserGroup方法

实现要求用户属于指定用户组的中间件函数：

```go
// RequireUserGroup 要求用户属于指定用户组
func (m *permissionMiddleware) RequireUserGroup(userGroupName string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 获取用户上下文
        userCtx, err := GetUserContext(c)
        if err != nil {
            response.Error(c, http.StatusUnauthorized, "UNAUTHORIZED", "用户未登录", nil)
            c.Abort()
            return
        }
        
        // 检查用户组（这里需要根据实际的用户组获取逻辑实现）
        if len(userCtx.UserGroupIDs) == 0 {
            response.Error(c, http.StatusForbidden, "FORBIDDEN", "用户不属于任何用户组", nil)
            c.Abort()
            return
        }
        
        // 从数据库或缓存获取用户组信息并检查
        // 这里需要根据实际的用户组服务实现
        // inUserGroup := m.checkUserGroup(c.Request.Context(), userCtx, userGroupName)
        // if !inUserGroup {
        //     response.Error(c, http.StatusForbidden, "FORBIDDEN", "用户组不足", nil)
        //     c.Abort()
        //     return
        // }
        
        c.Next()
    }
}
```

### 7. 实现权限缓存方法

实现权限缓存相关方法：

```go
// getPermissionFromCache 从缓存获取权限检查结果
func (m *permissionMiddleware) getPermissionFromCache(ctx context.Context, userCtx *UserContext, permissionName string) (bool, error) {
    // 构建缓存键：permission:check:user:{user_id}:permission:{permission_name}
    cacheKey := fmt.Sprintf("permission:check:user:%d:permission:%s", userCtx.UserID, permissionName)
    
    data, err := m.redisClient.Get(ctx, cacheKey).Result()
    if err == redis.Nil {
        return false, nil
    }
    if err != nil {
        return false, err
    }
    
    hasPermission := data == "true"
    return hasPermission, nil
}

// cachePermission 缓存权限检查结果
func (m *permissionMiddleware) cachePermission(ctx context.Context, userCtx *UserContext, permissionName string, hasPermission bool) {
    cacheKey := fmt.Sprintf("permission:check:user:%d:permission:%s", userCtx.UserID, permissionName)
    value := "false"
    if hasPermission {
        value = "true"
    }
    
    m.redisClient.Set(ctx, cacheKey, value, m.cacheExpiration)
}

// clearUserPermissionCache 清除用户权限缓存
func (m *permissionMiddleware) clearUserPermissionCache(ctx context.Context, userID int64) {
    // 清除用户的所有权限检查缓存
    pattern := fmt.Sprintf("permission:check:user:%d:*", userID)
    keys, err := m.redisClient.Keys(ctx, pattern).Result()
    if err != nil {
        return
    }
    
    if len(keys) > 0 {
        m.redisClient.Del(ctx, keys...)
    }
}
```

### 8. 代码规范要求

- 所有错误消息使用中文
- 使用Envelope格式返回错误响应
- 使用适当的HTTP状态码（401未授权，403禁止访问）
- 权限检查失败时使用c.Abort()终止请求
- 权限检查通过时使用c.Next()继续处理
- 所有方法都有清晰的注释（使用中文）

## 验收标准

1. **中间件函数实现完整**
   - 所有接口方法都有对应的实现
   - 中间件函数正确使用Gin的上下文
   - 正确调用Service层方法进行权限检查

2. **权限检查逻辑正确**
   - 基于角色的权限检查正确
   - 基于用户组的权限检查正确
   - 多权限检查逻辑正确（任意一个、所有）

3. **缓存机制实现正确**
   - 权限检查结果正确缓存
   - 缓存键设计合理
   - 缓存读取和写入正确

4. **错误处理正确**
   - 所有错误都使用中文错误消息
   - 使用适当的HTTP状态码
   - 错误响应符合Envelope格式

5. **代码规范符合要求**
   - 代码通过golangci-lint检查，无错误和警告
   - 代码注释完整，使用中文
   - 遵循Golang编码规范

## 相关文件

- `internal/pkg/middleware/permission_middleware.go` - 权限检查中间件实现
- `internal/pkg/service/permission_service.go` - 权限服务接口
- `pkg/response/response.go` - 响应格式化工具
- `docs/TASKS/TASK004/TASK004-49.md` - 创建权限检查中间件结构任务文档
- `.cursor/rules/golang.mdc` - Golang编码规范
- `docs/TASKS/TASK004/TASK004.md` - 主任务文档

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.1.0  
**最后更新**: 2026-01-03 15:00:00 CST

