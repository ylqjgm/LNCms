# TASK004-20: 编写LevelService单元测试

## 任务信息

**任务编号**: TASK004-20  
**父任务**: TASK004  
**任务名称**: 编写LevelService单元测试  
**版本信息**: v1.1.0  
**当前状态**: 计划中  
**创建时间**: 2026-01-03 14:54:20 CST

## 任务描述

编写等级服务层单元测试。包括：1) 测试LevelService的所有方法；2) 测试输入验证功能；3) 测试等级达成条件验证逻辑；4) 使用Mock Repository进行测试；5) 确保测试覆盖率达标。所有测试用例描述和错误消息必须使用中文。

## 依赖任务

- TASK004-19: 创建LevelService接口和实现

## 实现指南

### 1. 设置测试环境

在 `internal/pkg/service/level_service_test.go` 文件中创建测试文件：

```go
package service

import (
    "context"
    "fmt"
    "testing"
    
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
    "github.com/stretchr/testify/require"
    "yourproject/internal/pkg/model"
    "yourproject/internal/pkg/repository"
)

// MockLevelRepository Mock等级仓储
type MockLevelRepository struct {
    mock.Mock
}

func (m *MockLevelRepository) GetByID(ctx context.Context, id int64) (*model.Level, error) {
    args := m.Called(ctx, id)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*model.Level), args.Error(1)
}

func (m *MockLevelRepository) GetAll(ctx context.Context) ([]*model.Level, error) {
    args := m.Called(ctx)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).([]*model.Level), args.Error(1)
}

func (m *MockLevelRepository) Create(ctx context.Context, level *model.Level) error {
    args := m.Called(ctx, level)
    return args.Error(0)
}

func (m *MockLevelRepository) Update(ctx context.Context, level *model.Level) error {
    args := m.Called(ctx, level)
    return args.Error(0)
}

func (m *MockLevelRepository) Delete(ctx context.Context, id int64) error {
    args := m.Called(ctx, id)
    return args.Error(0)
}

func (m *MockLevelRepository) GetByName(ctx context.Context, name string) (*model.Level, error) {
    args := m.Called(ctx, name)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*model.Level), args.Error(1)
}
```

### 2. 测试GetByID方法

测试GetByID方法的正常情况和异常情况：

```go
func TestLevelService_GetByID(t *testing.T) {
    mockRepo := new(MockLevelRepository)
    service := NewLevelService(mockRepo)
    ctx := context.Background()
    
    tests := []struct {
        name    string
        id      int64
        setup   func()
        wantErr bool
        errMsg  string
    }{
        {
            name: "正常情况：获取存在的等级",
            id:   1,
            setup: func() {
                mockRepo.On("GetByID", ctx, int64(1)).Return(&model.Level{
                    ID:   1,
                    Name: "测试等级",
                }, nil)
            },
            wantErr: false,
        },
        {
            name: "异常情况：ID无效",
            id:   0,
            setup: func() {
                // 不需要设置Mock，因为会在验证阶段失败
            },
            wantErr: true,
            errMsg:  "等级ID无效",
        },
        {
            name: "异常情况：等级不存在",
            id:   999,
            setup: func() {
                mockRepo.On("GetByID", ctx, int64(999)).Return(nil, fmt.Errorf("等级不存在"))
            },
            wantErr: true,
            errMsg:  "获取等级失败",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            mockRepo.ExpectedCalls = nil
            mockRepo.Calls = nil
            if tt.setup != nil {
                tt.setup()
            }
            
            got, err := service.GetByID(ctx, tt.id)
            if tt.wantErr {
                assert.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
                assert.Nil(t, got)
            } else {
                assert.NoError(t, err)
                assert.NotNil(t, got)
                assert.Equal(t, tt.id, got.ID)
            }
            mockRepo.AssertExpectations(t)
        })
    }
}
```

### 3. 测试GetAll方法

测试GetAll方法：

```go
func TestLevelService_GetAll(t *testing.T) {
    mockRepo := new(MockLevelRepository)
    service := NewLevelService(mockRepo)
    ctx := context.Background()
    
    tests := []struct {
        name    string
        setup   func()
        wantErr bool
    }{
        {
            name: "正常情况：获取所有等级",
            setup: func() {
                mockRepo.On("GetAll", ctx).Return([]*model.Level{
                    {ID: 1, Name: "等级1"},
                    {ID: 2, Name: "等级2"},
                }, nil)
            },
            wantErr: false,
        },
        {
            name: "异常情况：查询失败",
            setup: func() {
                mockRepo.On("GetAll", ctx).Return(nil, fmt.Errorf("数据库错误"))
            },
            wantErr: true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            mockRepo.ExpectedCalls = nil
            mockRepo.Calls = nil
            if tt.setup != nil {
                tt.setup()
            }
            
            got, err := service.GetAll(ctx)
            if tt.wantErr {
                assert.Error(t, err)
                assert.Nil(t, got)
            } else {
                assert.NoError(t, err)
                assert.NotNil(t, got)
                assert.Greater(t, len(got), 0)
            }
            mockRepo.AssertExpectations(t)
        })
    }
}
```

### 4. 测试Create方法（包括等级达成条件验证）

测试Create方法，特别关注等级达成条件验证：

```go
func TestLevelService_Create(t *testing.T) {
    mockRepo := new(MockLevelRepository)
    service := NewLevelService(mockRepo)
    ctx := context.Background()
    
    tests := []struct {
        name    string
        req     *CreateLevelRequest
        setup   func()
        wantErr bool
        errMsg  string
    }{
        {
            name: "正常情况：创建等级（积分条件）",
            req: &CreateLevelRequest{
                Name:        "新等级",
                Description: stringPtr("新等级描述"),
                Conditions: model.LevelConditions{
                    ConditionType:  "points",
                    ConditionValue: 1000,
                },
            },
            setup: func() {
                mockRepo.On("GetByName", ctx, "新等级").Return(nil, fmt.Errorf("等级不存在"))
                mockRepo.On("Create", ctx, mock.AnythingOfType("*model.Level")).Return(nil)
            },
            wantErr: false,
        },
        {
            name: "异常情况：请求参数为空",
            req:  nil,
            setup: func() {
                // 不需要设置Mock
            },
            wantErr: true,
            errMsg:  "请求参数不能为空",
        },
        {
            name: "异常情况：等级名称为空",
            req: &CreateLevelRequest{
                Name: "",
            },
            setup: func() {
                // 不需要设置Mock
            },
            wantErr: true,
            errMsg:  "等级名称不能为空",
        },
        {
            name: "异常情况：等级名称已存在",
            req: &CreateLevelRequest{
                Name: "已存在的等级",
                Conditions: model.LevelConditions{
                    ConditionType:  "points",
                    ConditionValue: 1000,
                },
            },
            setup: func() {
                mockRepo.On("GetByName", ctx, "已存在的等级").Return(&model.Level{
                    ID:   1,
                    Name: "已存在的等级",
                }, nil)
            },
            wantErr: true,
            errMsg:  "等级名称已存在",
        },
        {
            name: "异常情况：等级达成条件类型无效",
            req: &CreateLevelRequest{
                Name: "新等级",
                Conditions: model.LevelConditions{
                    ConditionType:  "invalid_type",
                    ConditionValue: 1000,
                },
            },
            setup: func() {
                // 不需要设置Mock
            },
            wantErr: true,
            errMsg:  "等级达成条件类型无效",
        },
        {
            name: "异常情况：等级达成条件值为负数",
            req: &CreateLevelRequest{
                Name: "新等级",
                Conditions: model.LevelConditions{
                    ConditionType:  "points",
                    ConditionValue: -1,
                },
            },
            setup: func() {
                // 不需要设置Mock
            },
            wantErr: true,
            errMsg:  "等级达成条件值不能为负数",
        },
        {
            name: "异常情况：等级达成条件值超过最大值",
            req: &CreateLevelRequest{
                Name: "新等级",
                Conditions: model.LevelConditions{
                    ConditionType:  "points",
                    ConditionValue: 1000000000,
                },
            },
            setup: func() {
                // 不需要设置Mock
            },
            wantErr: true,
            errMsg:  "等级达成条件值不能超过999999999",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            mockRepo.ExpectedCalls = nil
            mockRepo.Calls = nil
            if tt.setup != nil {
                tt.setup()
            }
            
            got, err := service.Create(ctx, tt.req)
            if tt.wantErr {
                assert.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
                assert.Nil(t, got)
            } else {
                assert.NoError(t, err)
                assert.NotNil(t, got)
                assert.Equal(t, tt.req.Name, got.Name)
                assert.Equal(t, tt.req.Conditions.ConditionType, got.Conditions.ConditionType)
                assert.Equal(t, tt.req.Conditions.ConditionValue, got.Conditions.ConditionValue)
            }
            mockRepo.AssertExpectations(t)
        })
    }
}
```

### 5. 测试Update方法（包括等级达成条件验证）

测试Update方法，特别关注等级达成条件验证：

```go
func TestLevelService_Update(t *testing.T) {
    mockRepo := new(MockLevelRepository)
    service := NewLevelService(mockRepo)
    ctx := context.Background()
    
    tests := []struct {
        name    string
        id      int64
        req     *UpdateLevelRequest
        setup   func()
        wantErr bool
        errMsg  string
    }{
        {
            name: "正常情况：更新等级（包括等级达成条件）",
            id:   1,
            req: &UpdateLevelRequest{
                Name:        "更新后的等级名",
                Description: stringPtr("更新后的描述"),
                Conditions: model.LevelConditions{
                    ConditionType:  "currency",
                    ConditionValue: 2000,
                },
            },
            setup: func() {
                mockRepo.On("GetByID", ctx, int64(1)).Return(&model.Level{
                    ID:   1,
                    Name: "原始等级名",
                }, nil)
                mockRepo.On("GetByName", ctx, "更新后的等级名").Return(nil, fmt.Errorf("等级不存在"))
                mockRepo.On("Update", ctx, mock.AnythingOfType("*model.Level")).Return(nil)
            },
            wantErr: false,
        },
        {
            name: "异常情况：ID无效",
            id:   0,
            req: &UpdateLevelRequest{
                Name: "等级名",
                Conditions: model.LevelConditions{
                    ConditionType:  "points",
                    ConditionValue: 1000,
                },
            },
            setup: func() {
                // 不需要设置Mock
            },
            wantErr: true,
            errMsg:  "等级ID无效",
        },
        {
            name: "异常情况：等级不存在",
            id:   999,
            req: &UpdateLevelRequest{
                Name: "等级名",
                Conditions: model.LevelConditions{
                    ConditionType:  "points",
                    ConditionValue: 1000,
                },
            },
            setup: func() {
                mockRepo.On("GetByID", ctx, int64(999)).Return(nil, fmt.Errorf("等级不存在"))
            },
            wantErr: true,
            errMsg:  "等级不存在",
        },
        {
            name: "异常情况：等级名称已存在",
            id:   1,
            req: &UpdateLevelRequest{
                Name: "已存在的等级名",
                Conditions: model.LevelConditions{
                    ConditionType:  "points",
                    ConditionValue: 1000,
                },
            },
            setup: func() {
                mockRepo.On("GetByID", ctx, int64(1)).Return(&model.Level{
                    ID:   1,
                    Name: "原始等级名",
                }, nil)
                mockRepo.On("GetByName", ctx, "已存在的等级名").Return(&model.Level{
                    ID:   2,
                    Name: "已存在的等级名",
                }, nil)
            },
            wantErr: true,
            errMsg:  "等级名称已存在",
        },
        {
            name: "异常情况：等级达成条件类型无效",
            id:   1,
            req: &UpdateLevelRequest{
                Name: "等级名",
                Conditions: model.LevelConditions{
                    ConditionType:  "invalid_type",
                    ConditionValue: 1000,
                },
            },
            setup: func() {
                mockRepo.On("GetByID", ctx, int64(1)).Return(&model.Level{
                    ID:   1,
                    Name: "原始等级名",
                }, nil)
            },
            wantErr: true,
            errMsg:  "等级达成条件类型无效",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            mockRepo.ExpectedCalls = nil
            mockRepo.Calls = nil
            if tt.setup != nil {
                tt.setup()
            }
            
            got, err := service.Update(ctx, tt.id, tt.req)
            if tt.wantErr {
                assert.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
                assert.Nil(t, got)
            } else {
                assert.NoError(t, err)
                assert.NotNil(t, got)
                assert.Equal(t, tt.req.Name, got.Name)
                assert.Equal(t, tt.req.Conditions.ConditionType, got.Conditions.ConditionType)
                assert.Equal(t, tt.req.Conditions.ConditionValue, got.Conditions.ConditionValue)
            }
            mockRepo.AssertExpectations(t)
        })
    }
}
```

### 6. 测试Delete方法

测试Delete方法：

```go
func TestLevelService_Delete(t *testing.T) {
    mockRepo := new(MockLevelRepository)
    service := NewLevelService(mockRepo)
    ctx := context.Background()
    
    tests := []struct {
        name    string
        id      int64
        setup   func()
        wantErr bool
        errMsg  string
    }{
        {
            name: "正常情况：删除等级",
            id:   1,
            setup: func() {
                mockRepo.On("GetByID", ctx, int64(1)).Return(&model.Level{
                    ID:   1,
                    Name: "待删除等级",
                }, nil)
                mockRepo.On("Delete", ctx, int64(1)).Return(nil)
            },
            wantErr: false,
        },
        {
            name: "异常情况：ID无效",
            id:   0,
            setup: func() {
                // 不需要设置Mock
            },
            wantErr: true,
            errMsg:  "等级ID无效",
        },
        {
            name: "异常情况：等级不存在",
            id:   999,
            setup: func() {
                mockRepo.On("GetByID", ctx, int64(999)).Return(nil, fmt.Errorf("等级不存在"))
            },
            wantErr: true,
            errMsg:  "等级不存在",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            mockRepo.ExpectedCalls = nil
            mockRepo.Calls = nil
            if tt.setup != nil {
                tt.setup()
            }
            
            err := service.Delete(ctx, tt.id)
            if tt.wantErr {
                assert.Error(t, err)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
            } else {
                assert.NoError(t, err)
            }
            mockRepo.AssertExpectations(t)
        })
    }
}

// stringPtr 辅助函数：将字符串转换为指针
func stringPtr(s string) *string {
    return &s
}
```

### 7. 运行测试和覆盖率检查

```bash
# 运行测试
go test ./internal/pkg/service -v -run TestLevelService

# 生成覆盖率报告
go test ./internal/pkg/service -coverprofile=coverage.out -run TestLevelService

# 查看覆盖率报告
go tool cover -html=coverage.out

# 检查覆盖率是否达标（应达到80%以上）
go tool cover -func=coverage.out | grep level_service
```

## 验收标准

1. **测试覆盖完整**
   - 测试覆盖LevelService的所有方法：GetByID、GetAll、Create、Update、Delete
   - 每个方法都测试了正常情况和异常情况
   - 测试覆盖输入验证功能
   - 特别测试了等级达成条件验证逻辑

2. **测试用例质量**
   - 使用表驱动测试（table-driven tests）处理多个测试场景
   - 测试用例名称清晰描述测试场景（使用中文）
   - 测试用例独立，不依赖执行顺序
   - 使用Mock Repository进行测试

3. **等级达成条件验证测试**
   - 测试条件类型验证（有效类型、无效类型）
   - 测试条件值验证（有效值、负数、超过最大值）
   - 测试条件值的边界情况

4. **Mock使用正确**
   - 正确创建Mock Repository
   - 正确设置Mock期望
   - 正确验证Mock调用
   - 每个测试后清理Mock状态

5. **断言和验证**
   - 使用testify/assert和testify/require进行断言
   - 验证返回值正确性
   - 验证错误消息正确性（使用中文）
   - 验证Mock调用次数和参数

6. **代码覆盖率达标**
   - 测试覆盖率应达到80%以上
   - 关键代码路径都有测试覆盖
   - 错误处理路径都有测试覆盖
   - 等级达成条件验证逻辑都有测试覆盖

7. **代码规范符合要求**
   - 测试代码通过golangci-lint检查，无错误和警告
   - 测试用例描述和错误消息使用中文
   - 遵循Golang单元测试规范
   - 测试代码清晰、易读、易维护

## 相关文件

- `internal/pkg/service/level_service_test.go` - 等级服务单元测试文件
- `internal/pkg/service/level_service.go` - 等级服务接口和实现
- `docs/TASKS/TASK004/TASK004-19.md` - 创建LevelService接口任务文档
- `.cursor/rules/testing.mdc` - 单元测试规范
- `docs/TASKS/TASK004/TASK004.md` - 主任务文档

## Git 提交信息任务

任务完成后，需要生成 Git 提交信息。请根据实际修改内容生成合适的提交信息。

---

**文档版本**: 1.1.0  
**最后更新**: 2026-01-03 14:54:20 CST

