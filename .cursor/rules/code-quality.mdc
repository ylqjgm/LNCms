---
globs: ["**/*.go"]
description: "Golang 代码质量规范规则 - 定义代码质量指标、测试覆盖率、代码审查标准等质量要求，确保代码的高质量和高可维护性"
alwaysApply: true
---

# Golang 代码质量规范

本文档定义了项目中的 Golang 代码质量规范，包括代码质量指标、测试覆盖率、代码审查标准、性能要求等，确保代码的高质量和高可维护性。

**重要提示：代码质量是项目长期维护的基础，所有代码都必须符合本规范要求。在代码审查和 CI/CD 流程中，不符合质量规范的代码不应合并到主分支。**

## 代码质量指标

### 圈复杂度（Cyclomatic Complexity）

- **函数圈复杂度应不超过 15**，理想情况下应控制在 10 以内
- 圈复杂度超过 15 的函数必须重构，拆分为多个小函数
- 使用 `gocyclo` 工具检测圈复杂度

```go
// 好的做法：低圈复杂度
func ValidateUser(user *User) error {
    if user == nil {
        return errors.New("用户不能为空")
    }
    if err := validateUsername(user.Username); err != nil {
        return err
    }
    if err := validateEmail(user.Email); err != nil {
        return err
    }
    return nil
}

// 不好的做法：高圈复杂度
func BadValidateUser(user *User) error {
    if user == nil {
        return errors.New("用户不能为空")
    }
    if len(user.Username) < 3 || len(user.Username) > 20 {
        return errors.New("用户名长度错误")
    }
    matched, _ := regexp.MatchString(`^[a-zA-Z0-9_]+$`, user.Username)
    if !matched {
        return errors.New("用户名格式错误")
    }
    if !strings.Contains(user.Email, "@") {
        return errors.New("邮箱格式错误")
    }
    // ... 更多嵌套的条件判断
    return nil
}
```

### 代码重复率

- **代码重复率应低于 5%**
- 重复代码超过 3 行的，必须提取为公共函数或方法
- 使用 `gocopy` 或 `dupl` 工具检测代码重复
- 通过函数提取、接口抽象等方式减少重复代码

```go
// 好的做法：提取公共逻辑
func validateStringLength(s string, min, max int, fieldName string) error {
    if len(s) < min || len(s) > max {
        return fmt.Errorf("%s长度必须在%d-%d个字符之间", fieldName, min, max)
    }
    return nil
}

func ValidateUsername(username string) error {
    return validateStringLength(username, 3, 20, "用户名")
}

func ValidatePassword(password string) error {
    return validateStringLength(password, 8, 128, "密码")
}

// 不好的做法：重复代码
func BadValidateUsername(username string) error {
    if len(username) < 3 || len(username) > 20 {
        return errors.New("用户名长度必须在3-20个字符之间")
    }
    return nil
}

func BadValidatePassword(password string) error {
    if len(password) < 8 || len(password) > 128 {
        return errors.New("密码长度必须在8-128个字符之间")
    }
    return nil
}
```

### 函数长度

- **单个函数不应超过 50 行**，复杂函数不应超过 100 行
- 函数应该专注于单一职责，如果函数过长，应拆分为多个小函数
- 通过提取子函数、使用策略模式等方式简化复杂函数

```go
// 好的做法：短函数，职责单一
func ProcessUser(user *User) error {
    if err := validateUser(user); err != nil {
        return err
    }
    if err := saveUser(user); err != nil {
        return err
    }
    if err := sendWelcomeEmail(user); err != nil {
        log.Printf("发送欢迎邮件失败: %v", err)
        // 不中断流程，仅记录错误
    }
    return nil
}

func validateUser(user *User) error {
    // 验证逻辑
    return nil
}

func saveUser(user *User) error {
    // 保存逻辑
    return nil
}

func sendWelcomeEmail(user *User) error {
    // 发送邮件逻辑
    return nil
}
```

### 文件长度

- **单个文件不应超过 1000 行**
- 如果文件过长，应考虑按功能拆分为多个文件
- 相关功能可以放在同一个包的不同文件中

## 测试覆盖率

### 覆盖率要求

- **核心业务逻辑代码覆盖率应达到 80% 以上**
- **关键功能代码覆盖率应达到 90% 以上**
- **工具类和辅助函数覆盖率应达到 70% 以上**
- 使用 `go test -cover` 或 `go test -coverprofile` 生成覆盖率报告

```bash
# 生成覆盖率报告
go test -coverprofile=coverage.out ./...

# 查看覆盖率报告
go tool cover -html=coverage.out

# 检查覆盖率是否达标
go test -cover ./...
```

### 测试用例要求

- **每个导出的函数都应该有对应的测试用例**
- **测试用例应该覆盖正常情况、边界情况和异常情况**
- 使用表驱动测试（table-driven tests）处理多个测试场景
- 测试用例应该独立，不依赖执行顺序
- 使用 `t.Helper()` 标记辅助函数

```go
// 好的做法：完整的测试用例
func TestValidateUsername(t *testing.T) {
    tests := []struct {
        name    string
        input   string
        wantErr bool
        errMsg  string
    }{
        {
            name:    "有效用户名",
            input:   "validuser",
            wantErr: false,
        },
        {
            name:    "用户名过短",
            input:   "ab",
            wantErr: true,
            errMsg:  "用户名长度必须在3-20个字符之间",
        },
        {
            name:    "用户名过长",
            input:   strings.Repeat("a", 21),
            wantErr: true,
            errMsg:  "用户名长度必须在3-20个字符之间",
        },
        {
            name:    "包含非法字符",
            input:   "user@name",
            wantErr: true,
            errMsg:  "用户名只能包含字母、数字和下划线",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := ValidateUsername(tt.input)
            if (err != nil) != tt.wantErr {
                t.Errorf("ValidateUsername() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if tt.wantErr && err != nil && err.Error() != tt.errMsg {
                t.Errorf("ValidateUsername() error = %v, want %v", err.Error(), tt.errMsg)
            }
        })
    }
}
```

### 性能测试

- **对于性能关键的函数，应编写基准测试（Benchmark）**
- 使用 `go test -bench` 运行基准测试
- 基准测试结果应该记录在代码注释中，便于性能回归检测

```go
// 基准测试示例
func BenchmarkValidateUsername(b *testing.B) {
    username := "validusername123"
    for i := 0; i < b.N; i++ {
        _ = ValidateUsername(username)
    }
}

// 对比测试
func BenchmarkValidateUsernameRegex(b *testing.B) {
    username := "validusername123"
    pattern := regexp.MustCompile(`^[a-zA-Z0-9_]+$`)
    for i := 0; i < b.N; i++ {
        _ = pattern.MatchString(username)
    }
}
```

## 代码审查标准

### 审查检查清单

代码审查时，应检查以下项目：

1. **功能正确性**
   - 代码是否实现了需求
   - 是否处理了所有边界情况
   - 是否处理了错误情况

2. **代码质量**
   - 是否符合编码规范
   - 函数是否简洁、职责单一
   - 是否有重复代码
   - 圈复杂度是否在合理范围内

3. **测试覆盖**
   - 是否有足够的测试用例
   - 测试用例是否覆盖了所有场景
   - 测试用例是否易于理解和维护

4. **性能**
   - 是否有明显的性能问题
   - 是否有不必要的内存分配
   - 是否有性能优化的空间

5. **安全性**
   - 是否有安全漏洞
   - 是否正确处理用户输入
   - 是否正确处理敏感数据

6. **可维护性**
   - 代码是否易于理解
   - 是否有清晰的注释
   - 是否有必要的文档

### 审查流程

1. **提交前自检**：开发者提交代码前，应自行检查代码质量
2. **自动化检查**：CI/CD 流程应自动运行代码质量检查工具
3. **同行评审**：至少需要一名其他开发者进行代码审查
4. **质量门禁**：不符合质量标准的代码不应合并到主分支

## 代码质量工具

### 必须使用的工具

- **gofmt**：代码格式化（必须使用）
- **go vet**：静态代码分析，检查常见错误
- **golangci-lint**：综合代码检查工具（推荐配置）
- **gocyclo**：圈复杂度检查
- **go test**：单元测试和覆盖率检查

### 推荐使用的工具

- **staticcheck**：高级静态分析工具
- **errcheck**：检查未处理的错误
- **ineffassign**：检查无效赋值
- **misspell**：检查拼写错误
- **unused**：检查未使用的代码

### 工具配置示例

```yaml
# .golangci.yml 示例配置
linters:
  enable:
    - gofmt
    - goimports
    - govet
    - errcheck
    - staticcheck
    - gocyclo
    - dupl
    - ineffassign
    - misspell
    - unused

linters-settings:
  gocyclo:
    min-complexity: 15
  dupl:
    threshold: 100
  errcheck:
    check-type-assertions: true
    check-blank: true

issues:
  exclude-use-default: false
  max-issues-per-linter: 0
  max-same-issues: 0

run:
  timeout: 5m
  tests: true
  skip-dirs:
    - vendor
    - testdata
```

### 在 CI/CD 中集成

```yaml
# GitHub Actions 示例
name: Code Quality

on: [push, pull_request]

jobs:
  quality:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'
      
      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v3
        with:
          version: latest
      
      - name: Run tests with coverage
        run: |
          go test -coverprofile=coverage.out ./...
          go tool cover -func=coverage.out
      
      - name: Check coverage threshold
        run: |
          coverage=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//')
          if (( $(echo "$coverage < 80" | bc -l) )); then
            echo "Coverage $coverage% is below 80% threshold"
            exit 1
          fi
```

## 性能要求

### 响应时间要求

- **API 接口响应时间应控制在 500ms 以内**（正常情况）
- **数据库查询响应时间应控制在 100ms 以内**
- **缓存查询响应时间应控制在 10ms 以内**
- 对于耗时操作，应使用异步处理或后台任务

### 资源使用要求

- **内存使用应合理**，避免内存泄漏
- **CPU 使用应优化**，避免不必要的计算
- **并发处理应优化**，合理使用 goroutine 和 channel

### 性能优化原则

- **避免过早优化**：先确保功能正确，再考虑性能优化
- **进行性能测试**：使用基准测试和性能分析工具
- **识别性能瓶颈**：使用 `pprof` 工具分析性能
- **优化关键路径**：优先优化性能关键的部分

```go
// 性能优化示例：预分配切片容量
// 好的做法
func ProcessItems(items []Item) []Result {
    results := make([]Result, 0, len(items)) // 预分配容量
    for _, item := range items {
        results = append(results, processItem(item))
    }
    return results
}

// 不好的做法
func BadProcessItems(items []Item) []Result {
    var results []Result // 可能导致多次重新分配
    for _, item := range items {
        results = append(results, processItem(item))
    }
    return results
}
```

## 可维护性要求

### 代码可读性

- **代码应该自解释**，通过良好的命名和结构表达意图
- **复杂逻辑应该添加注释**，解释"为什么"而不是"是什么"
- **函数和类型应该有清晰的注释**，说明用途和用法
- **避免魔法数字和字符串**，使用常量或配置

```go
// 好的做法：使用常量
const (
    MinUsernameLength = 3
    MaxUsernameLength = 20
    MinPasswordLength = 8
    MaxPasswordLength = 128
)

func ValidateUsername(username string) error {
    if len(username) < MinUsernameLength || len(username) > MaxUsernameLength {
        return fmt.Errorf("用户名长度必须在%d-%d个字符之间", MinUsernameLength, MaxUsernameLength)
    }
    return nil
}

// 不好的做法：魔法数字
func BadValidateUsername(username string) error {
    if len(username) < 3 || len(username) > 20 {
        return errors.New("用户名长度必须在3-20个字符之间")
    }
    return nil
}
```

### 代码组织结构

- **包应该职责清晰**，每个包应该有一个明确的职责
- **文件应该合理组织**，相关功能应该放在一起
- **依赖关系应该清晰**，避免循环依赖
- **接口应该小而专注**，遵循接口隔离原则

### 错误处理

- **所有错误都应该被正确处理**，不应忽略错误
- **错误消息应该清晰、具体**，包含上下文信息
- **使用错误包装保留错误链**，便于错误追踪
- **定义错误变量**，用于可预期的错误

```go
// 好的做法：清晰的错误处理
var (
    ErrUserNotFound    = errors.New("用户不存在")
    ErrInvalidUsername = errors.New("无效的用户名")
    ErrInvalidPassword = errors.New("无效的密码")
)

func GetUser(id int64) (*User, error) {
    user, err := db.FindUser(id)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, fmt.Errorf("获取用户失败: %w", ErrUserNotFound)
        }
        return nil, fmt.Errorf("查询用户失败: %w", err)
    }
    return user, nil
}
```

## 质量门禁标准

### CI/CD 质量门禁

代码合并到主分支前，必须满足以下所有条件：

1. **代码格式化**：所有代码必须通过 `gofmt` 格式化
2. **静态检查**：所有代码必须通过 `go vet` 和 `golangci-lint` 检查
3. **测试通过**：所有测试用例必须通过
4. **覆盖率达标**：代码覆盖率必须达到要求（80% 以上）
5. **圈复杂度**：函数圈复杂度不超过 15
6. **代码重复**：代码重复率低于 5%
7. **无安全漏洞**：静态安全检查无高危漏洞

### 质量报告

每次代码提交应该生成质量报告，包括：

- 代码覆盖率报告
- 静态检查报告
- 性能测试报告（如果适用）
- 代码质量评分

## 代码质量评分

### 评分标准

代码质量评分综合考虑以下因素：

- **测试覆盖率**（30%）：覆盖率越高，分数越高
- **代码复杂度**（20%）：复杂度越低，分数越高
- **代码重复率**（15%）：重复率越低，分数越高
- **静态检查**（20%）：问题越少，分数越高
- **代码审查**（15%）：审查通过情况

### 评分等级

- **A 级（90-100 分）**：优秀，可以直接合并
- **B 级（80-89 分）**：良好，可以合并，建议优化
- **C 级（70-79 分）**：合格，需要改进后才能合并
- **D 级（60-69 分）**：不合格，必须改进后才能合并
- **F 级（<60 分）**：严重不合格，不能合并

## 持续改进

### 质量监控

- **定期审查代码质量指标**，识别质量问题
- **分析质量趋势**，了解代码质量变化
- **收集代码审查反馈**，改进开发流程

### 质量改进

- **重构低质量代码**，提高代码质量
- **补充测试用例**，提高测试覆盖率
- **优化性能瓶颈**，提高系统性能
- **更新工具配置**，使用最新的最佳实践

### 知识分享

- **分享最佳实践**，提高团队整体质量
- **代码审查讨论**，促进知识交流
- **质量培训**，提高开发人员技能

## 总结

遵循以上代码质量规范可以确保代码的高质量和高可维护性。在开发过程中，应该：

1. **编写高质量的代码**：遵循编码规范，保持代码简洁清晰
2. **编写充分的测试**：确保测试覆盖率达标，覆盖各种场景
3. **使用质量工具**：利用工具自动检查代码质量
4. **进行代码审查**：通过同行评审提高代码质量
5. **持续改进**：不断优化代码，提高质量水平

**代码质量是一个持续的过程，需要开发团队的共同努力和持续关注。**
